<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>盒子里的猫</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hellohezhili.com/"/>
  <updated>2020-03-25T08:32:01.560Z</updated>
  <id>https://hellohezhili.com/</id>
  
  <author>
    <name>AI_Wei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OC中使用Swift混编</title>
    <link href="https://hellohezhili.com/2019/12/18/OC%E4%B8%8ESwift%E6%B7%B7%E7%BC%96/"/>
    <id>https://hellohezhili.com/2019/12/18/OC%E4%B8%8ESwift%E6%B7%B7%E7%BC%96/</id>
    <published>2019-12-17T16:00:00.000Z</published>
    <updated>2020-03-25T08:32:01.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="混编配置"><a href="#混编配置" class="headerlink" title="混编配置"></a>混编配置</h2><p>OC与Swift混编中有两个重要的头文件：桥接头文件和隐式的Swift头文件，<strong>Swift中如果要使用OC的文件，在桥接头文件中引入即可，OC中如果要使用Swift的类，则需要在OC文件中引入隐式的Swift头文件</strong>。</p><h3 id="1-桥接头文件"><a href="#1-桥接头文件" class="headerlink" title="1.桥接头文件"></a>1.桥接头文件</h3><p>文件一般命名为“xxx-Bridging-Header.h”（xxx通常为工程名），在OC项目中第一次创建Swift文件时，Xcode会提示自动创建，也可以手动创建一个.h文件，然后在<code>Build Setting -&gt; Objective-C Bridging Header</code>中指明其为桥接头文件。Swift中引用Swift类是不需要引入头文件的，Swift中如果要使用OC的类，则在桥接头文件中引入即可，在Swift文件中则既不需要引入OC的头文件，也不需要引入桥接头文件。</p><h3 id="2-Swift头文件"><a href="#2-Swift头文件" class="headerlink" title="2.Swift头文件"></a>2.Swift头文件</h3><p>文件一般命名为“xxx-Swift.h”，xxx默认为<code>$(PRODUCT_NAME)</code>，也可以通过<code>Build Setting -&gt; Product Module Name</code>指定。OC中需要使用Swift类的时候，就需要引入这个隐式的头文件，一个Target中存在Swift文件，则存在一个与Target对应的隐式的Swift头文件，但如果缺少桥接头文件，OC中引入了Target的隐式头文件也无法使用Swift的类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;混编配置&quot;&gt;&lt;a href=&quot;#混编配置&quot; class=&quot;headerlink&quot; title=&quot;混编配置&quot;&gt;&lt;/a&gt;混编配置&lt;/h2&gt;&lt;p&gt;OC与Swift混编中有两个重要的头文件：桥接头文件和隐式的Swift头文件，&lt;strong&gt;Swift中如果要使用OC的文
      
    
    </summary>
    
    
      <category term="开发笔记" scheme="https://hellohezhili.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Objective-C" scheme="https://hellohezhili.com/tags/Objective-C/"/>
    
      <category term="Swift" scheme="https://hellohezhili.com/tags/Swift/"/>
    
      <category term="混编" scheme="https://hellohezhili.com/tags/%E6%B7%B7%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>InjectionⅢ</title>
    <link href="https://hellohezhili.com/2019/03/24/injection%E2%85%A2/"/>
    <id>https://hellohezhili.com/2019/03/24/injection%E2%85%A2/</id>
    <published>2019-03-24T10:48:24.000Z</published>
    <updated>2020-04-04T15:10:59.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具简介"><a href="#工具简介" class="headerlink" title="工具简介"></a>工具简介</h2><p><a href="https://github.com/johnno1962/InjectionIII" target="_blank" rel="noopener">InjectionⅢ</a>是作者John Holdsworth开源的一款iOS热重载工具，当APP在模拟器上编译运行后，使用它可以即时的执行项目中代码的改动，无需重新编译整个项目，从而极大的提高代码的调试效率。</p><p>InjectionⅢ大概的工作原理是：</p><ul><li>在APP启动时，以加载NSBundle的形式在APP中运行一个Client端；</li><li>InjectionⅢ作为Server端监视指定目录下文件的改动，当文件发生改动时将改动的文件重新编译为一个动态库；</li><li>动态库编译完成后，通过socket通信通知Client端，让APP去加载这个动态库（dlopen）；</li><li>动态库加载完成后，再通过Runtime的class_replaceMethod将原来类中的方法都替换为动态库中新类的方法；</li><li>最后再调用文件中的类及其对象的<code>injected</code>方法，以便在其中调用修改后的代码；</li><li>最终完成了对当前文件中代码改动的动态调试；</li></ul><h2 id="工具教程"><a href="#工具教程" class="headerlink" title="工具教程"></a>工具教程</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p>InjectionⅢ可以在Mac的应用商店中下载，也可以通过源码安装：clone或者下载源码，构建源码中的InjectionⅢ.xcodeproj工程即可。如果通过源码安装，卸载时删除构建源码时生成的xcode插件即可，终端命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/InjectionPlugin.xcplugin</span><br></pre></td></tr></table></figure><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><p>首先在InjectionⅢ中通过Open Project或Add Directory添加需要监视的文件目录，并勾选File Watcher。</p><p>然后在<code>application:DidFinishLaunching:</code>中加载Injection的动态库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="comment">// iOS</span></span><br><span class="line">    [[NSBundle bundleWithPath:@<span class="string">"/Applications/InjectionIII.app/Contents/Resources/iOSInjection.bundle"</span>] load];</span><br><span class="line">    <span class="comment">// tvOS</span></span><br><span class="line"><span class="comment">//    [[NSBundle bundleWithPath:@"/Applications/InjectionIII.app/Contents/Resources/tvOSInjection.bundle"] load];</span></span><br><span class="line">    <span class="comment">// macOS</span></span><br><span class="line"><span class="comment">//    [[NSBundle bundleWithPath:@"/Applications/InjectionIII.app/Contents/Resources/macOSInjection.bundle"] load];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>再在需要被监视改动的代码文件中添加类重载后的代码执行入口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)injected</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 代码改动或调用改动的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)injected</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 代码改动或调用改动的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行工程，当控制台输出“💉 Injection connected 👍”，即表示InjectionⅢ正常运行。</p><p>APP运行中，对代码文件做出修改并通过Command+s保存后，被修改文件中的所有类的<code>+injected</code>及其对象的<code>-injected</code>方法都会被调用，在方法中<strong>直接添加调试代码或调用发生改动的代码</strong>，即可对运行中的APP进行动态调试。</p><h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.注意</h3><p>在使用InjectionⅢ时需要注意以下几点：</p><ul><li>InjectionⅢ只能在模拟器中使用，目前还不能进行真机调试；</li><li>InjectionⅢ动态调试时，新增的类/方法/属性/变量会生效，删除的类/方法/属性/变量仍然可以动态访问；</li><li>InjectionⅢ只监视当前文件的改动，如果要动态新增类，需要在当前文件中新增；</li></ul><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="Could-not-find-file"><a href="#Could-not-find-file" class="headerlink" title="Could not find file"></a>Could not find file</h3><p><strong>记录日期</strong>：2020-04-03</p><p><strong>错误提示</strong>：如下（目标、文件名等已省略）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">💉 *** Compiling /xxx.m ***</span><br><span class="line">💉 *** Re-compilation failed (... .../com.johnholdsworth.InjectionIII/Data/command.sh)</span><br><span class="line">fatal error: malformed or corrupted AST file: &apos;could not find file &apos;... .../Pods/BaiduMapKit/BaiduMapKit/BaiduMapAPI_Search.framework/Headers/BMKPOISearchResult.h&apos; referenced by AST file &apos;... .../PrefixHeader.pch.gch&apos;&apos;</span><br><span class="line">note: after modifying system headers, please delete the module cache at &apos;/... ...&apos;</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><p><strong>错误原因</strong>：PrefixHeader中引用了BaiduMapKit，而BaiduMapKit中对文件的引用（包括BMKPOISearchResult.h），有两处文件名的大小写不正确，导致InjectionⅢ对变动的文件重新编译时失败。</p><p><strong>错误分析</strong>：XCode中import文件名大小写不正确时会报“Non-portable path”的警告，在InjectionⅢ这儿即导致了重编译的失败，同时信息中也说明InjectionⅢ重编译时使用了PrefixHeader.pch等system headers的编译缓存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工具简介&quot;&gt;&lt;a href=&quot;#工具简介&quot; class=&quot;headerlink&quot; title=&quot;工具简介&quot;&gt;&lt;/a&gt;工具简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/johnno1962/InjectionIII&quot; target=&quot;_
      
    
    </summary>
    
    
      <category term="实用工具" scheme="https://hellohezhili.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="injectionⅢ" scheme="https://hellohezhili.com/tags/injection%E2%85%A2/"/>
    
  </entry>
  
  <entry>
    <title>APP架构（六）--网络</title>
    <link href="https://hellohezhili.com/2019/01/20/APP%E6%9E%B6%E6%9E%846-%E7%BD%91%E7%BB%9C/"/>
    <id>https://hellohezhili.com/2019/01/20/APP%E6%9E%B6%E6%9E%846-%E7%BD%91%E7%BB%9C/</id>
    <published>2019-01-19T16:00:00.000Z</published>
    <updated>2019-12-18T07:35:26.237Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Reference:</strong><br><em>App Architecture</em></p></blockquote><h2 id="添加网络的挑战"><a href="#添加网络的挑战" class="headerlink" title="添加网络的挑战"></a>添加网络的挑战</h2><p>为程序添加网络支持时，会面临一些额外的挑战，这不是某个架构所特有的问题，也和本节中对于网络层如何架构的讨论无关，但是对于一款需要从网络中获取数据的APP，或多或少都需要清楚对于这些问题的思考：</p><ol><li><strong>额外的失败来源</strong>：任何从网络获取数据的尝试，都可能由于一系列的理由以失败而告终。我们必须考虑如何优雅地处理这些错误，而且经常还要为展示这些错误创建额外的UI。</li><li><strong>获取最新数据副本</strong>：持续从网络监听数据要比观察本地数据困难得多，这往往导致我们需要周期性地手动获取数据。</li><li><strong>多端间的数据冲突</strong>：网络引入了多端更新同一个数据的可能性，这可能导致潜在的冲突。网络上的数据可能会有独立于app的更改、引用的资源可能会在不通知客户端的情况下直接失效、两个客户端有可能更新了同样的对象。</li></ol><blockquote><p>对于两个客户端更新了同样的对象，这必须让服务器从两者间选择出哪一个应该胜出，并且告诉每一个客户端冲突的解决方案，可以参考<a href="https://developer.apple.com/library/archive/documentation/DataManagement/Conceptual/DocumentBasedAppPGiOS/ResolveVersionConflicts/ResolveVersionConflicts.html" target="_blank" rel="noopener">iCloud关于解决文档冲突的方式</a>和<a href="https://developer.apple.com/library/archive/technotes/tn2336/_index.html" target="_blank" rel="noopener">相关思考</a>。</p></blockquote><h2 id="添加网络层的方式"><a href="#添加网络层的方式" class="headerlink" title="添加网络层的方式"></a>添加网络层的方式</h2><p>为APP添加网络层有两种常见的方式：</p><ol><li><strong>Controller层持有网络</strong>：将model层移除，并让controller来处理网络请求。数据直接从网络获取，从网络获得的数据不会被持久化，而是由controller负责将它们以处理view state相同的方式缓存在内存中。这种方式非常的简单直接，主要问题在于不同的controller之间进行数据共享变得非常麻烦。</li><li><strong>Model层持有网络</strong>：保留model层，并在model的下方加入了一个网络层。model负责触发和管理网络请求，并按照需要用请求的结果来更新model，model的变更依然通过观察者模式传递给controller。在这种方式中，封装的网络服务可以提供接口直接由model层调用，也可以观察model的变更然后进行数据同步的网络活动，后者model层和网络层之间的耦合更低；因为保留了model层，利于不同controller间数据共享的同时，也可以很方便的做离线缓存。</li></ol><h2 id="Controller层持有网络"><a href="#Controller层持有网络" class="headerlink" title="Controller层持有网络"></a>Controller层持有网络</h2><h3 id="1-获取初始数据"><a href="#1-获取初始数据" class="headerlink" title="1.获取初始数据"></a>1.获取初始数据</h3><p>controller发起网络请求，并且在数据返回时对view进行配置，controller只维护前一次请求所获取的数据的内存缓存。因为网络获取数据是一种延时操作，所以需要添加数据获取过程处于不同的状态、已经状态变更的额外逻辑。</p><h3 id="2-更改数据"><a href="#2-更改数据" class="headerlink" title="2.更改数据"></a>2.更改数据</h3><p>数据的更改现在也是一个通过网络执行的异步任务，view action传递到controller中，controller发起数据变更的网络请求，并且在数据返回时更新view。</p><h3 id="3-思考-amp-讨论"><a href="#3-思考-amp-讨论" class="headerlink" title="3.思考&amp;讨论"></a>3.思考&amp;讨论</h3><p>Controller层持有网络将大量的新的职责放到了controller中，包括发起网络请求，处理结果，以及处理网络失败等，这可以通过将这些代码封装为网络服务来减少controller中的代码。不过在这种方式还存在其他弊端：controller负责进行网络请求并持有数据，实际上数据的逻辑已经等同于view state，如果app中没有其他部分依赖这些数据，这种方式也可以良好工作，但如果数据需要在不同controller中进行使用，缺少model层让数据共享变得更加麻烦，而且即使当前不需要共享，也需要考虑到未来可能会有变更，所以从一开始就选择对未来友好的方式可能会更加明智。</p><h2 id="Model层持有网络"><a href="#Model层持有网络" class="headerlink" title="Model层持有网络"></a>Model层持有网络</h2><h3 id="1-加载初始数据"><a href="#1-加载初始数据" class="headerlink" title="1.加载初始数据"></a>1.加载初始数据</h3><p>创建model对象，调用model的数据加载方法，在model的方法中，去触发相应的网络请求，根据请求的结果，model更新自己，而controller则观察model的变更并更新相应的view即可。</p><h3 id="2-更改数据-1"><a href="#2-更改数据-1" class="headerlink" title="2.更改数据"></a>2.更改数据</h3><p>controller与model进行交互，就好像model只是本地数据一样，网络则发生在model层的背后。但对于model如何触发网络请求，则有两种不同的可选方式：</p><ol><li><strong>model直接发起网络请求</strong>：在model数据变更的相应接口中，直接发起网络请求，同步数据的变更。</li><li><strong>网络服务观察model的变更</strong>：封装的网络服务观察model，model在数据变更时触发某种通知，网络服务在接收到信号时，再发起相应的网络请求。</li></ol><p>第二种方式让model层和网络层进一步的解耦，同时因为封装了相应的网络服务，可以使用一个更改队列来对这一类网络请求做统一管理，并对待处理更改队列进行持久化，这样即使APP离线时(断网、退出、崩溃)本地更改也不会丢失。</p><h3 id="3-讨论-amp-思考"><a href="#3-讨论-amp-思考" class="headerlink" title="3.讨论&amp;思考"></a>3.讨论&amp;思考</h3><p>model持有网络为代码增加了一些复杂度，但也具有更多的能力：保留了model，让controller之间的数据共享更加方便，同时也很容易做数据的离线缓存；通过添加网络服务部件来管理数据同步的网络请求，可以在APP中立即更新数据，而不用等服务器的响应，但同时也需要增加额外的代码，来追踪未提交的变更，并对变更提交是可能发生的冲突进行处理。<strong>持有网络是对APP未来变更和扩展更加友好的方式，是更加推荐的网络层架构模式</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;&lt;br&gt;&lt;em&gt;App Architecture&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;添加网络的挑战&quot;&gt;&lt;a href=&quot;#添加网络的挑战&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="APP架构" scheme="https://hellohezhili.com/categories/APP%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="APP架构" scheme="https://hellohezhili.com/tags/APP%E6%9E%B6%E6%9E%84/"/>
    
      <category term="AppArchitecture" scheme="https://hellohezhili.com/tags/AppArchitecture/"/>
    
      <category term="网络层" scheme="https://hellohezhili.com/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>APP架构（五）-- MVC+VS</title>
    <link href="https://hellohezhili.com/2019/01/12/APP%E6%9E%B6%E6%9E%845-MVC-VS/"/>
    <id>https://hellohezhili.com/2019/01/12/APP%E6%9E%B6%E6%9E%845-MVC-VS/</id>
    <published>2019-01-11T16:00:00.000Z</published>
    <updated>2019-12-18T07:35:28.074Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Reference:</strong><br><em>App Architecture</em></p></blockquote><p>MVC+VC是MVC的一种变体，所不同的是它将view state视为model层的一部分，用view state model进行存储，ViewController观察view state model，并且相应地更新 view 层级。</p><p><strong>MVC+VS中的反馈回路</strong>：<br><img src="APP架构5-MVC-VS/15626012236605.jpg" alt></p><p>MVC+VS对MVC的改进在于：提供了一种一致的处理view state变更的方法，让view state可以被持久化，同时对view state的数据管理也变成了单向数据流。</p><p><strong>MVC+VC中view state的数据流</strong>：<br><img src="APP架构5-MVC-VS/15712756097966.jpg" alt></p><p>除了对view state的处理变成了单向数据流，MVC+VS中对view state使用model抽象还带来了三点好处：</p><ol><li>Model通过接口和程序其余部分交流，在有需要时，对接口中的实现进行替换，并不会影响到接口和对接口的使用</li><li>Model为action提供了单一的事实来源，让重构和测试可以只关注单一的某个点</li><li>对Model的观察和响应可以被不同的action重用，所以结构的扩展性会更好</li></ol><p><strong>关于view state model有两点需要特别注意</strong>：</p><ul><li>虽然<strong>view state model</strong>与<strong>文档(数据)model</strong>是同一层抽象，并遵循相同的使用规则，但还是应该保持分离，这是因为文档(数据)与view state生命周期并不相同</li><li>view state model中仅仅是存储了代表view state的简单值，并不包含对数据的变形(这部分逻辑依然写在ViewController中)，这是其和MVVM中的view-model最本质的区别</li></ul><h2 id="一、MVC-VS的实现"><a href="#一、MVC-VS的实现" class="headerlink" title="一、MVC+VS的实现"></a>一、MVC+VS的实现</h2><h3 id="1-构建"><a href="#1-构建" class="headerlink" title="1.构建"></a>1.构建</h3><p>与MVC和MVVM中先构建ViewController不同，MVC+VS中需要首先构建view state，然后在view state所触发的观察回调中，去构建ViewController，再由ViewController构建其他部件。但由于view state的观察者就是ViewController，因此在view state的构建之前需要至少一个ViewController，所以第一个ViewController即Root ViewController比较特殊，它在view state之前构建。</p><h3 id="2-将View连接到数据"><a href="#2-将View连接到数据" class="headerlink" title="2.将View连接到数据"></a>2.将View连接到数据</h3><p>MVC+VS从view state model和文档(数据)model中拉取数据，并订阅这些数据，然后将这些数据关联到view上去。需要注意的是MVC+VS的标准模式是，文档(数据)model对象的标识应该存储在view state model中，这就意味着对文档(数据)model的观察是依赖于view state的，对文档(数据)model的观察必须在对view state model的观察之后。</p><blockquote><p>绝大多数应用场景中，ViewController的文档(数据)model的标识符在ViewController的生命周期中都不会更改，但如果有需要改变的情况，必须在view state model的观察回调里面，重新加载文档(数据)model，并重新创建创建对文档(数据)model的观察。</p></blockquote><h3 id="3-更改Model"><a href="#3-更改Model" class="headerlink" title="3.更改Model"></a>3.更改Model</h3><p>更改model的回路MVC+VS和MVC中是一样的：view将action传递给ViewController，ViewController直接更改<em>model</em>，同时ViewController中观察了<em>model</em>，当<em>model</em>变更时做相应的view更新。</p><h3 id="4-更改View-State"><a href="#4-更改View-State" class="headerlink" title="4.更改View State"></a>4.更改View State</h3><p>MVC+VS为view state的处理添加了一条和文档数据处理相似的路径：view将action传递到ViewController，ViewController更改<em>view state model</em>，同时ViewController中观察了<em>view state model</em>，当<em>view state model</em>变更时做相应的view更新。</p><blockquote><p>####状态恢复<br>MVC+VS的架构在view state model中维护了完整的view state，将view state model序列化保存，再根据其构建ViewController和ViewController的层级，即可完成状态恢复，状态恢复时的代码路径和初始构建的代码路径是一致的。</p></blockquote><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h3><p>MVC+VS和MVC中都使用集成测试，但实现上有很大的不同，<strong>第一个不同在于MVC+VS中不再需要先构建ViewController树</strong>，而是构建Root ViewController和view state model即可，包括ViewController树在内的其余部分都将作为view state的响应被自行创建出来。这样就可以通过提供view state model作为根ViewController的输入，以特定的状态构建出app的一个新的实例(状态恢复)。</p><p><strong>MVC+VS书写测试时的另外一个不同在于研究对action的响应时</strong>，MVC中研究对action的响应，可能需要等待动画或其他异步更改的完成，MVC+VS中“对于view action的响应所造成的view state更改” 与 “view state更改引起view层级中的更新”这两段路径的测试是可以分离开的。也就是说可以直接验证view state来确保某个action确实对数据进行了合适的变更，而不需要等待action执行动画并且最终更新view，这部分路径的测试代码会变得好写很多。至于view state的变更引起view更新的这段路径，则可以为它编写单独的测试。</p><h2 id="二、MVC-VS的优缺点"><a href="#二、MVC-VS的优缺点" class="headerlink" title="二、MVC+VS的优缺点"></a>二、MVC+VS的优缺点</h2><p>MVC+VS最大的好处在于为view state变更的通讯创建了一致的机制，对view state使用观察者模式也保证了UI的同步；同时原本发生在ViewController之间的通讯，现在也可以通过view state来完成；最后，因为view state model上维护了完整的view state，所以也能很方便的完成状态日志、状态恢复、时间旅行调试等功能。</p><p>MVC+VS在实践中一个比较麻烦的问题在于<strong>并不是总能在UIKit更新view层级之前捕获到view state的变化</strong>，比如NavigationController返回按钮和返回手势所引起的层级变动，这需要我们设置NavigationController的delegate，在页面层级变动完成，而这种<strong>变动又不是由view state的变更所引起时</strong>(由返回按钮和返回手势所引起)，去对view state进行更新和处理，其他类似的情况也需要我们去添加代码支持。</p><h2 id="三、MVC-VS架构的优秀经验"><a href="#三、MVC-VS架构的优秀经验" class="headerlink" title="三、MVC+VS架构的优秀经验"></a>三、MVC+VS架构的优秀经验</h2><h3 id="1-数据的依赖注入"><a href="#1-数据的依赖注入" class="headerlink" title="1.数据的依赖注入"></a>1.数据的依赖注入</h3><p>在对象初始化的时候将数据作为参数传递进去就叫依赖注入，在MVC+VS中为ViewController设置初始的view state model时便是选用的这种方式，这样可以避免直接访问单例，更方便书写测试，同时这也比初始化时先设置为nil再等之后提供非nil的方式更加简单，这种方式也可以用于其他基于ViewController的模式中。</p><h3 id="2-全局View-State通讯"><a href="#2-全局View-State通讯" class="headerlink" title="2.全局View State通讯"></a>2.全局View State通讯</h3><p>但view state会被多个ViewController或view共享时，使用单例来保存view state以提供全局的view state通讯，往往比在这些ViewController或view的共同祖先中保存view state更加的简单直接，它还不需要去考虑ViewController或view层级间的通讯管道。</p><h3 id="3-简化本地View-State"><a href="#3-简化本地View-State" class="headerlink" title="3.简化本地View State"></a>3.简化本地View State</h3><p>可以把一个简化版的MVC+VS应用到MVC的单个ViewController中：将部分view state抽象出来，用一个对象存储(字典或自定义类)，将这个对象设置为ViewController的属性，并对这个属性进行观察，在该属性变更的时候对view做这部分view state的更新，这种方式在一定程度上能缓解复杂的ViewController中view state的交互问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;&lt;br&gt;&lt;em&gt;App Architecture&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MVC+VC是MVC的一种变体，所不同的是它将view state视为model层的一部分，
      
    
    </summary>
    
    
      <category term="APP架构" scheme="https://hellohezhili.com/categories/APP%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="APP架构" scheme="https://hellohezhili.com/tags/APP%E6%9E%B6%E6%9E%84/"/>
    
      <category term="App Architecture" scheme="https://hellohezhili.com/tags/App-Architecture/"/>
    
      <category term="MVC+VS" scheme="https://hellohezhili.com/tags/MVC-VS/"/>
    
  </entry>
  
  <entry>
    <title>APP架构（四）-- MVVM+C</title>
    <link href="https://hellohezhili.com/2019/01/06/APP%E6%9E%B6%E6%9E%844-MVVM/"/>
    <id>https://hellohezhili.com/2019/01/06/APP%E6%9E%B6%E6%9E%844-MVVM/</id>
    <published>2019-01-05T16:00:00.000Z</published>
    <updated>2019-12-18T07:35:30.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Reference:</strong><br><em>App Architecture</em></p></blockquote><p>Model-View-ViewModel(MVVM)是一种基于MVC进行改进的模式，它将所有model相关的任务（观察model变更，将model数据变形，以及更新model）从controller层抽离出来，放到新的叫做view-model的一层对象中。引入view-model层的主要目的有两点：</p><ol><li>鼓励将model和view之间的关系构建为一系列的变形管道。</li><li>将view应该展示的状态通过一套独立于app框架的接口进行呈现。</li></ol><p>在MVVM中为了保持view与view-model的同步，MVVM强制使用某种形式的绑定，这通常通过响应式编程来完成。MVVM在一定程度上解决了MVC最大的两个问题，首先通过将model观察的代码以及其他显示和交互逻辑移动到围绕着数据流构建的隔离的view-model中，解决了MVC中ViewController里不规则的状态交互所带来的有关问题，在很大程度上缓解了ViewController肥大的问题；然后view-model还为场景的view state提供了一套干净的接口，让它可以独立于app框架进行测试，解决了MVC难以测试的问题。</p><p><strong>MVVM+C中APP的反馈回路</strong>：<br><img src="APP架构4-MVVM/15694650751590.jpg" alt>  </p><p>在MVVM+C中，协调器在APP启动完成的最后阶段创建，对于MVVM而言，协调器并非是强制需要的部件，但引入协调器来负责维护ViewController的层级，可以进一步分担ViewController的工作，让其变得更加的简单，这符合MVVM的架构思路，协调器分担的职责主要为：管理其他controller的展示，同时协调model数据和controller之间的通讯。协调器的工作方式有两种：</p><ol><li>作为ViewController的delegate，ViewController把导航行为直接转发给协调器。</li><li>把导航行为先转发给view-model，然后让协调器去观察view-model，以获取导航事件。</li></ol><p>第一种更加简单直接，但如果导航事件是依赖于当前view的状态或者model数据的话，第二种做法将更加合理，同时第二种做法也更利于代码测试。</p><h2 id="一、MVVM的实现"><a href="#一、MVVM的实现" class="headerlink" title="一、MVVM的实现"></a>一、MVVM的实现</h2><h3 id="1-构建"><a href="#1-构建" class="headerlink" title="1.构建"></a>1.构建</h3><p>MVVM构建的方式和MVC很相似：ViewController充分了解程序的结构，并且对其它所有部件进行构建和连接。此外，相比起MVC主要有三点不同：</p><ol><li>必须创建view-model。</li><li>必须建立起view-model和view之间的绑定。</li><li>Model由view-model拥有，而不是由controller所拥有。</li></ol><p>view-model的创建有在ViewController创建时创建默认值、作为参数传递给ViewController的依赖注入、和在ViewController加载后延迟创建三种方式。</p><h3 id="2-将View连接到数据"><a href="#2-将View连接到数据" class="headerlink" title="2.将View连接到数据"></a>2.将View连接到数据</h3><p>在MVVM+C中，将View连接到数据的数据管道：</p><ol><li>协调器为每个ViewController的view-model设置初始的model对象。 </li><li>view-model将设定值和其他model数据及观察量进行合并。</li><li>view-model将数据变形为view所需要的形式。</li><li>ViewController使用响应式编程框架来将准备好的值绑定到各个view上去。</li></ol><h3 id="3-更改Model"><a href="#3-更改Model" class="headerlink" title="3.更改Model"></a>3.更改Model</h3><p>MVVM-C中，View Action的事件回路和在MVC中各层之间的路径相似，不同在于，在ViewController和model之间插入了一层额外的用于协调的view-model：</p><ol><li>view通过target/action机制、delegate、或者响应式编程框架扩展，将View Action传递给ViewController；</li><li>ViewController接收到View Action时调用view-model的相应接口；</li><li>view-model的接口中直接更改model；</li><li>view-model观察model的变更，并在变形后通过可观察值暴露给ViewController；</li><li>ViewController中已经将可观察值和view进行了绑定，将会在这些值变化是更新view。</li></ol><h3 id="4-更改View-State"><a href="#4-更改View-State" class="headerlink" title="4.更改View State"></a>4.更改View State</h3><p>同MVC一样，部分view state依然隐式存储在view中，但原本那些由ViewController通过属性所保存的view state，在MVVM-C中由view-model显式地进行表示。view-model只负责那些会被view行为影响的view state，对于既不依赖于任何的view-model属性，也不是view-model所依赖的view state，并不需要通过view-model管理。</p><p>更改view state的事件回路和更改model的事件回来近似，只是少了view-model更改model，并观察model的变更且变形为可观察值的步骤：</p><ol><li>view通过target/action机制、delegate、或者响应式编程框架扩展，将View Action传递给ViewController；</li><li>ViewController接收到View Action时调用view-model的相应接口；</li><li>view-model的接口中直接更改自己存储的view state可观察值；</li><li>ViewController中已经将可观察值和view进行了绑定，将会在这些值变化是更新view。</li></ol><p>对于影响ViewController层级的view state变更，MVVM+C中根据协调器的工作方式不同，可以由ViewController通过delegate直接将事件传递给协调器处理，也可以将事件处理为view-model的可观察值，协调器订阅这些课观察者，当消息触发时，做相应的视图层级管理。</p><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h3><p>MVVM通过引入view-model层，提供了清晰且独立于app框架的接口，所以对于view-model及以下层次的代码，使用接口测试将非常方便，而对ViewController及View中的代码逻辑的测试则依赖于Xcode的UI测试或人工测试。MVC使用的集成测试，更偏向于功能而不是代码，虽然代码覆盖率比接口测试更高，但却难以编写和维护；相比而言，MVVM的接口测试由于只需要关注自己编写的view-model和接口，而且很少需要异步测试，其编写和维护都有方便得多。</p><p>接口测试的经典模式是：构建输入，再构建用来传递输入的接口，然后从接口中读取结果。MVVM中在配置测试环境和数据后，需要做的测试工作主要包括展示测试和行为测试：</p><ul><li><strong>展示测试</strong>：对view-model上所暴露的每一个可观察量，对初始值进行测试然后执行操作，并测试后续的条件。</li><li><strong>行为测试</strong>：测试初始条件，执行操作，然后测试接下来的条件。</li></ul><h2 id="二、MVVM的优缺点"><a href="#二、MVVM的优缺点" class="headerlink" title="二、MVVM的优缺点"></a>二、MVVM的优缺点</h2><p>MVVM的优点主要是低耦合和方便测试，此外的利于分工合作和方便代码迁移和复用，都是低耦合的延伸。MVVM也有一些自身的缺点，它们主要体现在：</p><ol><li><strong>更多的代码</strong>：因为引入view-model层，最直观的感受就是类变得更多，在处理简单的场景时代码量增多，但在处理相对复杂的状态交互时，MVVM更加清晰的逻辑，反而会让编码工作变得更加简单。</li><li><strong>更难以调试的BUG</strong>：MVVM一般选用响应式编程来做数据绑定，这会使得一处的BUG被快速的传递到别的地方，当你在某处发现问题时，定位它是因为数据变形管道上的哪一步出了BUG，将会更加的不容易。</li><li><strong>不利于重用的view</strong>：有的MVVM中对于view采用双向绑定，不仅将model的数据绑定到view上，还将view的action和model进行绑定，这将降低view的可重用性，应避免对view使用双向绑定，而是应该将view的action通过通用的方式传递给ViewController，再由ViewController调用view-model的接口做相应处理。</li><li><strong>基于响应式编程</strong>：MVVM中通常都会使用响应式编程来做数据绑定，这比其它方案更加方便简洁，响应式编程的学习曲线稍加陡峭，但理解响应式编程对编码工作者绝对大有裨益。</li></ol><h2 id="三、MVVM与响应式编程"><a href="#三、MVVM与响应式编程" class="headerlink" title="三、MVVM与响应式编程"></a>三、MVVM与响应式编程</h2><p>响应式编程是一种用来描述数据源和数据消费端之间数据流动的模式，响应式编程将这种流动描述为一个变形管道。MVVM并非必须使用响应式编程，但观察model数据并将其变形为view-model上的一系列可观察值，再在ViewController中将这些可观察值绑定到view上，对于这条路径，在MVVM中通常是推荐使用响应式编程来完成，也可以使用基于KVO等技术的其他方案，但那需要做更多的额外工作，而且使用起来也没有响应式编程这种对口的方案方便。</p><h2 id="四、MVVM架构的优秀经验"><a href="#四、MVVM架构的优秀经验" class="headerlink" title="四、MVVM架构的优秀经验"></a>四、MVVM架构的优秀经验</h2><h3 id="1-引入额外的层"><a href="#1-引入额外的层" class="headerlink" title="1.引入额外的层"></a>1.引入额外的层</h3><p>MVVM在MVC基础上引入view-model这额外的一层抽象来构建数据管道，将抽象的数据(model中的)变形为特定的数据(view里的)，这种模式也可以在程序中的其他部分使用，例如：</p><ul><li><strong>App-model</strong>：构建一个App-model，将用户凭证、系统服务信息(如网络是否可用)等数据合并、变形，然后作为可观察值提供给其他view-model使用，这种model也可以称之为setting-model。</li><li><strong>Session-model</strong>：用于追踪当前登录会话的细节，可能需要在view-model和主 model之间，或者view-model和其他接口之间，进行网络请求的处理。</li><li><strong>数据流-model</strong>：model版本的协调器，用来将导航状态作为数据进行建模，并将导航状态和model数据合并，直接为view-model提供可观察的model数据。</li><li><strong>Use case</strong>：Use case指的是那些用来对主model进行切片准备，并且用来简化所要执行操作的任意类型的接口或者model。Use case和view-model很像，但是它并不被绑定在一个单独的ViewController上，而是可以在view-model之间进行传递或者共享，从而在多个view-model中提供可重用的功能。当一个app有多个view显示同样的底层数据时，我们可以使用共通的Use case对象来对从model获取数据和将数据写回model的操作进行简化。</li></ul><h3 id="2-引入协调器"><a href="#2-引入协调器" class="headerlink" title="2.引入协调器"></a>2.引入协调器</h3><p>协调器是独立于MVVM的模式，它也可以用于其他APP架构中，通过引入协调器可以减轻ViewController的职责，让ViewController无需知道其他ViewController的信息，同时也让页面层级管理的逻辑集中在了一起，方便代码的维护。</p><h3 id="3-分离数据变形"><a href="#3-分离数据变形" class="headerlink" title="3.分离数据变形"></a>3.分离数据变形</h3><p>MVVM中通过view-model将数据变形的逻辑从ViewController中抽离了出来，这种分离让ViewController变得更加整洁，让数据变形的代码更加清晰，同时也更易于测试。如果有需要，即使不是在MVVM中，也可以通过添加辅助对象来同样的对数据变形逻辑进行分离，特别是数据变形牵涉到比较多的数据和逻辑的时候。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;&lt;br&gt;&lt;em&gt;App Architecture&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Model-View-ViewModel(MVVM)是一种基于MVC进行改进的模式，它将所有
      
    
    </summary>
    
    
      <category term="APP架构" scheme="https://hellohezhili.com/categories/APP%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="APP架构" scheme="https://hellohezhili.com/tags/APP%E6%9E%B6%E6%9E%84/"/>
    
      <category term="App Architecture" scheme="https://hellohezhili.com/tags/App-Architecture/"/>
    
      <category term="MVVM" scheme="https://hellohezhili.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>APP架构（三）-- MVC</title>
    <link href="https://hellohezhili.com/2018/12/22/APP%E6%9E%B6%E6%9E%843-MVC/"/>
    <id>https://hellohezhili.com/2018/12/22/APP%E6%9E%B6%E6%9E%843-MVC/</id>
    <published>2018-12-21T16:00:00.000Z</published>
    <updated>2019-12-18T07:35:32.936Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Reference:</strong><br><em>App Architecture</em></p></blockquote><p>MVC基于经典的面向对象原则:<strong>对象在内部对它们的行为和状态进行管理，并通过类和协议的接口进行通讯</strong>。MVC中<u>view对象通常是自包含且可重用的</u>；<u>model对象独立于表现形式之外，且避免依赖程序的其他部分</u>；controller层负责将model层和view层撮合到一起工作，<u>controller对另外两层进行构建和配置，并对model对象和view对象之间的双向通讯进行协调</u>。</p><p><strong>MVC中APP的反馈回路</strong>：<br><img src="APP架构3-MVC/15694647105186.jpg" alt></p><p>iOS中标准的MVC是三种不同的子模式的集合:</p><ol><li><strong>组合模式：</strong>view被组装成为层级，该层级按组区分，由controller对象进行管理</li><li><strong>策略模式：</strong>controller对象负责协调view和model，并且对可重用的、独立于app的view在app中的行为进行管理</li><li><strong>观察者模式：</strong>依赖于model数据的对象必须订阅和接收更新</li></ol><p>在所有模式中，MVC通常都是代码量最少，设计开销最小的模式。MVC模式有两个主要的缺陷，其一是view controller拥有太多的职责，所导致的“massive view controller”；同时MVC也难以测试，特别是单元测试和接口测试非常困难，而比较可行的集成测试的编写也并非易事。</p><h2 id="一、MVC的实现"><a href="#一、MVC的实现" class="headerlink" title="一、MVC的实现"></a>一、MVC的实现</h2><h3 id="1-构建"><a href="#1-构建" class="headerlink" title="1.构建"></a>1.构建</h3><p>Cocoa MVC程序的创建过程会完成对三个对象的创建：<strong>UIApplication对象，Application delegate，以及主窗口的根ViewController</strong>。<br>这三个对象的默认配置文件分别为：<strong>Info.plist，AppDelegate和Main.storyboard</strong>。<br>同时它们又提供了对后续启动流程进行配置的地方，这三个对象都属于Controller层级，所以说Controller层负责了所有的构建工作。</p><p>MVC app中的View不直接引用model对象，View将保持独立可重用，model对象将被存储在ViewController中，ViewController将变成了个不可重用的类，model对象赋予了ViewController对应的身份。</p><h3 id="2-将View连接到数据"><a href="#2-将View连接到数据" class="headerlink" title="2.将View连接到数据"></a>2.将View连接到数据</h3><p><strong>在MVC中Controller根据初始的model对View进行配置，并观察model，在model的变更通知到到达时做相应的View变更。</strong></p><p>在ViewController上设置一个初始model值时，有三种不同的方式:</p><ol><li>通过判定controller在controller层级上的位置以及controller的类型，直接访问一个全局的model对象</li><li>开始时将model对象的引用设置为nil并让所有东西保持为空白状态，直到另一个controller提供了一个非nil值</li><li>在controller初始化时将model对象当作参数传递进来(也就是依赖注入)</li></ol><p>在构建阶段结束后，<strong>对于view层级的变更应该遵循MVC中观察者模式的部分，只发生在观察的回调中</strong>。</p><p><strong>观察者模式是在MVC中维持model和view分离的关键</strong>。这种方式的优点在于，不论变更究竟是源自哪里(比如，view事件、后台任务或者网络)，我们都可以确信UI是和model数据同步的。而且，在遇到变更请求时，model将有机会拒绝或者修改这个请求，即使model被以其他方式(比如一个网络事件)改变，或者是model拒绝这次变更时，UI也会正确更新。<strong>这是一种确保view层始终与model层同步的十分健壮的方式</strong>。</p><h3 id="3-更改Model"><a href="#3-更改Model" class="headerlink" title="3.更改Model"></a>3.更改Model</h3><p>View Action的事件回路：</p><ol><li>view通过target/action机制和delegate等方式将View Action传递给ViewController；</li><li>ViewController接收到变更model的View Action时直接更改model；</li><li>ViewController通过观察者模式响应model变更并更新view。</li></ol><h3 id="4-更改ViewState"><a href="#4-更改ViewState" class="headerlink" title="4.更改ViewState"></a>4.更改ViewState</h3><p>MVC的model层起源于典型的基于文档的app：任何在保存操作中写入文档的状态都被当作是model的一部分来考虑。<strong>其他的任意状态（包括像是导航状态，临时的搜索和排序值，异步任务的反馈以及未提交的更改）传统意义上是被排除在MVC的model定义之外的，我们把这些状态统称为view state</strong>。在MVC中，这些被我们统称为view state的“其他”状态没有被包含在模式的描述中。</p><p><em>依照传统的面向对象的原则，任意的对象都可以拥有内部状态，这些对象也不需要将内部状态的变化传达给程序的其余部分</em>。基于这种内部处理，view state不需要遵守任何一条程序中的清晰路径。任意view或者controller都可以包含状态，这些状态由View Action进行更新。view state的处理尽可能地在本地进行:<strong>一个view或者ViewController可以独自响应用户事件，对自身的view state进行更新</strong>。</p><p>如果想要在view层级的不同部分共享view state，有两种方式：</p><ol><li>找到它们共同的祖先，并在那儿管理状态</li><li>使用单例来管理状态</li></ol><p>实际操作中，将view state放到层级的顶层controller对象中的做法（即第一种方式）并不常⻅，因为这会要求层级的每一层之间存在通讯的管道。</p><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h3><p>自动测试可以由好几种不同形式进行。从最小的粒度到最大的粒度，它们包括:</p><ul><li>单元测试：将独立的函数独立出来，并测试它们的行为</li><li>接口测试：使用接口输入并测试接口输出得到的结果，输入和输出通常都是函数</li><li>集成测试：在整体上测试程序或者程序的主要部分</li></ul><p>单元测试只花了十多年的时间就成为了app中最常⻅的测试方式。不过即使是现在，许多app除了人工测试以外并没有进行常规的自动测试。如果想要在代码层级对MVC的controller和model层进行自动测试，可行的选项是写集成测试，但想要正确书写集成测试，需要大量关于Cocoa框架是如何操作的知识，这并非易事。在MVC中，我们需要从window开始构建ViewController树和view树，在树构建出来后便可以选择以新创建出来的树作为单个集成测试单元进行测试：书写代码触发事件，然后与我们的预期进行验证。</p><h2 id="二、MVC的问题"><a href="#二、MVC的问题" class="headerlink" title="二、MVC的问题"></a>二、MVC的问题</h2><h3 id="观察者模式失效"><a href="#观察者模式失效" class="headerlink" title="观察者模式失效"></a>观察者模式失效</h3><p>第一个问题是，model和view的同步可能失效。当围绕model的观察者模式没有被完美执行时，这个问题就会发生。常⻅的错误是，在构建view时读取了model的值，而没有对后续的通知进行订阅。另一个常⻅错误是在变更model的同时去更改view层级。解决方法只有严格地遵守观察者模式：当读取model值时，也需要对它进行订阅。</p><h3 id="肥大的ViewController"><a href="#肥大的ViewController" class="headerlink" title="肥大的ViewController"></a>肥大的ViewController</h3><p>ViewController需要负责处理view层(设置view属性，展示view等)，但是它同时也负责controller层的任务(观察model以及更新view)，最后，它还要负责model层(获取数据，对其变形或者处理)。结合它在架构中的中心⻆色，这使得我们很容易在不经意间把所有的职责都赋予ViewController，从而迅速让程序变得难以管理。</p><p><strong>关于肥大的ViewController最主要的争论不是关于代码的行数，而在于所保存的状态的数量</strong>。当整个文件就像ViewController这样是一个单独的类的时候，所有的可变状态都将被文件中的各个部分共享，每个函数需要精诚合作，来共同读取和维护这些状态，避免彼此矛盾，这无疑是会让代码的可读性和可维护性都越来越差。</p><h2 id="三、MVC的改进"><a href="#三、MVC的改进" class="headerlink" title="三、MVC的改进"></a>三、MVC的改进</h2><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>最好是有一种方式，能让对View的初始设定和在viewDidLoad中对model建立观察者之间没有时间空隙。<strong>使用键值观察(KVO)来替代通知是可选项之一</strong>，但是，在大部分情况下这通常需要同时观察多个不同的键路径，这让KVO和通知的方式相比，实际上并没有更加稳定。在Swift中KVO由于需要每个被观察的属性都声明为dynamic，这也让它在Swift中远远没有在Objective-C中那样流行。</p><p>对观察者模式最简单的改进方式是，<strong>将Noti􏰊cationCenter进行封装并为它实现KVO所包含的初始化的概念</strong>。这个概念会在观察被建立的同时发送一个初始值，这允许我们将设定初始值和观察后续值的操作合并到一个单一管道中去。另外一种可行的思考是，<strong>将观察者模式替换为在MVVM中比较常用的响应式编程</strong>，这样可以借助一些响应式编程框架，将对初始值的设定与后续观察都合并在一次订阅操作中，同时也保证了model与view的同步，例如在ReactiveCocoa中，对KVO的封装也让这类代码的书写非常地方便。</p><h3 id="肥大ViewController的问题"><a href="#肥大ViewController的问题" class="headerlink" title="肥大ViewController的问题"></a>肥大ViewController的问题</h3><p>ViewController主要的工作为：观察model，展示view，为它们提供数据，以及接收View Action。造成肥大ViewController的原因就是ViewController通常还负责了主要工作之外的无关工作，这些额外的工作<strong>有的应该被分散到较小层级的Controller中</strong>，这些Controller各自管理一个较小部分的view；<strong>有的则可以通过接口和抽象将其封装起来</strong>，作为工具类使用；<strong>还有的功能则是应该移动到model层中</strong>，比如排序、数据获取和处理等方法，它们与app的数据和专用逻辑相关，把它们放在model中会是更好的选择。</p><p>所以解决肥大ViewController的主要思路有：</p><ul><li><strong>使用较小层级的Controller</strong><br>通过将主要的view的逻辑分散到它们自己的更小的controller中，简化场景的view依赖，在父ViewController中剩下的工作就只有集成和布局了</li><li><strong>将部分任务封装成工具类</strong><br>可以创建工具类来执行像是获取用户位置信息这种异步任务，这样，在controller中需要的代码就只是创建任务和回调闭包</li><li><strong>将数据相关的逻辑放在model中</strong><br>例如排序、数据获取和处理等方法，包括数据网络层的获取与处理，交由model管理将更加的合理</li></ul><p><strong>属于各个部件的逻辑应当尽可能地集成到各自的部件中去</strong>，将部分ViewController中的代码抽离出来，在本质上并没有降低整个程序的复杂度，但是这么做确实降低了ViewController本身的复杂度。</p><p>降低ViewController的复杂度的其他手段还包括：</p><ol><li><p><strong>使用代码而不是segue</strong><br>如果不使用segue，而是选择用代码来定义view层级，能在构建阶段有更多的控制力，其中最大的优点在于，可以更好地掌控依赖，这样可以让页面跳转时对ViewController的配置更加的方便可控。</p></li><li><p><strong>在扩展中进行代码重用</strong><br>在不同的ViewController间共享代码，最常⻅的方法是创建一个包含共通功能的父类，另一种选择是使用扩展(类别)。相较于继承，这种重用代码的方式，在降低ViewController复杂度的同时，并没有提高继承链的复杂度。</p></li><li><p><strong>利用ChildViewController进行代码重用</strong><br>ChildViewController是在ViewController之间共享代码的另一种选项，它符合使用较小层级Controller的思路，是降低ViewController复杂度同时提高代码重用的有效方式。</p></li><li><p><strong>提取协调controller</strong><br>许多大的ViewController都有很多⻆色和职责，除了一些具体的任务可以抽离成工具类之外，其他的一些职责事务也可以通过对象提取出来，对这些提取出来的事务对象做泛型抽象后，还能在其他有相似事务的ViewController中重用  </p><blockquote><p>苹果将controller的主要职责分为协调controller(coordinating controller)和调解controller(mediating controller)。一个协调controller是app特定的，而且一般来说是无法重用的(即ViewController的主要工作部分)。调解controller则是一个可重用的controller对象，通过配置，它可以被用来执行特定的任务。通常，用来遵守某个协议的代码(比如ViewController中遵守UITableViewDataSource的部分)，比较适合被提取为调解controller，再将提取出来的对象进行泛型抽象，让部分差异化逻辑通过block等方式从外面传递进来，这个提取出来的对象，便能用于有相似调解controller逻辑的ViewController中。需要注意的是，分离controller的逻辑能降低ViewController的复杂度，但是当两个部件紧密耦合在一起，并且需要对很多状态进行通讯和共享的时候，分离后所带来的开销可能会非常大，反而使得事情变得更加复杂，这时不分离反而是更好的选择。</p></blockquote></li><li><p><strong>简化View配置代码</strong><br>如果ViewController需要构建和更新非常多的view，那么将这部分view配置的代码提取出来，对于降低ViewController的复杂度也非常有效，特别是对于那些不需要双向通讯的配置</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;&lt;br&gt;&lt;em&gt;App Architecture&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MVC基于经典的面向对象原则:&lt;strong&gt;对象在内部对它们的行为和状态进行管理，并通过类
      
    
    </summary>
    
    
      <category term="APP架构" scheme="https://hellohezhili.com/categories/APP%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="APP架构" scheme="https://hellohezhili.com/tags/APP%E6%9E%B6%E6%9E%84/"/>
    
      <category term="App Architecture" scheme="https://hellohezhili.com/tags/App-Architecture/"/>
    
      <category term="MVC" scheme="https://hellohezhili.com/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>APP架构（二）-- 概览</title>
    <link href="https://hellohezhili.com/2018/12/16/APP%E6%9E%B6%E6%9E%842/"/>
    <id>https://hellohezhili.com/2018/12/16/APP%E6%9E%B6%E6%9E%842/</id>
    <published>2018-12-15T16:00:00.000Z</published>
    <updated>2019-12-18T08:31:46.285Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Reference:</strong><br><em>App Architecture</em></p></blockquote><p>iOS开发官方钦定的设计模式是MVC，而MVC及其两种变形：MVVM+C和MVC+VS，是学习iOS APP架构最需要掌握的三种设计模式，这三种设计模式都是基于场景进行的架构，它们其实都是观察者模式、策略模式和组合模式三种设计子模式的集合。</p><blockquote><p><strong>MVCS</strong>：在有的地方会提到一种称为MVCS的架构，它在Model层与Controller层之间加入了一个Service层，在iOS中一般又特指负责Model数据同步、缓存、持久化等服务的Store层，它所分离的逻辑在MVC中可以属于Model层，也可以属于Controller层。但在<em>App Architecture</em>一书中并没有将MVCS列为一种单独的架构，同时MVCS中的S层除了可能减轻了Controller的职责也未见其它裨益，而减轻Controller的职责通过封装服务类也能办到，事实上<em>App Architecture</em>一书中在阐述MVC架构的Demo中就用一个全局的服务Store负责了所谓MVCS架构中S层的工作，可见MVCS中为每个场景都分离一个S层的做法也确实没那么必要，其本质上和MVC架构也没多少区别。</p></blockquote><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC源于Smalltalk中所发展出的分离展示部分的理念，也就是view层和model层应该被完全隔离开，这带来了一个强烈的需求，那就是要引入一个支持对象来辅助两者之间的通讯，这个支持对象在MVC中就是Controller。MVC中Controller对象负责处理model或者view层范畴之外的所有任务。<br>Controller层接收所有的view action，处理所有的交互逻辑；发送所有的model action，接收所有的model通知，对所有用来展示的数据进行准备，最后再将它们应用到View的变更上去。构建和导航任务也由Controller负责。</p><p><img src="APP架构2/15625977439460.jpg" alt></p><h3 id="1-构建"><a href="#1-构建" class="headerlink" title="1.构建"></a>1.构建</h3><p><strong>Model和View</strong>：MVC中View和Model的构建都由Controller负责，App对象负责创建最顶层的view controller，这个view controller将加载view，并且要么显式地创建和持有model层，要么通过一个延迟创建的model单例来获取model。</p><h3 id="2-变更View"><a href="#2-变更View" class="headerlink" title="2.变更View"></a>2.变更View</h3><p>MVC中，Controller需要观察model，在收到model变更的通知时去变更View。当一个更改model的View action发生时，为了保证单向数据流原则，Controller应避免去直接操作View层级，标准的做法是：View action转变为model变更，然后model发送通知，Controller订阅model通知，并且在当通知到达时再更改View层级。</p><h3 id="3-更改Model"><a href="#3-更改Model" class="headerlink" title="3.更改Model"></a>3.更改Model</h3><p>MVC中，Controller主要通过target/action机制和delegate来接收view事件。Controller知道自己所连接的view，而view在编译期间并不知道Controller接口的信息。当一个View事件到达时，Controller有能力改变自身的内部状态，更改model，或者直接改变View层级。</p><h3 id="4-View-State"><a href="#4-View-State" class="headerlink" title="4.View State"></a>4.View State</h3><p>MVC中View State可以按需要被储存在View或者Controller的属性中，MVC中那些只影响View或Controller状态的action通常也不需要通过model进行传递，而页面层级或导航状态也由Controller进行维护。</p><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h3><p>MVC中View Controller与app的其他部件紧密相连，这导致层级间缺乏清晰的边界，单元测试和接口测试都十分困难，集成测试是MVC最可行的测试手段。</p><h2 id="MVVM-C"><a href="#MVVM-C" class="headerlink" title="MVVM+C"></a>MVVM+C</h2><p>MVVM+C就是MVVM加Coordinator(协调器)。MVVM在每个场景中使用View-model来描述场景中的表现逻辑和交互逻辑，使用Coordinator来管理View controller层级。<br><strong>View-model</strong>在编译期间不包含对view或者controller的引用，它暴露出一系列属性来描述每个view在显示时应有的值。将这些值设置到View上的工作，通常由预先建立的绑定来完成(响应式编程)，绑定会保证当这些显示值发生变化时，把它设定到对应的View上去。<br><strong>Coordinator(协调器)</strong>是在场景间切换时负责提供逻辑的对象。协调器持有对model层的引用，并且了解View controller树的结构。MVVM-C中的View controller通过delegate的机制将Viewcontroller的信息告诉协调器，协调器据此显示新的Viewcontroller并设置它们的 model数据。<br>MVVM+C中view controller不再拥有内部的View state，这些状态也被移动到了View-model中，<strong>view controller 仅仅只是View层级的一部分</strong>。</p><p><img src="APP架构2/15625994263472.jpg" alt></p><h3 id="1-构建-1"><a href="#1-构建-1" class="headerlink" title="1.构建"></a>1.构建</h3><p><strong>Model</strong>：在MVVM中model的创建和MVC中相同，通常由一个顶层controller负责。不过model对象属于view-model，而不再属于view controller。<br><strong>View</strong>：view层级的创建也和MVC中一样，通过storyboard或者代码来完成。和MVC不同的是，view controller不再直接为每个view获取和准备数据，而是由view-model负责。<br><strong>View-Model</strong>：View controller在创建的时候会一并创建view-model，并且将每个view绑定到view-model所暴露出的相应属性上去。</p><h3 id="2-变更View-1"><a href="#2-变更View-1" class="headerlink" title="2.变更View"></a>2.变更View</h3><p>在MVVM中，和MVC不同，view controller不监听model。View-model将负责观察model，并将model的通知转变为Viewcontroller可以理解的形式。View controller订阅view-model的变更(响应式编程)，当一个view-model事件来到时，再由Viewcontroller去更改View层级。</p><h3 id="3-更改Model-1"><a href="#3-更改Model-1" class="headerlink" title="3.更改Model"></a>3.更改Model</h3><p>在MVVM中，view controller接收View事件的方式和MVC中一样(target/Action和delegate)。不过，当一个View事件到达时，view controller不会去改变自身的内部状态、view state、或者是model，而是调用view-model上的方法，再由view-model改变内部状态或者model。</p><h3 id="4-View-State-1"><a href="#4-View-State-1" class="headerlink" title="4.View State"></a>4.View State</h3><p>在MVVM中，View state要么存在于View自身之中，要么存在于view-model里。和MVC不同，view controller中不存在任何View state。View-model中的View state的变更，会被controller观察到，不过controller无法区分model的通知和View state变更的通知。在MVVM+C中，Viewcontroller层级将由协调器进行管理。</p><h3 id="5-测试-1"><a href="#5-测试-1" class="headerlink" title="5.测试"></a>5.测试</h3><p>在MVVM中，因为view-model的引入，View层与controller层是解耦合的，所以可以使用接口测试来测试view-model，而不需要像MVC里那样使用集成测试，接口测试要比集成测试简单得多。</p><h2 id="MVC-VS"><a href="#MVC-VS" class="headerlink" title="MVC+VS"></a>MVC+VS</h2><p>MVC+VS是为标准的MVC带来单向数据流方式的一种尝试，通过MVC+VS能加深编程人员对view state和单向数据流的理解。在MVC+VS中，我们明确地在一个新的model对象中，对所有的view state进行定义和表达，我们把这个对象叫做view state model。我们不从 view 中去读取view state，而是从view state model中去获取它们。MVC+VS也具有独到的优点，例如：任意的状态恢复，完整的用户界面日志，以及极为强大的调试能力(通过设置不同的view state)。</p><p><img src="APP架构2/15626012236605.jpg" alt></p><h3 id="1-构建-2"><a href="#1-构建-2" class="headerlink" title="1.构建"></a>1.构建</h3><p>在MVC+VC和MVC一样，model和view的构建工作依然由view controller负责，但MVC+VC中view controller还需要使用和订阅view state。</p><h3 id="2-变更View-2"><a href="#2-变更View-2" class="headerlink" title="2.变更View"></a>2.变更View</h3><p>在MVC+VS中Controller同时对文档model和view state model进行观察，并且只在变更发生的时候更新view层级(单向数据流原则)。</p><h3 id="3-更改Model-2"><a href="#3-更改Model-2" class="headerlink" title="3.更改Model"></a>3.更改Model</h3><p>当view action发生时，view controller去变更文档model(这和MVC相同)或者变更model state。MVC+VS中不会去直接改变view层级，所有的view变更都要通过文档model和view state model的通知来进行。</p><h3 id="4-View-State-2"><a href="#4-View-State-2" class="headerlink" title="4.View State"></a>4.View State</h3><p>View State被明确地从view controller中提取出来,由view state model维护，处理的方法和model一样：controller观察view state model，并且对应地更改view层级。</p><h3 id="5-测试-2"><a href="#5-测试-2" class="headerlink" title="5.测试"></a>5.测试</h3><p>在MVC+VS中，使用和MVC里类似的集成测试，但是测试本身会非常不同：所有的测试都从一个空的根view controller开始，然后通过设定文档model和view state model，这个根view controller可以构建出整个view层级和view controller层级。一旦view层级被构建，我们可以编写两种测试。第一种测试负责检查view层级是不是按照我们的期望被建立起来，第二种测试检查view action有没有正确地改变view state。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;&lt;br&gt;&lt;em&gt;App Architecture&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;iOS开发官方钦定的设计模式是MVC，而MVC及其两种变形：MVVM+C和MVC+VS，是学
      
    
    </summary>
    
    
      <category term="APP架构" scheme="https://hellohezhili.com/categories/APP%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="APP架构" scheme="https://hellohezhili.com/tags/APP%E6%9E%B6%E6%9E%84/"/>
    
      <category term="App Architecture" scheme="https://hellohezhili.com/tags/App-Architecture/"/>
    
      <category term="MVC" scheme="https://hellohezhili.com/tags/MVC/"/>
    
      <category term="MVVM" scheme="https://hellohezhili.com/tags/MVVM/"/>
    
      <category term="MVC+VS" scheme="https://hellohezhili.com/tags/MVC-VS/"/>
    
      <category term="MVCS" scheme="https://hellohezhili.com/tags/MVCS/"/>
    
  </entry>
  
  <entry>
    <title>APP架构（一）-- 概论</title>
    <link href="https://hellohezhili.com/2018/12/08/APP%E6%9E%B6%E6%9E%841/"/>
    <id>https://hellohezhili.com/2018/12/08/APP%E6%9E%B6%E6%9E%841/</id>
    <published>2018-12-07T16:00:00.000Z</published>
    <updated>2019-12-18T07:46:49.512Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Reference:</strong><br><em>App Architecture</em></p></blockquote><h2 id="1-软件架构和APP设计模式"><a href="#1-软件架构和APP设计模式" class="headerlink" title="1. 软件架构和APP设计模式"></a>1. 软件架构和APP设计模式</h2><p><strong>软件架构</strong>是软件设计中的分支，它关注两个方面：</p><ol><li>如何将软件分解成不同的接口和概念层次部件；</li><li>这些部件自身和部件之间的不同操作中所使用的控制流和数据流路径。</li></ol><p>一个好的APP架构依赖于一套有力的设计规则来定义部件的划分以及部件之间的相互协作方式，在架构中一套被重复使用的设计规则称为<strong>设计模式</strong>。</p><p><strong>app的设计模式基本就是一套分层规则</strong>，app中不同的部件会被归纳到某个类型中去，将这些不同的种类叫做<strong>层次</strong>：一个层次指的是，遵循一些基本规则并负责特定功能的接口和其他代码的集合。</p><h2 id="2-Model和View"><a href="#2-Model和View" class="headerlink" title="2. Model和View"></a>2. Model和View</h2><p>Model和View是APP架构中最常见也是最基础的两个分层。</p><ul><li><strong>Model</strong>：Model层是APP的内容，它不依赖于任何APP框架，程序员对Model层有完全的控制。它通常包括model对象和协调对象。</li><li><strong>View</strong>：View层几乎是完全依赖于APP框架的部分，它使Model层可见，并允许用户进行交互，从而将Model层转变为一个APP。</li></ul><p>在APP中，View对象通常会构成一个单一的view层级，view controller也通常会形成 view controller层级。model对象却不需要有明确的层级关系，在程序中它们可以是互不关联的独立 model。</p><p>model层的最重要的意义在于：<strong>它为我们的程序提供一个表述事实的单一来源，让程序的行为有清晰的规则可以依据，这会让编程逻辑清晰、行为正确</strong>。如果 model 层能做到和应用框架分离，我们就可以完全在 app 的范围之外使用它。</p><h2 id="3-反馈回路"><a href="#3-反馈回路" class="headerlink" title="3. 反馈回路"></a>3. 反馈回路</h2><p><strong>用户界面是一个同时负责展示和输入功能的反馈设备，APP的逻辑就是一个反馈回路</strong>。<br>用户发起的事件会导致view的响应，我们把由此引起的代码路径称为view action，当一view action被送到model层时，它会被转变为model action，将view action转变为model action的操作,以及路径上的其他逻辑被叫做<strong>交互逻辑</strong>。<br>一个或者多个model对象上状态的改变叫做model变更。Model的变更通常会触发一个model通知，当view依赖于model数据时，通知会触发一个view变更，将model通知和数据转变为view 更改的操作，以及路径上的其他逻辑被叫做<strong>表现逻辑</strong>。<br><img src="APP架构1/15712192375156.jpg" alt></p><h2 id="4-单向数据流"><a href="#4-单向数据流" class="headerlink" title="4. 单向数据流"></a>4. 单向数据流</h2><p>有些状态可能是在文档model之外进行维护的，例如导航状态。在app中非文档model的状态被叫做<strong>view state</strong>。在Cocoa里，大部分view对象都管理着它们自己的view state，controller对象则管理剩余的view state。<br>当所有的状态都在model层中被维护，而且所有的变更都通过完整的反馈回路路径进行传递时，我们就将它称为<strong>单向数据流</strong>。即：任意的view对象或者中间层对象只能够通过 model发出的通知来进行创建和更新(换句话说view或者中间层不能通过捷径来更新自身或者其他的view)时，这个模式通常就是单向的。在遵循单向数据流的模式中，就实现了model与应用框架的解耦。</p><h2 id="5-APP的任务"><a href="#5-APP的任务" class="headerlink" title="5. APP的任务"></a>5. APP的任务</h2><p>一个程序的正常工作方式为：view必须依赖于model数据来生成和存在，我们配置view，让它可以对model进行更改，并且能在model得到更新时也得到更新。所以我们需要决定APP中如何执行下列任务：</p><ol><li><strong>构建</strong>：谁构建model和view，以及将两者连接起来？</li><li><strong>变更view</strong>：如何将model数据的变化应用到view上去？</li><li><strong>更新model</strong>：如何处理view action？</li><li><strong>处理view state</strong>：如何处理导航及其他model state以外的状态？</li><li><strong>测试</strong>：为达到一定程度的测试覆盖，采取怎样的测试策略？</li></ol><p>我们研究APP设计模式，就是研究一个设计模式如何处理以上五个APP任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;&lt;br&gt;&lt;em&gt;App Architecture&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-软件架构和APP设计模式&quot;&gt;&lt;a href=&quot;#1-软件架构和APP设计模式&quot;
      
    
    </summary>
    
    
      <category term="APP架构" scheme="https://hellohezhili.com/categories/APP%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="APP架构" scheme="https://hellohezhili.com/tags/APP%E6%9E%B6%E6%9E%84/"/>
    
      <category term="App Architecture" scheme="https://hellohezhili.com/tags/App-Architecture/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发中好用的三方轮子</title>
    <link href="https://hellohezhili.com/2018/09/06/iOS%E4%B8%89%E6%96%B9%E8%BD%AE%E5%AD%90%E5%88%86%E7%B1%BB-OC/"/>
    <id>https://hellohezhili.com/2018/09/06/iOS%E4%B8%89%E6%96%B9%E8%BD%AE%E5%AD%90%E5%88%86%E7%B1%BB-OC/</id>
    <published>2018-09-06T13:45:55.000Z</published>
    <updated>2020-04-01T13:17:39.802Z</updated>
    
    <content type="html"><![CDATA[<font color="red"><br><em> <strong>收录的库以Objective C为主，含少量Swift库；</strong></em> <strong>以⚠️标记表示作者已多年(3年及以上)未更新；</strong><br>* <strong>以🚫标记表示作者已声明不再维护升级。</strong><br><br></font><h2 id="1-用户界面层-User-Interface"><a href="#1-用户界面层-User-Interface" class="headerlink" title="1.用户界面层(User Interface)"></a>1.用户界面层(User Interface)</h2><h3 id="视图控件"><a href="#视图控件" class="headerlink" title="视图控件"></a>视图控件</h3><p>对于更新不够频繁或自定义接口不够丰富的视图控件，最好直接使用其源码，而不是通过Cocoapods导入</p><ul><li><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="noopener">MJRefresh</a>：下拉刷新，上拉加载</li><li><a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="noopener">MBProgressHUD</a>：好用易扩展的活动指示器</li><li><a href="https://github.com/SVProgressHUD/SVProgressHUD" target="_blank" rel="noopener">SVProgressHUD</a>：轻量级的活动指示器</li><li><a href="https://github.com/terryworona/TWMessageBarManager" target="_blank" rel="noopener">TWMessageBarManager</a>：轻量的通知和警告提示库⚠️</li><li><a href="https://github.com/KrauseFx/TSMessages" target="_blank" rel="noopener">TSMessages</a>：轻量的通知和警告提示库</li><li><a href="https://github.com/calimarkus/JDStatusBarNotification" target="_blank" rel="noopener">JDStatusBarNotification</a>：顶部状态栏提醒</li><li><a href="https://github.com/JJSaccolo/UIActivityIndicator-for-SDWebImage" target="_blank" rel="noopener">UIActivityIndicator-for-SDWebImage</a>：为网络图片加载添加活动指示</li><li><a href="https://github.com/ko1o/PYSearch" target="_blank" rel="noopener">PYSearch</a>：一种使用样式较广的搜索页面</li><li><a href="https://github.com/ibireme/YYText" target="_blank" rel="noopener">YYText</a>：富文本</li><li><a href="https://github.com/Cocoanetics/DTCoreText" target="_blank" rel="noopener">DTCoreText</a>：富文本，可解析Html和CSS</li><li><a href="https://github.com/TTTAttributedLabel/TTTAttributedLabel" target="_blank" rel="noopener">TTTAttributedLabel</a>：富文本label</li><li><a href="https://github.com/xiangwangfeng/M80AttributedLabel" target="_blank" rel="noopener">M80AttributedLabel</a>：富文本label</li><li><a href="https://github.com/gsdios/SDCycleScrollView" target="_blank" rel="noopener">SDCycleScrollView</a>：轮播图</li><li><a href="https://github.com/WenchaoD/FSCalendar" target="_blank" rel="noopener">FSCalendar</a>：日历插件</li><li><a href="https://github.com/xiaozhuxiong121/PGDatePicker" target="_blank" rel="noopener">PGDatePicker</a>：时间/日期选择器</li><li><a href="https://github.com/dzenbot/DZNEmptyDataSet" target="_blank" rel="noopener">DZNEmptyDataSet</a>：无数据时的展示视图</li><li><a href="https://github.com/kingsic/SGPagingView" target="_blank" rel="noopener">SGPagingView</a>：标签指示器</li><li><a href="https://github.com/nicklockwood/iCarousel" target="_blank" rel="noopener">iCarousel</a>：卡片的旋转切换</li><li><a href="https://github.com/Abnerzj/ZJPickerView" target="_blank" rel="noopener">ZJPickerView</a>：各列会联动的选择器</li><li><a href="https://github.com/littleMeaning/LMReport" target="_blank" rel="noopener">LMReport</a>：常见报表表格样式</li><li><a href="https://github.com/jkpang/PPBadgeView" target="_blank" rel="noopener">PPBadgeView</a>：为各种视图添加badge</li><li><a href="https://github.com/weng1250/WZLBadge" target="_blank" rel="noopener">WZLBadge</a>:为视图添加badge</li><li><a href="https://github.com/wangmchn/WMPageController" target="_blank" rel="noopener">WMPageController</a>：分页视图控制器</li><li><a href="https://github.com/Grouper/FlatUIKit" target="_blank" rel="noopener">FlatUIKit</a>：扁平化风格的UIKit⚠️</li><li><a href="https://github.com/jessesquires/JSQMessagesViewController" target="_blank" rel="noopener">JSQMessagesViewController</a>：聊天消息类框架🚫</li><li><a href="https://github.com/jverdi/JVFloatLabeledTextField" target="_blank" rel="noopener">JVFloatLabeledTextField</a>：带浮动标签的文本输入框</li><li><a href="https://github.com/CEWendel/SWTableViewCell" target="_blank" rel="noopener">SWTableViewCell</a>：支持左滑和右滑的tableViewCell⚠️</li><li><a href="https://github.com/MortimerGoro/MGSwipeTableCell" target="_blank" rel="noopener">MGSwipeTableCell</a>：支持左滑和右滑的tableViewCell</li><li><a href="https://github.com/devinross/tapkulibrary" target="_blank" rel="noopener">tapkulibrary</a>：自定义控件库，包括HUD、进度条、日历、CoverFlow等</li><li><a href="https://github.com/mwaterfall/MWPhotoBrowser" target="_blank" rel="noopener">MWPhotoBrowser</a>：简单的照片浏览控件⚠️</li><li><a href="https://github.com/zhouxing5311/ZZCircleProgress" target="_blank" rel="noopener">ZZCircleProgress</a>：可定制的环形进度条</li><li><a href="https://github.com/DrummerB/BFNavigationBarDrawer" target="_blank" rel="noopener">BFNavigationBarDrawer</a>：NavigationBar下的tool菜单</li><li><a href="https://github.com/dsxNiubility/SXFiveScoreShow" target="_blank" rel="noopener">SXFiveScoreShow</a>：五项素质评分所组成的五角星</li><li><a href="https://github.com/ZhipingYang/UUChatTableView" target="_blank" rel="noopener">UUChatTableView</a>：IM聊天界面的封装</li><li><a href="https://github.com/wwdc14/HyPopMenuView" target="_blank" rel="noopener">HyPopMenuView</a>：类似微博效果的弹出菜单</li><li><a href="https://github.com/xiekw2010/DXPopover" target="_blank" rel="noopener">DXPopover</a>：带小箭头的弹出视图</li><li><a href="https://github.com/dopcn/DOPDropDownMenu" target="_blank" rel="noopener">DOPDropDownMenu</a>：下拉菜单</li><li><a href="https://github.com/skywinder/ActionSheetPicker-3.0" target="_blank" rel="noopener">ActionSheetPicker-3.0</a>：底部弹窗选择器</li><li><a href="https://github.com/ChokShen/MultilevelMenu" target="_blank" rel="noopener">MultilevelMenu</a>：多级选择器，Swift实现</li></ul><h3 id="层级管理"><a href="#层级管理" class="headerlink" title="层级管理"></a>层级管理</h3><ul><li><a href="https://github.com/ChavezChen/CWLateralSlide" target="_blank" rel="noopener">CWLateralSlide</a>：侧边抽屉效果的视图容器</li><li><a href="https://github.com/ViewDeck/ViewDeck" target="_blank" rel="noopener">ViewDeck</a>：侧边抽屉效果的视图容器</li><li><a href="https://github.com/ECSlidingViewController/ECSlidingViewController" target="_blank" rel="noopener">ECSlidingViewController</a>：双层子视图容器实现侧滑效果</li><li><a href="https://github.com/mutualmobile/MMDrawerController" target="_blank" rel="noopener">MMDrawerController</a>：轻量的侧边抽屉效果的视图容器⚠️</li><li><a href="https://github.com/robbdimitrov/RDVTabBarController" target="_blank" rel="noopener">RDVTabBarController</a>：三方封装的tabBarController</li></ul><h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><ul><li><a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a>：Autolayout代码布局库</li><li><a href="https://github.com/PureLayout/PureLayout" target="_blank" rel="noopener">PureLayout</a>：Autolayout代码布局库</li><li><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="noopener">UITableView+FDTemplateLayoutCell</a>：tableVeiwCell高度的自动布局</li></ul><h3 id="动画特效"><a href="#动画特效" class="headerlink" title="动画特效"></a>动画特效</h3><ul><li><a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="noopener">GPUImage</a>：图片添加滤镜⚠️</li><li><a href="https://github.com/facebook/Shimmer" target="_blank" rel="noopener">Shimmer</a>：为视图添加流光效果</li><li><a href="https://github.com/nicklockwood/FXBlurView" target="_blank" rel="noopener">FXBlurView</a>：添加毛玻璃效果🚫</li><li><a href="https://github.com/Nyx0uf/NYXImagesKit" target="_blank" rel="noopener">NYXImagesKit</a>：常规的图片处理</li><li><a href="https://github.com/levey/AwesomeMenu" target="_blank" rel="noopener">AwesomeMenu</a>：弹射动画展开的菜单</li><li><a href="https://github.com/CanvasPod/Canvas" target="_blank" rel="noopener">Canvas</a>：无需编码就能添加动画效果的库⚠️</li><li><a href="https://github.com/IFTTT/JazzHands" target="_blank" rel="noopener">JazzHands</a>：在scrollview中绘制关键帧动画⚠️ </li><li><a href="https://github.com/facebook/pop" target="_blank" rel="noopener">pop</a>：pop动画引擎</li><li><a href="https://github.com/schneiderandre/popping" target="_blank" rel="noopener">popping</a>：基于pop引擎的动画库</li><li><a href="https://github.com/kevinzhow/pop-handapp" target="_blank" rel="noopener">pop-handapp</a>：基于pop引擎的动画实例</li><li><a href="https://github.com/ColinEberhardt/VCTransitionsLibrary" target="_blank" rel="noopener">VCTransitionsLibrary</a>：转场动画库⚠️</li></ul><h3 id="UI层优化"><a href="#UI层优化" class="headerlink" title="UI层优化"></a>UI层优化</h3><ul><li><a href="https://github.com/forkingdog/FDFullscreenPopGesture" target="_blank" rel="noopener">FDFullscreenPopGesture</a>：简化返回手势的管理 </li><li><a href="https://github.com/MoZhouqi/KMNavigationBarTransition" target="_blank" rel="noopener">KMNavigationBarTransition</a>：优化转场时的导航栏样式</li><li><a href="https://github.com/liuzhiyi1992/ZYCornerRadius" target="_blank" rel="noopener">ZYCornerRadius</a>：避免离屏渲染的圆角设置</li><li><a href="https://github.com/path/FastImageCache" target="_blank" rel="noopener">FastImageCache</a>：本地图片的快速加载与渲染</li><li><a href="https://github.com/texturegroup/texture" target="_blank" rel="noopener">Texture</a>：通过异步绘制来提升性能的UI框架</li><li><a href="https://github.com/tombenner/nui" target="_blank" rel="noopener">nui</a>：用类CSS的语法来简化UI样式的设置⚠️</li></ul><h2 id="2-业务逻辑层-Bussiness-Logic"><a href="#2-业务逻辑层-Bussiness-Logic" class="headerlink" title="2.业务逻辑层(Bussiness Logic)"></a>2.业务逻辑层(Bussiness Logic)</h2><h3 id="APP任务"><a href="#APP任务" class="headerlink" title="APP任务"></a>APP任务</h3><ul><li><a href="https://github.com/hackiftekhar/IQKeyboardManager" target="_blank" rel="noopener">IQKeyboardManager</a>：键盘事务管理</li><li><a href="https://github.com/AYJk/AYCheckVersion" target="_blank" rel="noopener">AYCheckVersion</a>：更新检查</li><li><a href="https://github.com/nicklockwood/iVersion" target="_blank" rel="noopener">iVersion</a>：更新检查🚫</li><li><a href="https://github.com/arashpayan/appirater" target="_blank" rel="noopener">Appirater</a>：去AppStore评分</li><li><a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="noopener">CocoaLumberjack</a>：App的日志管理库</li><li><a href="https://github.com/fpillet/NSLogger" target="_blank" rel="noopener">NSLogger</a>：带mac客户端的日志分析工具</li></ul><h3 id="功能组件"><a href="#功能组件" class="headerlink" title="功能组件"></a>功能组件</h3><ul><li><a href="https://github.com/banchichen/TZImagePickerController" target="_blank" rel="noopener">TZImagePickerController</a>：图片选择器</li><li><a href="https://github.com/renzifeng/ZFPlayer" target="_blank" rel="noopener">ZFPlayer</a>：视频播放器及控制器</li><li><a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="noopener">PNChart</a>：图表绘制库(OC)</li><li><a href="https://github.com/danielgindi/Charts" target="_blank" rel="noopener">Charts</a>：图标绘制库(Swift)</li><li><a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">WebViewJavascriptBridge</a>：OC和JS的交互库</li><li><a href="https://github.com/ayushgoel/AGEmojiKeyboard" target="_blank" rel="noopener">AGEmojiKeyboard</a>：emoji表情输入面板</li><li><a href="https://github.com/renzifeng/ZFSetting" target="_blank" rel="noopener">ZFSetting</a>：快捷构建设置界面</li><li><a href="https://github.com/TimOliver/TOCropViewController" target="_blank" rel="noopener">TOCropViewController</a>：图片裁剪</li><li><a href="https://github.com/syedhali/EZAudio" target="_blank" rel="noopener">EZAudio</a>：音频波形图绘制⚠️</li></ul><h3 id="便捷工具"><a href="#便捷工具" class="headerlink" title="便捷工具"></a>便捷工具</h3><ul><li><a href="https://github.com/ReactiveCocoa/ReactiveObjC" target="_blank" rel="noopener">ReactiveObjC</a>：函数响应式编程框架</li><li><a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">KVOController</a>：方便安全的KVO工具</li><li><a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener">PromiseKit</a>：Promise设计模式处理异步任务的库</li><li><a href="https://github.com/shaojiankui/JKCategories" target="_blank" rel="noopener">JKCategories</a>：系统库的类扩展</li><li><a href="https://github.com/bennyguitar/Colours" target="_blank" rel="noopener">Colours</a>：颜色库扩展</li><li><a href="https://github.com/mattt/FormatterKit" target="_blank" rel="noopener">FormatterKit</a>：为很多数据类型提供了格式化的转换</li><li><a href="https://github.com/jverkoey/nimbus" target="_blank" rel="noopener">nimbus</a>：开源的iOS开发框架</li><li><a href="https://github.com/BlocksKit/BlocksKit" target="_blank" rel="noopener">BlocksKit</a>：为一些常用的系统接口提供block版本</li><li><a href="https://github.com/BoltsFramework/Bolts-ObjC" target="_blank" rel="noopener">Bolts-ObjC</a>：GCD、NSOperation之外的多任务管理库</li><li><a href="https://github.com/wezm/RegexKitLite" target="_blank" rel="noopener">RegexKitLite</a>：通过正则表达式处理字符串⚠️</li><li><a href="https://github.com/bendytree/Objective-C-RegEx-Categories" target="_blank" rel="noopener">Objective-C-RegEx-Categories</a>：提供便捷的正则表达式使用接口⚠️</li></ul><h2 id="3-数据访问层-Data-Access"><a href="#3-数据访问层-Data-Access" class="headerlink" title="3.数据访问层(Data Access)"></a>3.数据访问层(Data Access)</h2><h3 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h3><ul><li><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a>：网络请求库</li><li><a href="https://github.com/kangzubin/XMNetworking" target="_blank" rel="noopener">XMNetworking</a>：基于AF的封装，使用方便，适合中小型项目</li><li><a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNetwork</a>：基于AF的封装，功能完备，适合复杂网络请求项目</li><li><a href="https://github.com/MugunthKumar/MKNetworkKit" target="_blank" rel="noopener">MKNetworkKit</a>：轻量的网络请求库</li><li><a href="https://github.com/tonymillion/Reachability" target="_blank" rel="noopener">Reachability</a>：判断网络可达性</li><li><a href="https://github.com/RestKit/RestKit" target="_blank" rel="noopener">RestKit</a>：专注于RESTful API的网络请求、JSON解析、CoreData存储的框架</li><li><a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>：根据网络连接获取图片</li><li><a href="https://github.com/facebook/SocketRocket" target="_blank" rel="noopener">SocketRocket</a>：facebook家的轻量级socket连接库⚠️</li><li><a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a>：异步socket通讯</li><li><a href="https://github.com/facebook/SocketRocket" target="_blank" rel="noopener">SocketRocket</a>：webSocket客户端</li><li><a href="https://github.com/robbiehanson/XMPPFramework" target="_blank" rel="noopener">XMPPFramework</a>：XMPP通信框架</li></ul><h3 id="转换处理"><a href="#转换处理" class="headerlink" title="转换处理"></a>转换处理</h3><ul><li><a href="https://github.com/nicklockwood/GZIP" target="_blank" rel="noopener">GZIP</a>：数据压缩与解压</li><li><a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="noopener">MJExtension</a>：JSON字典和模型相互转换</li><li><a href="https://github.com/Mantle/Mantle" target="_blank" rel="noopener">Mantle</a>：JSON字典和模型的转换</li><li><a href="https://github.com/stig/json-framework" target="_blank" rel="noopener">json framework</a>：JSON数据解析</li><li><a href="https://github.com/jsonmodel/jsonmodel" target="_blank" rel="noopener">JSONModel</a>：JSON字典和模型的转换</li><li><a href="https://github.com/topfunky/hpple" target="_blank" rel="noopener">hpple</a>：XML/HTML解析</li></ul><h3 id="本地持久化"><a href="#本地持久化" class="headerlink" title="本地持久化"></a>本地持久化</h3><ul><li><a href="https://github.com/ibireme/YYCache" target="_blank" rel="noopener">YYCache</a>：NSCoding归档缓存</li><li><a href="https://github.com/realm/realm-cocoa" target="_blank" rel="noopener">Realm</a>：移动端本地数据库</li><li><a href="https://github.com/magicalpanda/MagicalRecord" target="_blank" rel="noopener">MagicalRecord</a>：对CoreData的封装</li><li><a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a>：对SQLite数据库的封装</li><li><a href="https://github.com/baptistefetet/KeychainItemWrapper" target="_blank" rel="noopener">KeychainItemWrapper</a>：keychain钥匙串管理⚠️</li><li><a href="https://github.com/soffes/SAMKeychain" target="_blank" rel="noopener">SAMKeychain</a>：keychain钥匙串管理</li><li><a href="https://github.com/gangverk/GVUserDefaults" target="_blank" rel="noopener">GVUserDefaults</a>：对NSUserDefaults的方便存取</li></ul><h2 id="4-测试调试-Test-amp-Debug"><a href="#4-测试调试-Test-amp-Debug" class="headerlink" title="4.测试调试(Test &amp; Debug)"></a>4.测试调试(Test &amp; Debug)</h2><p>调试类三方库在Cocoapods导入时需设置其编译环境仅包含<strong>Debug</strong>，即需要在三方库的引入后面加上<code>:configurations =&gt; [&#39;Debug&#39;]</code>，测试类三方库要注意仅加到测试target下</p><ul><li><a href="https://github.com/Flipboard/FLEX" target="_blank" rel="noopener">FLEX</a>：强大的调试工具</li><li><a href="https://github.com/Tencent/MLeaksFinder" target="_blank" rel="noopener">MLeaksFinder</a>：VC和VC上的View的内存泄漏检查工具</li><li><a href="https://github.com/facebook/FBRetainCycleDetector" target="_blank" rel="noopener">FBRetainCycleDetector</a>：对象的循环引用检查工具</li><li><a href="https://github.com/JxbSir/JxbDebugTool" target="_blank" rel="noopener">JxbDebugTool</a>：网络请求调试工具⚠️</li><li><a href="https://github.com/coderyi/NetworkEye" target="_blank" rel="noopener">NetworkEye</a>：Http网络请求调试工具</li><li><a href="https://github.com/square/PonyDebugger" target="_blank" rel="noopener">PonyDebugger</a>：通过Chrome调试网络流量和数据存储</li><li><a href="https://github.com/kif-framework/KIF" target="_blank" rel="noopener">KIF</a>：基于XCTest的UI测试框架</li><li><a href="https://github.com/kiwi-bdd/Kiwi" target="_blank" rel="noopener">Kiwi</a>：BDD行为驱动开发测试框架</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font color=&quot;red&quot;&gt;&lt;br&gt;&lt;em&gt; &lt;strong&gt;收录的库以Objective C为主，含少量Swift库；&lt;/strong&gt;
&lt;/em&gt; &lt;strong&gt;以⚠️标记表示作者已多年(3年及以上)未更新；&lt;/strong&gt;&lt;br&gt;* &lt;strong&gt;以🚫标记表
      
    
    </summary>
    
    
      <category term="库与 源码" scheme="https://hellohezhili.com/categories/%E5%BA%93%E4%B8%8E-%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="三方库合集" scheme="https://hellohezhili.com/tags/%E4%B8%89%E6%96%B9%E5%BA%93%E5%90%88%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Appledoc</title>
    <link href="https://hellohezhili.com/2018/09/06/Appledoc/"/>
    <id>https://hellohezhili.com/2018/09/06/Appledoc/</id>
    <published>2018-09-06T09:19:59.000Z</published>
    <updated>2020-04-06T13:05:35.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具简介"><a href="#工具简介" class="headerlink" title="工具简介"></a>工具简介</h2><p><a href="https://github.com/tomaz/appledoc" target="_blank" rel="noopener">Appledoc</a>是一款开源工具，使用它可以根据指定路径下代码文件中的注释，为项目生成Apple风格的API文档。</p><h2 id="工具教程"><a href="#工具教程" class="headerlink" title="工具教程"></a>工具教程</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p>appledoc可以通过Homebrew安装，终端执行命令<code>brew install appledoc</code>即可，不过这种方式不会一并安装文档模板（template），所以更推荐通过appledoc项目的源文件来安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. clone appledoc文件</span></span><br><span class="line">git <span class="built_in">clone</span> git://github.com/tomaz/appledoc.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 进入appledoc目录</span></span><br><span class="line"><span class="built_in">cd</span> ./appledoc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 运行appledoc安装脚本</span></span><br><span class="line">sudo sh install-appledoc.sh</span><br></pre></td></tr></table></figure><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><h4 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h4><p>appledoc支持导出Markdown语法书写的注释，同时也支持导出Xcode通过<code>Command + Option + /</code>为方法添加的标准注释，附Xcode标准注释的关键字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> @brief     方法简要描述</span></span><br><span class="line"><span class="comment"> @param     方法参数说明</span></span><br><span class="line"><span class="comment"> @exception 方法会抛出异常</span></span><br><span class="line"><span class="comment"> @see       参看相关的 Method/Function/枚举</span></span><br><span class="line"><span class="comment"> @discussion    方法详细说明</span></span><br><span class="line"><span class="comment"> @warning   警告</span></span><br><span class="line"><span class="comment"> @bug       BUG</span></span><br><span class="line"><span class="comment"> @return    返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="导出文档"><a href="#导出文档" class="headerlink" title="导出文档"></a>导出文档</h4><p>appledoc的命令格式为<code>appledoc [OPTIONS] &lt;paths to source dirs or files&gt;</code>，常用的appledoc命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appledoc -i *.m --keep-undocumented-objects --keep-undocumented-members -h --no-publish-docset --no-create-docset --no-install-docset -c <span class="string">"公司名称"</span> -p <span class="string">"项目名称"</span> -o <span class="string">"输出地址"</span> <span class="string">"源文件目录"</span></span><br></pre></td></tr></table></figure><p>命令的最后是需要导出文档的源文件目录，中间是命令参数，appledoc所支持的更多命令参数可通过<code>appledoc --help</code>进行查看。</p><p>命令成功执行后通常是在指定的输出地址下生成一个名为<strong>docset-installed.txt</strong>的文件（示例命令是直接在输出地址中生成html文档），里面记录了导出的文档的地址，导出的文档一般在<code>~/Library/Developer/Shared/Documentation/DocSets/</code>目录下，文档为<code>.doset</code>格式，可通过<strong>右键-显示包内容</strong>查看其内容。</p><h4 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h4><p>可以通过为项目添加Aggregate Target，再为Aggregate添加Run Script，最后再编译Aggregate的方式来方便快速的为项目生成API文档。</p><p><strong>添加Aggregate</strong>：Xcode中依次<code>File -&gt; New -&gt; Target... -&gt; Aggretgate</code>进行添加；</p><p><strong>添加Run Script</strong>：在添加的Aggregate的<strong>Build Phases</strong>中添加Run Script；</p><p><strong>Run Script示例</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">company=&quot;组织名称&quot;;  </span><br><span class="line">companyID=&quot;组织ID&quot;;</span><br><span class="line">outputPath=&quot;$&#123;PROJECT_DIR&#125;&quot;;</span><br><span class="line">filePath=&quot;$&#123;PROJECT_DIR&#125;&quot;</span><br><span class="line"></span><br><span class="line">appledoc \</span><br><span class="line">-i *.m \</span><br><span class="line">--keep-undocumented-objects \</span><br><span class="line">--keep-undocumented-members \</span><br><span class="line">-h \</span><br><span class="line">--no-publish-docset \</span><br><span class="line">--no-create-docset \</span><br><span class="line">--no-install-docset \</span><br><span class="line">--company-id &quot;$&#123;companyID&#125;&quot; \</span><br><span class="line">-c &quot;$&#123;company&#125;&quot; \</span><br><span class="line">-p &quot;$&#123;PROJECT_NAME&#125;&quot; \</span><br><span class="line">-o &quot;$&#123;outputPath&#125;&quot; \</span><br><span class="line">--exit-threshold 2 \</span><br><span class="line">&quot;$&#123;filePath&#125;&quot;</span><br></pre></td></tr></table></figure><h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.注意</h3><p>使用appledoc的注意事项：</p><ul><li>appledoc不会导出<code>//</code>注释的内容，需要导出的单行注释可以使用<code>///</code>；</li><li>Xcode9.3之后不再支持集成自定义文档，使用appledoc集成文档时会报Error，但不影响文档的导出，详见<a href="https://github.com/tomaz/appledoc/issues/628" target="_blank" rel="noopener">Issue</a>；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工具简介&quot;&gt;&lt;a href=&quot;#工具简介&quot; class=&quot;headerlink&quot; title=&quot;工具简介&quot;&gt;&lt;/a&gt;工具简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/tomaz/appledoc&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="实用工具" scheme="https://hellohezhili.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="appledoc" scheme="https://hellohezhili.com/tags/appledoc/"/>
    
  </entry>
  
  <entry>
    <title>OC的动态特性(二) -- 反射机制</title>
    <link href="https://hellohezhili.com/2018/06/30/OC%E7%9A%84%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7-%E4%BA%8C-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://hellohezhili.com/2018/06/30/OC%E7%9A%84%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7-%E4%BA%8C-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2018-06-29T16:00:00.000Z</published>
    <updated>2020-04-14T07:56:21.490Z</updated>
    
    <content type="html"><![CDATA[<p><strong>反射是指程序在运行时可以访问、检测和修改程序本身的状态或行为的一种能力</strong>，OC是基于Runtime运行时系统的动态语言，具有强大的反射能力。OC的反射机制通常是指NSFoundation中为反射功能提供的一系列API，它们是基于Runtime的封装，是<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="noopener">Runtime编程</a>的子集。</p><h3 id="1-获取对象类型"><a href="#1-获取对象类型" class="headerlink" title="1. 获取对象类型"></a>1. 获取对象类型</h3><p>NSFoundation的根类NSObject中实现了<code>-class</code>方法，默认情况下它返回的是<code>isa</code>指向的类，但它可以被子类重写（比如KVO中），造成此方法返回的类和<code>isa</code>指向的类不一致的情况；Runtime提供了<code>Class object_getClass(id obj)</code>函数来获取对象所属的类，此函数直接返回对象<code>isa</code>所指向的类；NSFoundation中还提供了类方法<code>+class</code>，该方法返回的就是当前类，而不是类的类（元类）。</p><h3 id="2-对象检测方法"><a href="#2-对象检测方法" class="headerlink" title="2. 对象检测方法"></a>2. 对象检测方法</h3><p>NSFoundation中根类NSObject实现了一系列方法，来对对象的类型、协议、方法等做检测判断：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @protocol NSObject</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)aClass;</span><br><span class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)aClass;</span><br><span class="line">- (<span class="built_in">BOOL</span>)conformsToProtocol:(Protocol *)aProtocol;</span><br><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @interface NSObject</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)instancesRespondToSelector:(SEL)aSelector;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)conformsToProtocol:(Protocol *)protocol;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)isSubclassOfClass:(Class)aClass;</span><br></pre></td></tr></table></figure><h3 id="3-消息派发"><a href="#3-消息派发" class="headerlink" title="3.消息派发"></a>3.消息派发</h3><p>NSFoundation中根类NSObject实现一系列Perform Selector，它们有的是对<code>objc_msgSend</code>的封装，有的则是基于线程的RunLoop来实现的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @protocol NSObject</span></span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector;</span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)object;</span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)object1 withObject:(<span class="keyword">id</span>)object2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @interface NSObject (NSDelayedPerforming)</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay inModes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @interface NSObject (NSThreadPerformAdditions)</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br><span class="line">- (<span class="keyword">void</span>)performSelectorInBackground:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg;</span><br></pre></td></tr></table></figure><p>Perform Selector中有返回值的API要注意<strong>返回的对象可能会内存泄露</strong>，进行<strong>延迟派发、派发给其他线程、以及当前线程异步派发时</strong>，要注意判断目标线程的RunLoop是否运行。</p><h3 id="4-反射方法"><a href="#4-反射方法" class="headerlink" title="4. 反射方法"></a>4. 反射方法</h3><p>NSFoundation中还提供了字符串和Selector、类、协议互相装换的API，以方便放射功能的使用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *<span class="built_in">NSStringFromSelector</span>(SEL aSelector);</span><br><span class="line">SEL <span class="built_in">NSSelectorFromString</span>(<span class="built_in">NSString</span> *aSelectorName);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *<span class="built_in">NSStringFromClass</span>(Class aClass);</span><br><span class="line">Class __<span class="keyword">nullable</span> <span class="built_in">NSClassFromString</span>(<span class="built_in">NSString</span> *aClassName);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *<span class="built_in">NSStringFromProtocol</span>(Protocol *proto);</span><br><span class="line">Protocol * __<span class="keyword">nullable</span> <span class="built_in">NSProtocolFromString</span>(<span class="built_in">NSString</span> *namestr);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;反射是指程序在运行时可以访问、检测和修改程序本身的状态或行为的一种能力&lt;/strong&gt;，OC是基于Runtime运行时系统的动态语言，具有强大的反射能力。OC的反射机制通常是指NSFoundation中为反射功能提供的一系列API，它们是基于Runtime
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>OC的动态特性(一) -- Runtime</title>
    <link href="https://hellohezhili.com/2018/06/23/OC%E7%9A%84%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7-%E4%B8%80-Runtime/"/>
    <id>https://hellohezhili.com/2018/06/23/OC%E7%9A%84%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7-%E4%B8%80-Runtime/</id>
    <published>2018-06-22T16:00:00.000Z</published>
    <updated>2020-04-13T10:06:45.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Reference:</strong><br><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a><br><a href="https://www.jianshu.com/p/6ebda3cd8052" target="_blank" rel="noopener">iOS Runtime详解</a></p></blockquote><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>Runtime抽象的说OC的运行时系统，实质点讲它是一个由C和汇编编写的库（后逐步用C++重写）。这个库完成了OC对C的扩展，在编译期，通过它实现了OC向C/C++的装换；同时在运行时，它是OC面向对象和动态特性的基石：它让OC可以动态的创建类和对象、并通过方法调用来完成函数的动态绑定，进行消息的传递和转发。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%B8%80-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/RuntimePreview.png" alt="RuntimePreview"></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li>类和对象都有个指向类的<code>isa</code>指针，所以类又称类对象，对象的<code>isa</code>指向所属类，类的<code>isa</code>指向元类；</li><li>所有元类的<code>isa</code>都指向根类（NSObject）的元类，包括它自己；</li><li>类别可以为类添加属性，但不能添加成员变量，可以用关联对象来代替成员变量，保存属性的值；</li><li>消息决策时先在当前类的方法缓存中查找，再去继承链上的方法列表中查找，继承连上找到后，会缓存到当前类的方法缓存中；</li><li>消息转发的系列方法中要注意调用父类的方法，以便处理当前类未处理的消息；</li></ul><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">Runtime</a>的代码是开源的，从objc4-493版本开始，Runtime的实现代码逐步用C++进行重写，本文参照的源码是最后一个没有C++的版本objc4-437.3。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="1-对象"><a href="#1-对象" class="headerlink" title="1.对象"></a>1.对象</h3><p>源码中对象的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    Class isa;</span><br><span class="line">&#125; *id;</span><br></pre></td></tr></table></figure><p>对象的定义是一个结构体，内部只有一个指向所属类的<code>isa</code>指针。</p><h3 id="2-类"><a href="#2-类" class="headerlink" title="2.类"></a>2.类</h3><p>源码中类的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class isa;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class super_class                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                            OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                      OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>            <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>   <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>                <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>    <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><h4 id="Meta-Class"><a href="#Meta-Class" class="headerlink" title="Meta Class"></a>Meta Class</h4><p>类的结构体中也有一个指向所属类的<code>isa</code>指针，还有一个指向父类的<code>super_class</code>指针，类的<code>isa</code>指向的是类的类，被称之为元类；元类的<code>super_class</code>指针指向元类的父类，元类的<code>isa</code>指针则都指向根元类（即NSObject的元类）；值得注意的是<strong>根元类的<code>super_class</code>指向的是根类（即NSObject），<code>isa</code>指针依然指向根元类（即它自己）</strong>。</p><p><strong>对象、类和元类之间的关系如图</strong>：<br><img src="APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%B8%80-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Object-Class.png" alt="Object-Class"></p><p><strong>类对象</strong>：对象和类都有<code>isa</code>指针指向所属的类，甚至在C++实现的Runtime版本中，类的结构体直接继承自对象的结构体，所以说类也是对象，称之为类对象，类对象和元类是一一对应的，都是运行时由系统创建的单例。</p><h4 id="objc-ivar-list"><a href="#objc-ivar-list" class="headerlink" title="objc_ivar_list"></a>objc_ivar_list</h4><p>类中<code>struct objc_ivar_list *ivars</code>是成员变量列表，源码中定义的成员变量其结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ivar_name                     OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> *ivar_type                     OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset                     OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                           OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中ivar_type存储的是成员变量的数据类型、内存管理、访问权限等信息编码后的结果；提供<code>Ivar *class_copyIvarList(Class cls, unsigned int *outCount)</code>函数来获取一个类的成员变量列表。</p><p>在类中使用<code>@property</code>为类同时添加了属性和成员变量，属性的本质是set和get方法，提供<code>objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</code>函数获取一个类的属性列表。</p><h4 id="objc-method-list"><a href="#objc-method-list" class="headerlink" title="objc_method_list"></a>objc_method_list</h4><p>类中<code>struct objc_method_list **methodLists</code>是对象方法列表，类方法就是类对象的方法，保存在元类的方法列表中，源码中方法的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> &#123;</span></span><br><span class="line">    SEL method_name                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> *method_types              OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                  OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中method_name即Selector，method_types是方法的签名，method_imp则是方法的实现，提供<code>Method *class_copyMethodList(Class cls, unsigned int *outCount)</code>来获取一个类的对象方法列表。</p><h4 id="objc-cache"><a href="#objc-cache" class="headerlink" title="objc_cache"></a>objc_cache</h4><p>类中<code>struct objc_cache *cache</code>是Selector的方法缓存，其中保存的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SEL name;     <span class="comment">// same layout as struct old_method</span></span><br><span class="line">    <span class="keyword">void</span> *unused;</span><br><span class="line">    IMP imp;  <span class="comment">// same layout as struct old_method</span></span><br><span class="line">&#125; cache_entry;</span><br></pre></td></tr></table></figure><p>方法缓存的设计源于一个理念：类的某个方法调用后，接下来会有很大的概率被再次调用。当向一个对象发送消息后，需要查找Selecotr对应的实现（IMP），查找顺序是先查找当前类的方法缓存，如果没有找到，则从当前类开始，沿着继承链在类的方法列表中查找，找到后会将Selector和IMP的映射缓存在当前类的方法缓存中。</p><h4 id="objc-protocol-list"><a href="#objc-protocol-list" class="headerlink" title="objc_protocol_list"></a>objc_protocol_list</h4><p>类中<code>struct objc_protocol_list *protocols</code>是协议列表，源码中协议的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface Object</span><br><span class="line">&#123;</span><br><span class="line">    Class isa;<span class="comment">/* A pointer to the instance's class structure */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interface Protocol : Object</span><br><span class="line">&#123;</span><br><span class="line">@<span class="keyword">private</span></span><br><span class="line">    <span class="keyword">char</span> *protocol_name OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocol_list</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description_list</span> *<span class="title">instance_methods</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description_list</span> *<span class="title">class_methods</span> <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协议是一个继承自Object的类，其内有该协议遵循的协议列表、对象方法列表、和类方法列表；提供<code>Protocol **class_copyProtocolList(Class cls, unsigned int *outCount)</code>函数来获取一个类的协议列表。</p><h3 id="3-类别"><a href="#3-类别" class="headerlink" title="3.类别"></a>3.类别</h3><p>源码中类别的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_category</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *category_name                         OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> *class_name                            OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> *<span class="title">instance_methods</span>   <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> *<span class="title">class_methods</span>      <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>        <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过类别可以为类添加属性，但不能添加成员变量，类别添加属性时，可以通过<code>objc_setAssociatedObject</code>添加关联对象，代替成员变量来保存属性的值。</p><p>类别中的方法、协议会在类别<code>+load</code>时添加到主类的列表中，后添加的方法会在列表前面，所以类别的方法可以覆盖主类中的同名方法，<code>+load</code>的执行顺序总结如下：</p><ul><li>父类的<code>+load</code>执行后子类的<code>+load</code>才执行；</li><li>所有类的<code>+load</code>执行后类别的<code>+load</code>才执行；</li><li>类别之间、没有继承关系的类之间，<code>+load</code>执行的顺序与编译顺序相同（即<code>buildPhases -&gt; Compile Sources</code>中的文件顺序）；</li></ul><h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>Runtime通过方法调用来实现<strong>函数的动态绑定</strong>，即所调用的函数地址不是编译期硬编码在指令中，而是需要在运行期读取。方法调用又叫消息传递，消息由selector及其参数所构成，消息传递的核心是<code>objc_msgSend</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_msgSend</span><span class="params">(id self, SEL op, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>在<code>objc_msgSend</code>函数中，第一个参数是消息的接收类/对象，第二个参数是selector，后面才是消息的参数，所以在一个方法实现的内部，有两个默认的参数self和_cmd，它们分别代表方法调用者自身和方法的selector。</p><p>消息传递，即对象进行方法调用，到执行对应实现，所执行的步骤大致如下：</p><ol><li>根据对象/类的<code>isa</code>指针找到对象/类所属的类/元类；</li><li>先在当前类/元类的方法缓存中查找selector对应的IMP，找到IMP则去执行对应的函数实现；</li><li>方法缓存中没找到，则沿着继承链在类/元类的方法列表找查找selector对应的方法；</li><li>找到对应方法后，将方法中的IMP和selector的映射添加到<strong>当前类/元类</strong>的方法缓存中，并执行IMP对应的函数实现；</li><li>如果最终沿着继承链没有找到对应的方法，则启动<strong>消息转发</strong>机制；</li></ol><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>当一个消息在类及其继承链上最终没有找到对应的方法实现，将启动消息转发机制，消息转发的流程如图：</p><p><img src="APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%B8%80-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/MessageForward.png" alt="MessageForward"><br>启动消息转发后，消息的接收者还有三次机会来对消息做出处理：</p><ol><li><strong>动态方法解析</strong>：在<code>+resolveClassMethod:</code>/<code>+resolveInstanceMethod:</code>中，如果为消息动态的添加了一个类/对象方法，则重新再发送一次消息，如果没有为消息动态的添加方法，则继续消息转发的下一步（与动态解析方法返回YES/NO没有关系）；</li><li><strong>备援接受者</strong>：在<code>-forwardingTargetForSelector:</code>中如果返回了一个非nil的备援接受者，则将消息发送给备援接受者，如果返回nil，则继续消息转发的下一步；</li><li><strong>转发消息</strong>：需要先在<code>-methodSignatureForSelector:</code>返回消息对应的方法签名，再在<code>-forwardInvocation:</code>中处理NSInvocation，如果没有返回方法签名，则会调用<code>-doesNotRecognizeSelector:</code>方法，并抛出异常；</li></ol><p>在为当前类实现以上消息转发方法时，对于没有处理的消息，都应调用父类的方法，交由父类处理。在第三步转发消息时，方法签名可以参看官方文档<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Type Encodings</a>，处理NSInvocation时，可以简单的转发给另外一个target，但这就跟返回备援接受者效果一样，一般如果消息转发需要走到这一步，则是需要编辑NSInvocation来更改消息内容，比如追加参数、更换selector等。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Runtime是OC动态特性的基石，使用它可以实现OC语言层面的拓展，Runtime的应用非常的广泛，Runtime实现的功能也非常的实用，Runtime编程可以参见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a>，这里只对一些常见的应用做一个简单的介绍</p><h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><p>Runtime提供了三个函数来管理关联对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关联对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, objc_AssociationPolicy policy)</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取关联的对象</span></span></span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"><span class="comment">//移除关联的对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span></span></span><br></pre></td></tr></table></figure><p>关联对象一个非常常用的地方是在类别中添加属性时，代替成员变量来保存属性的值。添加关联对象时，需要指明和属性修饰符类似的关联对象内存策略，常用的有以下几个：</p><ul><li>OBJC_ASSOCIATION_ASSIGN，同@property (assign)或 @property (unsafe_unretained)；</li><li>OBJC_ASSOCIATION_RETAIN_NONATOMIC，同@property (nonatomic, strong)；</li><li>OBJC_ASSOCIATION_COPY_NONATOMIC，同@property (nonatomic, copy)；</li></ul><h3 id="ISA-Swizzling"><a href="#ISA-Swizzling" class="headerlink" title="ISA Swizzling"></a>ISA Swizzling</h3><p>对象的<code>isa</code>指针指向了它所属的类，ISA Swizzling是指修改对象<code>isa</code>指向的类的技术。Runtime提供<code>Class object_setClass(id obj, Class cls)</code>函数来修改一个对象所指向的类，<strong>ISA Swizzling只会影响做了替换操作的对象，不会影响到整个类</strong>，替换示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">swizzlingObjClass</span><span class="params">(id obj, Class newCls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (class_getInstanceSize(newCls) &lt;= class_getInstanceSize([obj class])) &#123;</span><br><span class="line">        object_setClass(obj, newCls);</span><br><span class="line">        <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中使用了<code>size_t class_getInstanceSize(Class cls)</code>来比较ISA Swizzling前后类的实例的大小，这是因为将要ISA Swizzling的对象的内存是已经分配好的，如果替换后类的实例大于替换之前分配的内存，会导致<code>EXC_BAD_ACCESS</code>错误，所以ISA Swizzling时，替换后的类一般为替换前类的子类，而且子类中没有新增任何成员变量或合成属性。KVO就是通过ISA Swizzling技术来实现的。</p><p>当对某个类<code>A</code>的对象添加KVO之后，KVO机制会动态的创建一个<code>A</code>的子类（通常命名为NSKVONotifying_A），然后让被观察对象的<code>isa</code>指向这个子类，在子类中重写了<code>-class</code>方法，让<code>-class</code>依然返回原来的类，并重写了被观察<code>keyPath</code>的<code>setter</code>方法，在<code>setter</code>方法中调用了<code>-willChangeValueForKey:</code>和<code>-didChangeValueForKey:</code>，当通过<code>setter</code>方法更改被观察的值时，观察者就能收到通知。</p><h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><p>Runtime允许动态的新增、替换方法的实现，用新的实现替换原有方法的实现，就叫做Method Swizzling。一种特殊的Method Swizzling - 交换两个已有方法的实现，配合类别可以为原方法添加<code>hook</code>，完成对没有源码的原方法的修改。简单的<code>hook</code>使用<code>method_exchangeImplementations</code>即可实现，但实际上<code>hook</code>时有许多需要注意的问题，安全而健壮的<code>hook</code>可以参看文章<a href="http://yulingtianxia.com/blog/2017/04/17/Objective-C-Method-Swizzling/" target="_blank" rel="noopener">Objective-C Method Swizzling</a>。</p><h3 id="Zombie-Objects"><a href="#Zombie-Objects" class="headerlink" title="Zombie Objects"></a>Zombie Objects</h3><p>Zombie Objects是Xcode中用来调试野指针（<code>EXC_BAD_ACCESS</code>）这类内存问题的工具，它充分的应用了Runtime技术：它首先通过Method Swizzling替换原来的<code>-dealloc</code>方法，当对象引用计数为0的时候，会调用新的<code>__dealloc_zombie</code>方法；新的方法中又使用ISA Swizzling技术让对象的<code>isa</code>指向僵尸类，然后释放对象的引用，但并不释放当前对象；最后当程序再向本该已释放的对象发送消息时，在僵尸类的消息转发中就会输出调试信息。</p><p>Zombie Objects中<code>__dealloc_zombie</code>打大致实现（非源码）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)__dealloc_zombie</span><br><span class="line">&#123;</span><br><span class="line">    Class cls = object_getClass(self);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *clsName = class_getName(cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *zombieClsPrefix = <span class="string">"_NSZombie_"</span>;</span><br><span class="line">    <span class="keyword">char</span> *zombieClsName = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(zombieClsPrefix)+<span class="built_in">strlen</span>(clsName)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(zombieClsName, zombieClsPrefix);</span><br><span class="line">    <span class="built_in">strcat</span>(zombieClsName, clsName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看是否存在相同的僵尸对象类名，不存在则创建</span></span><br><span class="line">    Class zombieCls = objc_lookUpClass(zombieClsName);</span><br><span class="line">    <span class="keyword">if</span> (!zombieCls) &#123;</span><br><span class="line">        Class baseZombieCls = objc_lookUpClass(<span class="string">"_NSZombie_"</span>);</span><br><span class="line">        zombieCls = objc_duplicateClass(baseZombieCls, zombieClsName, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放引用。</span></span><br><span class="line">    objc_destructInstance(self);</span><br><span class="line">    <span class="comment">// ISA Swizzling</span></span><br><span class="line">    object_setClass(self, zombieCls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="YYModel"><a href="#YYModel" class="headerlink" title="YYModel"></a>YYModel</h3><p>YYModel运用Runtime面向对象的特性，为根类NSObject添加扩展，实现JSON数据和OC模型之间自动转换。YYModel非常的轻量级，代码也非常的直观，其他利用Runtime特性实现JSON与OC模型互相转换的库还有很多（如：MJExtension），它们对Runtime的利用更加复杂，功能也相对丰富。</p><h3 id="JSPatch"><a href="#JSPatch" class="headerlink" title="JSPatch"></a>JSPatch</h3><p>JSPatch是一个热修复库，它的基本原理是：JS传递字符串给OC，OC通过Runtime动态调用接口和替换OC方法的实现。JSPatch对Runtime的应用还包括动态的注册类，为类添加方法等，实例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class cls = objc_allocateClassPair(superCls, <span class="string">"JPObject"</span>, <span class="number">0</span>);</span><br><span class="line">class_addMethod(cls, selector, implement, typedesc);</span><br><span class="line">objc_registerClassPair(cls);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRunti
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>APP工作机制(四) -- 响应链</title>
    <link href="https://hellohezhili.com/2018/01/13/APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E5%9B%9B-%E5%93%8D%E5%BA%94%E9%93%BE/"/>
    <id>https://hellohezhili.com/2018/01/13/APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E5%9B%9B-%E5%93%8D%E5%BA%94%E9%93%BE/</id>
    <published>2018-01-12T16:00:00.000Z</published>
    <updated>2019-12-13T04:10:48.749Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="iOS基础" scheme="https://hellohezhili.com/categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
      <category term="APP工作机制" scheme="https://hellohezhili.com/categories/iOS%E5%9F%BA%E7%A1%80/APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>APP工作机制(三) -- APP生命周期</title>
    <link href="https://hellohezhili.com/2018/01/07/APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%B8%89-APP%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://hellohezhili.com/2018/01/07/APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%B8%89-APP%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2018-01-06T16:00:00.000Z</published>
    <updated>2020-04-01T14:11:27.368Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Reference:</strong><br><a href="https://www.cnblogs.com/EverNight/p/3818570.html" target="_blank" rel="noopener">app的生命周期</a><br><a href="https://www.jianshu.com/p/d92ecfa01012" target="_blank" rel="noopener">ios background modes</a></p></blockquote><p><em>在知道APP是如何在内存中保持一直运行后之后，接下来需要知道的是APP运行时有哪些主要的状态，以及这些状态是如何切换的。</em></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>应用程序有 Not Running(未运行)，Inactive(未激活)，Active(激活), Background(后台)，Suspended(挂起)五个状态，当状态即将改变或已经改变时，会发送相应通知并在AppDelegate中会执行相应的回调，开发中需要视需求，在状态变换的回调方法中，添加相应的处理。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%B8%80-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%A6%82%E8%A7%88.jpg" alt="概览"></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li>Not Running和Suspended是APP未运行时的两种状态，在APP的抽象对象UIApplication的的<code>applicationState</code>中没有这两种状态，也没有相应的通知和AppDelegate回调；</li><li>需要注意区分APP在刚启动和返回前台时分别触发的<code>applicationDidBecomeActive:</code>；</li><li>APP进入后台前会先进入未激活状态<code>applicationWillResignActive:</code>；</li><li>一般的APP(没有特殊Background Modes的APP)进入后台有5s时间执行代码，之后会被挂起；</li><li>进入后台后通过<code>beginBackgroundTaskWithExpirationHandler:</code>可申请180s的时间<ul><li>申请后台任务需和结束后台任务<code>endBackgroundTask:</code>需成对出现；</li></ul></li><li>挂起的APP依然在内存中，但可能被系统终止，内存不足时系统优先清理内存大的挂起APP；</li><li>APP将要被终止(非崩溃)时会调用<code>applicationWillTerminate:</code>，有5s的任务执行时间。</li></ul><h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><p>APP开始运行之后会根据配置文件info.plist创建APP的抽象对象–UIApplication，这是一个完全单例，在运行期间有且只会有一个，Not Running和Suspended是APP运行期之外的状态，UIApplication对象的<code>applicationState</code>属性中运行时的三种状态：active、inactive和background，当APP运行时的状态将要或已经发生变化时，会发送通知并通过代理模式回调AppDelegate中的方法，由通知接受者或AppDelegate做相应的处理。</p><h3 id="ApplicationState"><a href="#ApplicationState" class="headerlink" title="ApplicationState"></a>ApplicationState</h3><p>APP未运行时的两种状态Not Running和Suspended对于编程没多少意义，需要关心的正是UIApplication对象中<code>applicationState</code>的状态切换，需要清楚的有以下几点：</p><ol><li>APP完成加载前是inactive，完成加载后即进入active状态<ul><li>回调1：<code>application:willFinishLaunchingWithOptions:</code></li><li>回调2：<code>application:didFinishLaunchingWithOptions:</code></li><li>回调3：<code>applicationDidBecomeActive:</code></li></ul></li><li>APP被中断时会进入inactive状态，结束中断时返回active状态<ul><li>回调1：<code>applicationWillResignActive:</code></li><li>回调2：<code>applicationDidBecomeActive:</code></li></ul></li><li>锁屏和home按键也都是中断，所以APP在进入后台前会先进入inactive<ul><li>回调1：<code>applicationWillResignActive:</code></li><li>回调2：<code>applicationDidEnterBackground:</code></li></ul></li><li>从后台返回前台，APP会重新进入active状态<ul><li>回调1：<code>applicationWillEnterForeground:</code></li><li>回调2：<code>applicationDidBecomeActive:</code></li></ul></li><li>普通APP进入后台一段时间后会被挂起，被挂起的APP可能会被系统终止<ul><li>回调：<code>applicationWillTerminate:</code></li></ul></li></ol><p>上述回调方法对应的的APP通知有：</p><ul><li>UIApplicationDidFinishLaunchingNotification;</li><li>UIApplicationDidEnterBackgroundNotification</li><li>UIApplicationWillEnterForegroundNotification</li><li>UIApplicationDidBecomeActiveNotification;</li><li>UIApplicationWillResignActiveNotification;</li><li>UIApplicationWillTerminateNotification;</li></ul><h3 id="Background-Modes"><a href="#Background-Modes" class="headerlink" title="Background Modes"></a>Background Modes</h3><p>APP进入后台后可以按创建时指定的特殊后台运行模式运行，APP可以拥有多种后台运行模式，但审核时如果被认为APP无需所声明的后台运行模式，则审核会被拒。后台模式可以通过info.plist中的Required background modes进行配置，也可以通过<strong>Capabilities-&gt;Background Modes</strong>进行配置(推荐方式)，APP的后台模式如下：</p><ol><li><strong>Audio, AirPlay and Picture in Picture</strong><ul><li>info.plist key: App plays audio or streams audio/video using AirPlay</li><li>音频播放、录制、<a href="http://nto.github.io/AirPlay.html" target="_blank" rel="noopener">使用AirPlay投放</a>，<a href="http://www.jianshu.com/p/27ce4ada48da" target="_blank" rel="noopener">画中画(iPad)</a>，此类APP可以后台常驻</li></ul></li><li><strong>Location updates</strong><ul><li>info.plist key: App registers for location updates</li><li><a href="https://github.com/W-King/Location" target="_blank" rel="noopener">后台获取定位更新</a>，此类APP也可以后台常驻</li></ul></li><li><strong>Voice over IP</strong><ul><li>info.plist key: App provides Voice over IP services</li><li>IP电话，此类APP同样会被挂起，但系统会接管其通信socket，当socket中有数据传来时，会唤醒APP并交回socket</li></ul></li><li><strong>Newsstand downloads</strong><ul><li>info.plist key: App processes Newsstand Kit downloads</li><li><a href="http://www.viggiosoft.com/blog/blog/2011/10/17/ios-newsstand-tutorial/" target="_blank" rel="noopener">杂志类应用</a>，此类APP会被挂起和终止，但可使用NKAssetDownload后台下载杂志，并在下载成功后重新唤醒或启动APP</li></ul></li><li><strong>External Accessory communication</strong><ul><li>info.plist key: App communicates with an accessory</li><li>与MFi外设通信类APP，在外设消息到达时APP会被唤醒，有10s的执行时间</li></ul></li><li><strong>Uses Bluetooth LE accessories</strong><ul><li>info.plist key: App communicates using CoreBluetooth</li><li>与Bluetooth LE设备通信类APP，在设备的消息到达时会被唤醒，有10s的执行时间</li></ul></li><li><strong>Acts as a Bluetooth LE accessory</strong><ul><li>info.plist key: App shares data using CoreBluetooth</li><li>自身作为蓝牙外设的应用，此类APP可以后台常驻，但需要用户授权</li></ul></li><li><strong>Background fetch</strong><ul><li>info.plist key: App downloads content from the network</li><li><a href="http://www.jianshu.com/p/82f639012f3e" target="_blank" rel="noopener">后台定时更新</a>，设置时间间隔，在间隔时间内启动应用更新数据，有30s执行时间</li></ul></li><li><strong>Remote notifications</strong> <ul><li>info.plist key: App downloads content in response to push notifications </li><li><a href="http://www.jianshu.com/p/82f639012f3e" target="_blank" rel="noopener">静默推送</a>，在静默推送到底时，回调对应方法下载内容，有30s执行时间</li></ul></li><li><strong>Background processing</strong><ul><li>info.plist key: App processes data in the background</li><li><a href="http://onevcat.com/2013/08/ios7-background-multitask/" target="_blank" rel="noopener">基于NSURLSession的后台传输</a>，任务成功或失败时，APP会被唤醒并执行<code>application:handleEventsForBackgroundURLSession:completionHandler:</code>回调</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/EverNight/p/3818570.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;app
      
    
    </summary>
    
    
      <category term="iOS基础" scheme="https://hellohezhili.com/categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
      <category term="APP工作机制" scheme="https://hellohezhili.com/categories/iOS%E5%9F%BA%E7%A1%80/APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="APP生命周期" scheme="https://hellohezhili.com/tags/APP%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
      <category term="Background Modes" scheme="https://hellohezhili.com/tags/Background-Modes/"/>
    
  </entry>
  
  <entry>
    <title>APP工作机制(二) -- Runloop</title>
    <link href="https://hellohezhili.com/2017/12/23/APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%BA%8C-Runloop/"/>
    <id>https://hellohezhili.com/2017/12/23/APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%BA%8C-Runloop/</id>
    <published>2017-12-22T16:00:00.000Z</published>
    <updated>2020-04-14T06:43:32.033Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Reference:</strong><br><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a><br><a href="https://www.cnblogs.com/DamonTang/archive/2012/12/07/2807290.html" target="_blank" rel="noopener">RunLoop 详解</a></p></blockquote><p><em>程序运行时代码都是顺序执行的，执行完毕程序就结束退出了，了解APP工作机制的一个基础，是弄清楚APP如何实现在内存中常驻的。</em></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>代码在程序的线程中顺序执行，当程序所有的线程中代码都运行完毕，程序就结束并退出了，iOS与MacOS中通过RunLoop机制来让线程可以一直保持运行，并循环的处理各类事件，从而让APP常驻在内存中持续工作 。系统的某些任务也依托RunLoop来完成，了解RunLoop的运行机制将有助于了解系统任务的机制，同时理解了RunLoop能清楚一个线程中（特别是主线程中）各类任务的代码执行顺序，还将有助于多线程并发编程时的程序设计。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%B8%80-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/RunLoop.png" alt="RunLoop"></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li>RunLoop就是让线程保持一直运行，并可以循环处理事件的机制；</li><li>RunLoop线程一一对应，代码中不能直接创建，而是提供获取主线程和当前线程RunLoop的API，在第一次调取API时，API内部负责创建RunLoop，子线程的RunLoop需要手动启动；</li><li>一个RunLoop包含若干个Mode，每个Mode又包含若干个Source/Timer/Observer；</li><li>RunLoop必须指定一个Mode进行运行，运行后如果Mode中一个items都没有，将会退出运行；</li><li>kCFRunLoopCommonModes是一个伪Mode，用它添加的items，在其他“CommonMode”运行时，也能得到触发，NSTimer通常需要通过此Mode添加到RunLoop中；</li><li>Source分为Source0和Source1，Source0需要手动显示唤醒RunLoop来处理事件，可用于线程间发送消息，Source1是基于端口的，端口有消息能自动唤醒RunLoop来处理事件，用于监听内核端口的消息；</li><li>Timer是在计算好的预设时间点由内核发送时间通知，唤醒RunLoop来处理Timer事件；</li><li>Observer是RunLoop的观察者，RunLoop在某些活动节点会触发其回调，可以据此在对应的时机安排自己APP需要执行的任务；</li><li>RunLoop的休眠/唤醒是通过Mach陷阱切换程序的应用态/内核态来实现的；</li><li>Perform Selector系列方法中<strong>延迟派发、派发给其他线程、以及当前线程异步派发时</strong>，是通过创建源并加入到对应RunLoop中来实现的，必须要目标线程的RunLoop运行，派发的Selector才会被执行，Perform Selector添加的源会在执行后从RunLoop中移除；</li><li>用GCD为主线程派发任务，也是包装成待处理的Source1，再添加到主线程RunLoop中来实现的，但GCD为子线程（并发队列）派发任务，不是通过RunLoop实行的；</li><li>UIEvent是UIKit在主线程中注册一个Source1，通过端口接收到Spring Board转发的IOHIDEvent，再在回调中处理，最后包装成UIEvent的；</li></ul><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="1-什么是RunLoop"><a href="#1-什么是RunLoop" class="headerlink" title="1.什么是RunLoop"></a>1.什么是RunLoop</h3><p>RunLoop是一种iOS与MacOS中让线程<strong>保持一直运行，并可以循环处理事件</strong>的机制。RunLoop在CoreFoundation中通过CFRunLoopRef对象来实现，其提供纯C函数的、线程安全的API；同时还有基于CFRunLoopRef更上层的封装：NSRunLoop，其提供面向对象的API，但不是线程安全的。</p><h3 id="2-RunLoop与线程的关系"><a href="#2-RunLoop与线程的关系" class="headerlink" title="2.RunLoop与线程的关系"></a>2.RunLoop与线程的关系</h3><p>RunLoop与线程是一一对应的，CoreFoundation与NSFoundation中都不提供直接创建RunLoop的API，而是提供了获取主线程RunLoop和当前线程RunLoop的API，在第一次调取线程的RunLoop获取API时，函数内部才为线程创建其RunLoop，并以线程为key，RunLoop为value，保存在一个全局字典中。</p><h3 id="3-RunLoop的相关概念"><a href="#3-RunLoop的相关概念" class="headerlink" title="3.RunLoop的相关概念"></a>3.RunLoop的相关概念</h3><p>RunLoop中的结构如图：</p><p><img src="APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%B8%80-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/RunLoop_Modes_Items.png" alt="RunLoop_Modes_Items"></p><p>一个RunLoop中包含若干个Mode，每个Mode中又包含若干个Source、Timer和Observer，Source、Timer和Observer统称为items，一个item可以添加到不同的Mode，重复添加到同一个Mode没有效果；<strong>启动RunLoop时需要指定一个Mode，Mode中至少要有一个item</strong>，否则RunLoop会立即退出；RunLoop运行期间指定Mode下的items的回调会触发，<strong>如果指定运行的Mode属于”CommondMode”，则标记为 kCFRunLoopCommonModes的items的回调也会触发</strong>；<strong>要切换Mode，必需停止RunLoop，再指定新的Mode重新启动RunLoop</strong>。</p><p>在CoreFoundation中Mode和items对应的类为：CFRunLoopModeRef、CFRunLoopSourceRef、CFRunLoopTimerRef和CFRunLoopObserverRef，下面将分别介绍它们的特性。</p><h4 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h4><p>CFRunLoopModeRef类没有对外暴露，而是提供了一系列根据mode name来管理Mode和Mode下的items（Source、Timer和Observer）的API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管理Mode的接口</span></span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line"><span class="comment">// 管理Mode下items的接口</span></span><br><span class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br></pre></td></tr></table></figure><p>提供的接口只能通过mode name来管理mode，当传入一个新的mode name，而RunLoop内又没有对应的Mode时，RunLoop会自动创建对应的CFRunLoopModeRef；并没有提供删除Mode的API，所以RunLoop的Mode只能增加不能删除。</p><p>系统为主线程的RunLoop默认注册了五个Mode：</p><ol><li>kCFRunLoopDefaultMode：默认Mode，主线程通常也是在此Mode下运行；</li><li>UITrackingRunLoopMode：界面追踪Mode，当需要追踪触摸滑动时，主线程会被切换到此Mode，避免其他items对界面滑动的影响；</li><li>UIInitializationRunLoopMode：APP刚启动时使用的Mode，启动完成后就不再使用；</li><li>GSEventReceiveRunLoopMode：接收系统事件的内部Mode，开发中通常用不到；</li><li>kCFRunLoopCommonModes：占位Mode，不是一个真正的Mode，可以用来添加items，不能用来启动RunLoop；</li></ol><p>上述Mode中开发相关的有：kCFRunLoopDefaultMode、UITrackingRunLoopMode和kCFRunLoopCommonModes，其中kCFRunLoopDefaultMode和UITrackingRunLoopMode是真正的Mode，而kCFRunLoopCommonModes是一个占位Mode。用kCFRunLoopCommonModes添加的items，在RunLoop以一个“CommondMode”运行时，也能得到触发。可以用CFRunLoopAddCommonMode将一个Mode标记为”CommondMode“（既将Mode添加到CFRunLoopRef的_commonModes集合中），kCFRunLoopDefaultMode和UITrackingRunLoopMode都是”CommondMode“。</p><blockquote><p>事件队列中判断Source和Timer的Block是否触发代码逻辑大致如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm) &#123; </span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">while</span> (item) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *<span class="title">curr</span> = <span class="title">item</span>;</span></span><br><span class="line">        item = item-&gt;_next;</span><br><span class="line">        Boolean doit = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123;</span><br><span class="line">            doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!doit) prev = curr;</span><br><span class="line">        <span class="keyword">if</span> (doit) &#123;</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">return</span> did;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h4><p>RunLoop的事件源有两个：输入源和定时源，输入源即Source，可以通过为Mode添加Source，来为RunLoop添加需要处理的事件，在Cocoa层官方将Source分为三类：</p><ul><li>Port-Based Sources</li><li>Custom Input Sources</li><li>Cocoa Perform Selector Sources</li></ul><p>CoreFoundation中输入源则分为非基于端口的Source0和基于端口的Source1，分别对应Custom Input Sources和Port-Based Sources，Cocoa Perform Selector Sources是Perform Selector系列方法创建的源，Perform Selector延迟派发时创建的是定时源，派发给其他线程或当前线程异步派发时创建的Source0，<strong>Perform Selector创建的源，在执行完后会自动从RunLoop中移除</strong>。</p><ul><li><strong>Source0</strong>：只包含一个回调（函数指针），需要应用手动触发，不能主动唤醒RunLoop，使用时需要先调用CFRunLoopSourceSignal(source)，将Source标记为待处理，再手动调用CFRunLoopWakeUp(runloop)，唤醒RunLoop处理Source的事件。</li><li><strong>Source1</strong>：包含一个mach_port和一个回调（函数指针），由mach_port驱动，可以主动唤醒RunLoop，通常用于通过内核和其他线程互相发送消息。</li></ul><h4 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h4><p>Timer就是定时源，是RunLoop的另一个事件源，也可以通过为Mode添加Timer，来为RunLoop添加需要处理的事件。CFRunLoopTimerRef包含一个时间长度和一个回调（函数指针），它与NSTimer是toll-free bridged的，可以混用。当Timer加入到RunLoop之后，会基于XNU内核的mk_timer或GCD计时器（根据CoreFoundation的版本不同而不同），在计算好的预设时间点由内核发送通知，唤醒RunLoop处理Timer的事件。</p><h4 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h4><p>Observer是RunLoop的观察者，包含一个回调（函数指针），当RunLoop运行到特定状态时会触发回调，并将状态传递给回调函数，会触Observer回调的状态包括：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry         = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入循环</span></span><br><span class="line">    kCFRunLoopBeforeTimers  = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting  = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit          = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出循环</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-RunLoop的核心逻辑"><a href="#4-RunLoop的核心逻辑" class="headerlink" title="4.RunLoop的核心逻辑"></a>4.RunLoop的核心逻辑</h3><p>CoreFoundation的版本不同，RunLoop的核心源码可能不一致，但逻辑不会有太大的出入，整体可以参考以下对CoreFoundation <a href="http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz" target="_blank" rel="noopener">CF-855.17版本</a>源码删减后的逻辑整理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 公开接口一：用DefaultMode启动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 公开接口二：用指定的Mode启动（允许设置RunLoop超时时间）</span></span><br><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunInMode</span><span class="params">(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    <span class="keyword">return</span> CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// RunLoop的实现</span></span><br><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">  <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span> kCFRunLoopRunFinished;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line"> Boolean did = <span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">return</span> did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    <span class="keyword">int32_t</span> result = kCFRunLoopRunFinished;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line"><span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line"> result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line"> <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">    rl-&gt;_currentMode = previousMode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 内部核心函数，进入loop</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 如果当前是主线程RunLoop，且当前mode的第一次运行，会分发一个GCD端口（用于第5步）</span></span><br><span class="line">    <span class="keyword">mach_port_name_t</span> dispatchPort = MACH_PORT_NULL;</span><br><span class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="literal">NULL</span> == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="number">0</span> == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</span><br><span class="line">    <span class="keyword">if</span> (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 给当前模式分发GCD定时端口</span></span><br><span class="line">    <span class="keyword">mach_port_name_t</span> modeQueuePort = MACH_PORT_NULL;</span><br><span class="line">    <span class="keyword">if</span> (rlm-&gt;_queue) &#123;</span><br><span class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</span><br><span class="line">        <span class="keyword">if</span> (!modeQueuePort) &#123;</span><br><span class="line">            CRASH(<span class="string">"Unable to get port for run loop mode queue (%d)"</span>, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/// 初始化一个GCD计时器，用于第7步对RunLoop进行超时唤醒</span></span><br><span class="line">    <span class="keyword">dispatch_source_t</span> timeout_timer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">timeout_context</span> *<span class="title">timeout_context</span> = (<span class="title">struct</span> __<span class="title">timeout_context</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(*<span class="title">timeout_context</span>));</span></span><br><span class="line">    <span class="keyword">if</span> (seconds &lt;= <span class="number">0.0</span>) &#123; <span class="comment">// instant timeout</span></span><br><span class="line">        seconds = <span class="number">0.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR = <span class="number">0U</span>LL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</span><br><span class="line">        <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT);</span><br><span class="line">        timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">queue</span>);</span><br><span class="line">        dispatch_retain(timeout_timer);</span><br><span class="line">        timeout_context-&gt;ds = timeout_timer;</span><br><span class="line">        timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</span><br><span class="line">        timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</span><br><span class="line">        dispatch_set_context(timeout_timer, timeout_context); <span class="comment">// source gets ownership of context</span></span><br><span class="line">        dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</span><br><span class="line">        <span class="keyword">uint64_t</span> ns_at = (<span class="keyword">uint64_t</span>)((__CFTSRToTimeInterval(startTSR) + seconds) * <span class="number">1000000000U</span>LL);</span><br><span class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(<span class="number">1</span>, ns_at), DISPATCH_TIME_FOREVER, <span class="number">1000U</span>LL);</span><br><span class="line">        dispatch_resume(timeout_timer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// infinite timeout</span></span><br><span class="line">        seconds = <span class="number">9999999999.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Boolean didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> msg_buffer[<span class="number">3</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">mach_msg_header_t</span> *msg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">mach_port_t</span> livePort = MACH_PORT_NULL;</span><br><span class="line">        __CFPortSet waitSet = rlm-&gt;_portSet;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 2. 通知 Observers: RunLoop开始处理Timer</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">       <span class="comment">/// 3. 通知 Observers: RunLoop即将处理Source0(非port)回调</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 执行可能即时提交到队列中的block</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 4. 处理Source0</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 如果Source0中有待处理的事件，执行Source0提交到队列中的block</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 标志是否等待端口唤醒</span></span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0U</span>LL == timeout_context-&gt;termTSR);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 5. 如果是主线程（dispatchPort是主线程才会被赋值）在进入休眠前会检查是否有通过GCD派发过来的Source1，如果有，跳过休眠到第9步进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">        <span class="comment">/// 首次循环是不会进入检查（didDispatchPortLastTime为true）</span></span><br><span class="line">            msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        didDispatchPortLastTime = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 6.通知 Observers: RunLoop即将进入休眠(sleep)</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopSetSleeping(rl); </span><br><span class="line">   </span><br><span class="line">       <span class="comment">/// 7. 调用mach_msg等待接受mach_port的消息，线程将进入休眠, 直到被下面某一个事件唤醒：</span></span><br><span class="line">       <span class="comment">/// • 某个基于port的Source1有消息到达</span></span><br><span class="line"> <span class="comment">/// • 某个Timer的时间到了</span></span><br><span class="line"><span class="comment">/// • RunLoop为自身设定的超时时间到了</span></span><br><span class="line"><span class="comment">/// • 被其他调用者手动显式唤醒</span></span><br><span class="line">        </span><br><span class="line">       msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">       __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY);</span><br><span class="line"></span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 8. 通知 Observers: RunLoop的线程刚刚被唤醒了。</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 事件处理的跳转标准</span></span><br><span class="line">    handle_msg:</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/// 9. 处理未处理的事件</span></span><br><span class="line"><span class="keyword">if</span> (MACH_PORT_NULL == livePort) &#123;</span><br><span class="line">            <span class="comment">/// 无端口唤醒，RunLoop正常运行不会有此情况</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">            <span class="comment">/// 被自身的CGD超时计时器唤醒，无需做任何处理</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">            <span class="comment">/// 被定时器通知唤醒，处理定时器事件</span></span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</span><br><span class="line">            <span class="comment">///  主线程被GCD派发的事件唤醒，或由第5步直接跳转过来，处理派发的事件</span></span><br><span class="line">          CFRUNLOOP_WAKEUP_FOR_DISPATCH();</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/// 被source1唤醒,处理Source1</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</span><br><span class="line">            <span class="keyword">mach_msg_header_t</span> *reply = <span class="literal">NULL</span>;</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">/// 执行以上各类事件时加入到队列中的block</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 跳出循环，停止RunLoop的各类情况</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            <span class="comment">/// 启动RunLoop时即指明处理完事件就返回</span></span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            <span class="comment">/// RunLoop运行超过启动时指明的超时时间</span></span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            <span class="comment">/// 被外部调用者手动终止了RunLoop</span></span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">            <span class="comment">/// RunLoop被标记为已停止了</span></span><br><span class="line">            rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            <span class="comment">/// 当前Mode中Source/Timer/Observer都被移除了</span></span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 释放RunLoop自身的超时GCD计时器</span></span><br><span class="line">    <span class="keyword">if</span> (timeout_timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">free</span>(timeout_context);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>值得一提的是<a href="http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz" target="_blank" rel="noopener">CF-855.17版本</a>是CoreFoundation使用mk_timer和GCD计时器的一个过渡版本，源码中有分使用mk_timer和GCD计时器的条件编译，以上代码逻辑的整理中，只参照了使用GCD计时器的源码。</p></blockquote><p>对<strong>RunLoop核心代码逻辑的关键流程概述</strong>如下：</p><ol><li>通知Observer：RunLoop进入Loop；</li><li>通知Observer：RunLoop开始处理Timer；</li><li>通知Observer：RunLoop即将处理Source0；</li><li>执行Source0加入到事件队列中的Block；</li><li>如果是主线程RunLoop，检查是否有通过GCD派发给主线程的待处理的Source1：<ul><li>没有：继续下一步；</li><li>有：跳到第9步去处理Source1；</li></ul></li><li>通知Observer：RunLoop即将进入休眠；</li><li>休眠，等待被唤醒：<ul><li>某个基于port的Source1有消息到达；</li><li>某个Timer的时间到了；</li><li>RunLoop为自身设定的超时时间到了；</li><li>被其他调用者手动显式唤醒；</li></ul></li><li>通知Observer：RunLoop刚被唤醒；</li><li>开始处理未处理的事件：<ul><li>超时唤醒，不用做任何处理；</li><li>Timer到时了，处理Timer的事件；</li><li>如果是主线程，处理GCD派发过来的事件；</li><li>处理基于port的Source1；</li></ul></li><li>通知Observer：已经退出Loop；</li></ol><p>RunLoop的代码内部是一个do-while循环，循环的执行上述流程的第2-9步，<strong>以下情况会导致此次流程后跳出循环，退出RunLoop</strong>：</p><ol><li>启动RunLoop时的参数指明：执行一遍事件处理流程就退出循环；</li><li>超过了启动RunLoop时指定的超时时间；</li><li>被外部调用者手动显式的终止了RunLoop；</li><li>RunLoop被标记为已停止（_stopped）了；</li><li>当前Mode中Source/Timer/Observer都被移除了;</li></ol><p>RunLoop在需要时被唤醒，在不需要时进行休眠，<strong>其原理是通过mach_msg( )调用了一个Mach陷阱：mach_msg_trap( )，将线程由用户态切换为内核态，在内核态下等待消息</strong>，当有消息到达时又返回用户态进行处理，其逻辑示意如图：</p><p><img src="APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%B8%80-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/RunLoop_Trap.png" alt="RunLoop_Trap"></p><h3 id="5-系统中对RunLoop的应用"><a href="#5-系统中对RunLoop的应用" class="headerlink" title="5.系统中对RunLoop的应用"></a>5.系统中对RunLoop的应用</h3><h4 id="Perform-Selector"><a href="#Perform-Selector" class="headerlink" title="Perform Selector"></a>Perform Selector</h4><p>Perform Selector系列方法延迟派发创建的是定时源，派发给其他线程或当前线程异步派发时创建的Source0，再添加到指定线程的RunLoop中。所以如果使用Perform Selector<strong>延迟派发、派发给其他线程、以及当前线程异步派发时</strong>，要注意判断目标线程的RunLoop是否在运行，如果未运行则派发的任务就不会被执行。</p><h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><p>使用GCD为主线程派发任务，会唤醒主线程RunLoop，并对派发的事件进行处理，在每次主线程RunLoop休眠前，还会检查是否有GCD派发过来的事件，如果有，则会跳过休眠，开始对事件进行处理。但以上RunLoop中的逻辑，仅限于主线程中的RunLoop，通过GCD为其他线程派发的任务，则是由libDispatch处理，所以GCD将任务派发给子线程时，也不需要子线程的RunLoop处于运行状态。</p><h4 id="UIEvent"><a href="#UIEvent" class="headerlink" title="UIEvent"></a>UIEvent</h4><p>系统为APP注册了一个Source1用来接收操作系统的事件。当一个硬件事件（触摸/锁屏/摇晃等）发生后，先由IOKit.framework生成一个IOHIDEvent，并由SpringBoard接收，SpringBoard再通过mach_port转发给需要的APP；APP中系统注册的那个Source1接收到mach_port中传递过来的消息后，唤醒主线程RunLoop，在其回调中调用_UIApplicationHandleEventQueue( )进行APP内部的分发；_UIApplicationHandleEventQueue( )中会把IOHIDEvent包装成UIEvent，再通过APP的响应链传递给对应的响应者。</p><h4 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h4><p>NSTimer其实就是CFRunLoopTimerRef，他们之间是toll-free bridged的（<a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html#//apple_ref/doc/uid/TP40010677-SW4" target="_blank" rel="noopener">Toll-Free Bridged Types</a>）。根据版本不同RunLoop的Timer可能基于内核的mk_timer或者GCD的timer来实现的，Timer并不是绝对准时的，而是有一个宽容度（Tolerance），实际执行的时间可能在这个宽容度允许的误差之内，如果因为执行队列中其他事件造成时间超过了宽容度所允许的误差，那么这次Timer的block不会延后执行，而是会被跳过。</p><p>NSTimer默认是添加到RunLoop的kCFRunLoopDefaultMode中的，如果需要NSTimer在RunLoop切换为其他Mode运行时也会正确触发，需要通过kCFRunLoopCommonModes来添加NSTimer。</p><h4 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h4><p>APP启动后，系统为主线程RunLoop注册了两个Observer来管理主线程的自动释放池：</p><ul><li>第一个Observer只观察kCFRunLoopEntry：在其回调中调用_objc_autoreleasePoolPush( )创建自动释放池；</li><li>第二个Observer观察两个事件：在其回调中观察到kCFRunLoopBeforWaiting，会调用_objc_autoreleasePoolPop( )，再调用_objc_autoreleasePoolPush( )，以释放旧池并创建新池；回调中观察到kCFRunLoopExit，会调用_objc_autoreleasePoolPop( )来释放自动释放池；</li></ul><p>子线程中的自动释放池会在使用时懒加载，在线程退出时释放，所以一般子线程中也无需考虑内存自动释放的问题，但是如果通过运行子线程的RunLoop来让子线程常驻，可能需要考虑为某些自动释放对象添加自动释放池来避免内存泄漏。</p><h4 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h4><p>当更改了UI之后，比如改变了Frame、更新了UIView/CALayer的层次、或手动调用了UIView/CALayer的setNeedsLayout/setNeedsDisplay等，这个UIView/CALayer会被标记为待处理，然后提交到一个全局容器中去。系统为主线程注册了一个Observer来刷新UI，在其回调中，当观察到kCFRunLoopBeforWaiting和kCFRunLoopExit时，会调用一个函数去遍历所有待处理的UIView/CALayer，为它们执行实际的绘制和调整，来完成界面的刷新。</p><h4 id="NSURLConnection与NSURLSession"><a href="#NSURLConnection与NSURLSession" class="headerlink" title="NSURLConnection与NSURLSession"></a>NSURLConnection与NSURLSession</h4><p>NSURLConnection已经被NSURLSession取代，但底层的部分逻辑却在沿用，同时NSURLConnection对RunLoop的运用也可作为多线程编程设计的参考：开始网络任务时，会为NSURLConnection设置一个delegate，除了这个开始任务时的delegate线程，NSURLConnection又注册了两个新线程com.apple.NSURLConnectionLoader和com.apple.CFSocket.private，三个线程间的消息交流如图所示：</p><p><img src="APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%B8%80-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/RunLoop_network.png" alt="RunLoop_network"></p><p>CFSocket线程负责处理底层socket连接，NSURLConnectionLoader则负责居中调度。开始一个网络任务时，NSURLConnection创建了4个Source0，并添加到了delegate线程RunLoop的DefaultMode中，NSURLConnectionLoader线程本身通过一个Source1来接收底层CFSocket线程根据网络连接产生的通知，在NSURLConnectionLoader线程的Source1回调中，又通过delegate线程的4个Source0把相关的通知传递给delegate线程，在这些Source0的回调中再执行真正的delegate回调方法。</p><h3 id="6-三方库对RunLoop的应用"><a href="#6-三方库对RunLoop的应用" class="headerlink" title="6.三方库对RunLoop的应用"></a>6.三方库对RunLoop的应用</h3><h4 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h4><p>在AFNetworking2.x中通过开启子线程的RunLoop来创建了一条常驻线程，相关代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@<span class="string">"AFNetworking"</span>];</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> NSThread *_networkRequestThread = nil;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    <span class="keyword">if</span> ([self isCancelled]) &#123;</span><br><span class="line">        [self performSelector:@selector(cancelConnection) onThread:[[self <span class="class"><span class="keyword">class</span>] <span class="title">networkRequestThread</span>] <span class="title">withObject</span>:</span>nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([self isReady]) &#123;</span><br><span class="line">        self.state = AFOperationExecutingState;</span><br><span class="line">        [self performSelector:@selector(operationDidStart) onThread:[[self <span class="class"><span class="keyword">class</span>] <span class="title">networkRequestThread</span>] <span class="title">withObject</span>:</span>nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AFNetworking2.x是基于NSURLConnection的，AFNetworking在常驻子线程中异步的start所有NSURLConnection，也在此线程中接收所有NSURLConnection的delegate回调，所以需要子线程常驻。</p><p>由于NSURLConnection需要delegate线程保持活跃来接收回调，如果维持一个常驻子线程来管理NSURLConnection的网络请求则开销太大了，在NSURLSession中已经改为指明delegateQueue（NSOperationQueue）来处理网络回调，AFNetworking3.x之后网络请求改为使用NSURLSession，所以也不再需要常驻子线程来处理网络回调了。</p><p>值得一提的是NSURLSession的delegateQueue的maxConcurrentOperationCount通常需要设为1，来将代理队列设置为一个串行队列，这是因为即使设置为并发队列，在回调中通常也需要加锁来处理，实际也是串行执行，直接设置为串行队列，则无需再添加加锁等操作。</p><h4 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a>ReactiveCocoa</h4><p>在RAC的一个Testing方法中，通过如下方法来使用RunLoop：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">[NSRunLoop.mainRunLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:<span class="number">0.1</span>]];</span><br><span class="line">&#125; <span class="keyword">while</span> (!done);</span><br></pre></td></tr></table></figure><p>上面代码是用来满足RAC单元测试时的需求：短暂的运行起主线程，以接收通过主线程派发的RACSignal。这种在do-while循环中设置一个超时时间来运行RunLoop的方式值得参考，在现在的ARC下，它其实起到了定时释放旧池（自动释放池）并创建新池的作用（每一次循环，ARC会自动为其添加自动释放池的创建与释放）。</p><h4 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h4><p>Texture原名AsyncDisplayKit，是一个界面性能优化框架，相较于UIKit把界面元素的创建、绘制、渲染、销毁等任务都在主线程中顺序完成，它把界面显示的相关任务进行了拆分，再把可以放到子线程的任务并发的执行，把可以推迟的任务延后执行，把可以合并的任务合并显示，以此来保证界面的流畅性。</p><p>Texture中也有对RunLoop的相关应用，相关逻辑如图所示：<br><img src="APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%B8%80-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/ios_vsync_runloop.png" alt="ios_vsync_runloop"></p><p>Texture把界面元素中<strong>必须在主线程完成的部分任务，先封装到一个全局容器中</strong>，然后在主线程RunLoop中注册了一个Observer，观察的事件和CoreAnimation的Observer观察的事件相同：kCFRunLoopBeforeWaiting和kCFRunLoopBeforeExit，但回调优先级低于CoreAnimation的回调，这样在RunLoop每次<strong>休眠前或退出时，在CoreAnimation的回调处理完成后，Texture再执行自己全局容器中提交的任务</strong>，此时这些必须在主线程完成的任务<strong>需要依赖的任务，便可能已经异步、并发的完成</strong>，此处Texture也<strong>完成了将这些异步、并发的操作同步到主线程</strong>中去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://blog.ibireme.com/2015/05/18/runloop/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入理解Run
      
    
    </summary>
    
    
      <category term="iOS基础" scheme="https://hellohezhili.com/categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
      <category term="APP工作机制" scheme="https://hellohezhili.com/categories/iOS%E5%9F%BA%E7%A1%80/APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>APP工作机制(一) -- 内存与内存管理</title>
    <link href="https://hellohezhili.com/2017/12/16/APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%B8%80-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://hellohezhili.com/2017/12/16/APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%B8%80-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2017-12-15T16:00:00.000Z</published>
    <updated>2020-04-01T14:22:05.006Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Reference:</strong><br><em>Effective Objective-C 2.0</em><br><a href="https://blog.devtang.com/2016/07/30/ios-memory-management/" target="_blank" rel="noopener">理解 iOS 的内存管理</a><br><a href="https://hit-alibaba.github.io/interview/basic/arch/Memory-Management.html" target="_blank" rel="noopener">内存管理基础</a><br><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/MM.html" target="_blank" rel="noopener">Objective-C 中的内存分配</a><br><a href="https://draveness.me/block-retain-object" target="_blank" rel="noopener">iOS中的block是如何持有对象的</a></p></blockquote><p><em>程序都是加载到内存中运行，了解APP工作机制，第一步先了解APP是如何使用内存的。</em></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>程序加载到内存中运行时，在内存中分静态数据(只读)和动态数据(读写)两部分，其中动态部分中堆的分配与释放由程序做内存管理，iOS中使用引用计数机制配合自动释放池来做内存管理，又使用ARC来简化引用计数和自动释放的编程：</p><ul><li><strong>引用计数</strong>：对于堆中的对象，想要保留时使其引用计数+1，想要释放时使其引用计数-1，当对象的引用计数为0时，系统会销毁对象回收内存；</li><li><strong>ARC技术</strong>：依赖编译器的静态分析，在编译时为对象插入保留、释放、自动释放等引用计数管理代码，并在运行时对引用计数管理代码做优化;</li><li><strong>自动释放</strong>：自动释放标记使对象引用计数延迟-1，即自动释放池销毁时，对象在此自动释放池管理范围内被标记了几次，就会做几次引用计数-1；</li></ul><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%B8%80-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png" alt="iOS内存管理"></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li>内存中静态数据不会发生变化，栈则由系统自动管理，编程中内存管理是对堆的分配和回收；</li><li>iOS中使用引用计数来管理内存，又使用ARC来简化引用计数的编程；</li><li>自动释放池满足了对象归当前调用者所有，但又需要延迟释放的引用计数管理需求；</li><li>ARC中指向对象的指针都需表明自己对对象的所有权，普通指针通过所有权修饰符指明，属性的成员变量则通过属性修饰符指明；</li><li>推荐用__autoreleasing来修饰结果参的形参，这样可以减少ARC的开销；</li><li>现在的ARC中虽然不再需要使用@autoreleasepool { }来消除大量的局部对象所造成的内存峰值，但依然可以保留这种写法以兼容较老的版本；</li><li>CoreFoundation中的对象不由ARC管理，当和ARC管理的OC对象互相转换时，需视情况指明对象所有权是否发生变化；</li><li>ARC中需要注意对象间相互引用、performSelector相关接口和异常捕获时可能出现的内存泄露；</li><li>block分为全局block、栈block和堆block，MRC中需要持有一个block时，使用它的copy总是没错，ARC中可以将block直接赋值给变量，因为ARC会视情况自动copy；</li><li>ARC中block会保留其捕获的环境局部变量对对象的引用，所以可能造成循环引用，可以使用弱引用指针来避免循环引用，还可以结合临时强引用指针来避免block执行期间对象被释放；</li><li>NSString和NSMutableString都是抽象类，iOS中字符串的实际类型为<strong>NSCFString、</strong>NSCFConstantString和NSTaggedPointerString，它们在内存中的生命周期和管理方式各不相同；</li><li>当出现内存问题时，Xcode自带的僵尸对象可以调试野指针问题，Instruments中的Leaks可以检查内存泄露问题，三方框架FBRetainCycleDetector可以检查对象的循环引用问题；</li></ul><h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><h3 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1.内存模型"></a>1.内存模型</h3><p>程序在内存中运行时分静态数据和动态数据：静态数据只读，存储在代码段(.text)和数据段(.data + .bbs)，中这部分数据占用的内存在运行时不会发生变化，在程序终止后被清理；动态数据可读写，存储在栈(stack)和堆(heap)中，这部分数据占用的内存会随着程序运行而动态变化，其中栈的使用由系统管理，而堆的的使用则需要程序进行管理。</p><p><img src="APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%B8%80-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg" alt="内存模型"></p><p>栈由高位向低位增长，是因程序中函数运行而临时占用的内存，由系统的入栈和出栈操作来自动管理。堆由低位向高位增长，需要由程序自行管理，编程中的内存管理即是指对堆的分配与回收，运行中不再使用的内存却未回收便是内存泄露，还在使用的内存却被回收了便是野指针问题。</p><blockquote><p>栈的内存变化：每一个函数的调用就会向栈中压入一个函数的帧，函数帧中包括函数的形参、局部变量和返回地址等信息，有多少层函数调用就会压多少个帧，当函数执行结束时其函数帧就会出栈，并回到函数的返回地址继续执行，随着函数执行时函数帧的入栈与出栈，程序对栈的占用也随之发生变化。</p></blockquote><h3 id="2-引用计数"><a href="#2-引用计数" class="headerlink" title="2.引用计数"></a>2.引用计数</h3><p>iOS中使用引用计数来做内存管理，对象的创建方法为其在堆中分配内存，并将引用计数初始为1，对象创建后想要保留时使其引用计数+1，想要释放时使其引用计数-1，当对象的引用计数为0时，系统会销毁对象回收内存。</p><p>引用计数手动管理方法：</p><ul><li>retain</li><li>release</li><li>autorelease</li></ul><p>引用计数初始为1的创建方法：</p><ul><li>alloc</li><li>new</li><li>copy</li><li>mutableCopy</li></ul><p><strong>通过以上方法创建的对象归调用者所有，需要调用者在使用后将其引用计数-1</strong></p><h3 id="3-ARC技术"><a href="#3-ARC技术" class="headerlink" title="3.ARC技术"></a>3.ARC技术</h3><p>ARC编程时指向对象的引用(指针)都需要表明对对象的所有权，普通指针通过所有权修饰符指明(如果没有显示声明所有权修饰符，则缺省为__strong)，属性的成员变量则通过属性修饰符指明，编译时则依据指针对对象的所有权添加引用计数管理代码(引用计数管理的相关C函数，而非MRC中的OC方法)，运行时对于引用计数管理代码又做了适当的优化。ARC既简化了引用计数管理代码的编程，又优化了引用计数管理代码的执行，Objective-C和Objective-C++的对象都可以依赖ARC进行内存管理，CoreFoundation中的对象则需要手动管理引用计数。</p><h4 id="ARC中的所有权修饰符"><a href="#ARC中的所有权修饰符" class="headerlink" title="ARC中的所有权修饰符"></a>ARC中的所有权修饰符</h4><p>ARC中有以下4种所有权修饰符：</p><ul><li><strong>__strong</strong>：强引用，默认的修饰符，使引用计数+1，对应属性修饰符中的<code>strong</code>、<code>copy</code>和<code>retain</code>；</li><li><strong>__weak</strong>：弱引用，不会引起引用计数变化，对象释放后会自动指向nil，对应属性修饰符中的<code>weak</code>；</li><li><strong>__unsafe_unretained</strong>：不安全的弱引用，不会引起引用计数变化，对象释放后不会自动指向nil，容易造成野指针，但比__weak性能更好，对应属性修饰符中的<code>assign</code>和<code>unsafe_unretained</code>;</li><li><strong>__autoreleasing</strong>：自动释放引用，会使引用计数+1，并在自动释放池释放时延迟-1，常用于申明结果参的形参。</li></ul><blockquote><p>NSNotificationCenter对Observer的引用在iOS9之前是unsafe_unretained的，需要在对象dealloc前removeObserver，否则容易出现野指针问题，iOS9之后对Observer的引用改为了weak，在对象dealloc时没有removeObserver也不再有野指针的问题。</p></blockquote><h4 id="ARC与CoreFoundation"><a href="#ARC与CoreFoundation" class="headerlink" title="ARC与CoreFoundation"></a>ARC与CoreFoundation</h4><p>CoreFoundation中的对象不由ARC管理，依然需要手动管理引用计数，ARC中CF对象和OC对象进行相互转换时，需要通过关键字指明转换后对象所有权的变化：</p><ul><li><strong>__bridge</strong>：用于CF和OC对象的相互转换，不发生所有权的变化，引用计数不变。CF对象转OC对象，则对象依然需要在CF中手动管理引用计数；OC对象转CF对象，则对象由ARC管理，CF中可以不对其做手动的引用计数管理。</li><li><strong>__bridge_retained</strong>：等效于<code>CFBridgingRetain</code>，用于OC对象转CF对象，CF保留一次对象的所有权，引用计数+1。相当于转换完成后再调用了一次<code>CFRetain</code>。</li><li><strong>__bridge_transfer</strong>：等效于<code>CFBridgingRelease</code>，用于CF对象转OC对象，CF释放一次对象的所有权，引用计数-1。相当于转换完成后再调用了一次<code>CFRelease</code>。</li></ul><h4 id="ARC中的内存泄露"><a href="#ARC中的内存泄露" class="headerlink" title="ARC中的内存泄露"></a>ARC中的内存泄露</h4><p>ARC为程序自动添加了引用计数管理代码，但如果编程过程中不注意，依然可能出现内存泄露的情况：</p><ol><li><strong>循环引用造成的内存泄露</strong>：A直接或间接的保留了B，B又直接或间接的保留了A，就会出现循环引用，这在block的使用中尤其容易出现，循环引用的对象在互相等对方释放自己，最终是都不会释放，造成内存泄露。ARC可以使用弱引用来避免循环引用的出现，也可以在出现循环引用后手动解除引用环。</li><li><strong>performSelector相关API造成的内存泄露</strong>：当派发的选择子不明确的时候，ARC中编译器不知道是否应该为返回的对象添加释放的代码，所以ARC选择不添加释放代码的保守做法，这样当选择子是new、alloc、copy和mutableCopy这些应当由调用者释放返回对象的方法时，就会造成内存泄露。可以添加额外的判断，当选择子是需要调用者释放返回对象的方法时，将返回对象转为CoreFoundation对象，再用__bridge_transfer转回OC对象，使其引用计数-1来避免内存泄露。</li><li><strong>异常捕获代码造成的内存泄露</strong>：异常捕获代码<code>@try{ } @catch{ } @finally{ }</code>的<code>@try{ }</code>中出现异常时会跳过后面的代码，进入<code>@catch{ }</code>中继续执行，如果<code>@try{ }</code>中创建并持有了临时对像，那么即使ARC为其添加了释放代码，也不会被执行，如此便会造成内存泄露。解决的办法是避免在<code>@try{ }</code>中使用new、alloc、copy和mutableCopy等方法来创建并持有对象，或者为文件添加-fobjc-arc-exceptions标识让ARC生成额外的代码来做处理(影响运行期性能)，更推荐的做法其实是避免使用异常捕获代码。</li></ol><blockquote><p>在OC的编程中并推荐编写异常安全代码(异常捕获)，因为<strong>OC的语言设计中认为只有严重到需要程序终止的错误才应该抛出异常</strong>，那么既然抛出异常时程序应该终止，也就无需捕获异常书写异常安全代码。对于可被接受或进一步处理的错误，OC中推荐通过返回nil/0或使用NSError来传递错误信息，并在接收到错误信息后做相应处理。</p></blockquote><h3 id="4-自动释放"><a href="#4-自动释放" class="headerlink" title="4.自动释放"></a>4.自动释放</h3><p>有时不想再保留对象但又不想对象被马上释放时，比如函数中生成的对象作为函数的返回值，可以使用autorelease来标记对象，让对象在其所在的自动释放池<code>drain</code>时自动释放，达到延迟释放的效果。</p><h4 id="autorelease与-autorelease"><a href="#autorelease与-autorelease" class="headerlink" title="autorelease与__autorelease"></a>autorelease与__autorelease</h4><p>MRC和ARC中分别用autorelease和__autorelease为对象做自动释放标记，在一个自动释放池管理范围内对象被标记了几次自动释放，自动释放池<code>drain</code>时就会为其做几次引用计数-1。</p><p>ARC中通常用来__autorelease声明结果参(二级指针形参)的实参，关于这种使用场景需要清楚的有：</p><ol><li>强引用的局域对象在出了作用域时引用计数-1，__autoreleasing指向的局域对象，会延迟释放，即离开作用域引用计数也不会-1，而是在当前自动释放池释放时才引用计数-1；</li><li>强引用形参会使引用计数+1，但是是函数作用域的局域对象，出了函数作用域引用计数-1，__autoreleasing修饰的形参不会使引用计数+1，出了函数作用域也不会-1；</li><li>当形参是结果参时(二级指针)如果传入的实参未做<strong>autoreleasing修饰，为结果参赋值时，ARC会添加一个</strong>autoreleasing的指针指向所赋的结果，使结果参返回后延迟释放；如果实参已经有__autoreleasing修饰，则在为结果参赋值时ARC不会添加额外的代码。</li></ol><h4 id="autoreleasePool"><a href="#autoreleasePool" class="headerlink" title="autoreleasePool"></a>autoreleasePool</h4><p>关于自动释放池需要清楚的有以下几点：</p><ol><li>每个线程通过自己的自动释放池栈维护着线程中添加的自动释放池，对象被标记为自动释放时会添加到栈顶的自动释放池中；</li><li>每个线程都会为其自动释放池栈中创建一个默认自动释放池，主线程会监听main runloop的活动并通过入栈和出栈来周期性的新建和销毁自动释放池，子线程的默认自动释放池在使用时懒加载，在线程退出时清空；</li><li><code>@autoreleasepool { }</code>添加了自动释放池，但在离开其作用域后就已经释放了，可用其来做精细内存管理；</li><li>在MRC和早期的ARC中推荐用<code>@autoreleasepool { }</code>来消除内存峰值，现在的ARC中生成的局部对象，在离开局部作用域后就已经被释放了，已经不需要自动释放池来消除内存峰值，但依然可以保留这种写法以兼容老版本。</li></ol><h3 id="5-Block与内存管理"><a href="#5-Block与内存管理" class="headerlink" title="5.Block与内存管理"></a>5.Block与内存管理</h3><h4 id="Block自身的内存管理"><a href="#Block自身的内存管理" class="headerlink" title="Block自身的内存管理"></a>Block自身的内存管理</h4><p>block其实是一个结构体，但也有一个指向类的isa指针，所以也可视为一种特殊的对象。block的isa指向抽象类<code>NSBlock</code>的子类<code>__NSMallocBlock__</code>、<code>__NSStackBlock__</code>或<code>__NSGlobalBlock__</code>，根据其实际类的不同可将block分为堆block、栈block和全局block，它们在内存中有不同的管理方法：</p><ul><li>全局block(<code>__NSGlobalBlock__</code>)：和C函数一样储存在代码段，无需内存管理；</li><li>栈block(<code>__NSStackBlock__</code>)：类似于函数中的局部变量，由系统自动管理；</li><li>堆block(<code>__NSMallocBlock__</code>)：和普通对象一样由引用计数进行管理，支持ARC；</li></ul><p>声明一个block时，block可以使用环境变量，对环境中全局变量和静态变量的使用不会影响block的类型，可<strong>如果使用了环境中的局部变量，声明的block将会是一个栈block，如果没有使用环境中的局部变量，则将会是一个全局block</strong>。对栈block进行copy会得到一个其在堆中的拷贝，而栈block的生命周期仅限于其声明时的作用域，所以若要持有一个栈block，<strong>MRC中需要手动调用栈block的copy来使用堆block，而ARC中则在将栈block赋值给变量时就自动进行了copy</strong>，而又因为全局block和堆block的copy返回的都是其自身，所以<strong>在需要持有一个block时，使用它的copy总是没错</strong>。</p><h4 id="Block中对象的内存管理"><a href="#Block中对象的内存管理" class="headerlink" title="Block中对象的内存管理"></a>Block中对象的内存管理</h4><p><strong>ARC中block会保留其捕获的环境局部变量对对象的引用</strong>，也就是说如果block中出现的环境局部变量是一个强引用指针，则block也会对该指针指向的对象强引用，如果捕获的环境局部变量是弱引用指针，则block对指针指向的对象也是弱应用，至于环境局部变量是自动释放引用指针，则不能在block中使用。</p><p>因为block的上述特性，如果block中要使用的局部变量是一个强引用指针，且指针指向的对象直接或间接的又强引用了该block，则会出现循环引用，造成内存泄露。针对这种情况，可以<strong>先用一个弱引用指针指向要使用的对象，再在block中使用弱引用指针，则能避免循环引用</strong>；而如果还<strong>需要防止block中代码执行期间，弱引用指针指向的对象被释放掉，则又可以在block中用先用一个临时的强引用指针来持有弱引用指针指向的对象</strong>，这个临时的强引用指针，作为block的局部变量，对对象的持有在block的作用域结束时即会释放。</p><h3 id="6-NSString的内存问题"><a href="#6-NSString的内存问题" class="headerlink" title="6.NSString的内存问题"></a>6.NSString的内存问题</h3><p>iOS中NSString和NSMutableString都是抽象类，字符串的实际类型为：<strong>NSCFString、</strong>NSCFConstantString和NSTaggedPointerString，它们在内存中的存储和管理方式都各不相同：</p><ul><li><strong>__NSCFString</strong>：对象字符串，运行时创建，存储在堆中，通过引用计数管理；</li><li><strong>__NSCFConstantString</strong>：常量字符串，编译期创建，存储在常量区，无需内存管理；</li><li><strong>NSTaggedPointerString</strong>：变量字符串，运行时创建，存储在指针变量中(栈中)，系统自动管理；</li></ul><p>在创建一个字符串时，得到的字符串的实际类型遵循以下规律：</p><ol><li><strong>NSCFConstantString和NSTaggedPointerString是NSString的直接子类，</strong>NSCFString是NSMutableString的直接子类，所以创建一个可变字符串和对字符串<code>mutableCopy</code>得到的必然是__NSCFString；</li><li>字面量语法生成的NSString在编译期创建，实际类型为<strong>NSCFConstantString，再次创建相同的</strong>NSCFConstantString时不会重复创建，而是指向相同的常量字符串；</li><li><code>withFormart:</code>系列方法创建的NSString在运行时创建，实际类型为<strong>NSCFString或NSTaggedPointerString：当字符串支持<strong>Tagged Pointer</strong>优化时则创建的NSString实际类型为NSTaggedPointerString，否则为</strong>NSCFString；</li><li><code>withString:</code>系列方法和<code>copy</code>得到的NSString实际类型和原字符串实际类型一致；</li></ol><blockquote><p><strong>Tagged Pointer</strong>：由于在64位系统中一个指针的长度已经达到了8个字节，对于一些信息量较少的对象(如NSSting、NSNumber、NSDate等)，其本身需要的内存空间可能都不足8个字节，再将其创建在堆中，并用一个8个字节长度的指针去指向它，就有一些性能和内存上的浪费，针对这种情况苹果为这些类引入了各自的Tagged Pointer对象进行优化 –  用指针的前后各半个字节存储对象的标记信息，中间的7个字节存储对象的值，对象不再保存在堆中，而是直接保存在指针中。对于NSString，如果字符串可以被ASCII编码、六位编码或五位编码，并被存储在7个字节中，则运行时创建的NSString实际类型为NSTaggedPointerString，但即使是五位编码(五位表示一个字符)，7个字节中最多保存(7*8)/5 = 11个字符，所以运行时创建的NSString如果大于11个字符则必然为__NSCFString</p></blockquote><h3 id="7-内存问题调试"><a href="#7-内存问题调试" class="headerlink" title="7.内存问题调试"></a>7.内存问题调试</h3><p>可以使用Xcode自带的僵尸对象功能来调试野指针问题，使用Instruments中的Leaks来检查内存是否泄露，当出现内存泄露时可以使用三方框架FBRetainCycleDetector来检查对象的循环引用，至于相关工具如何使用，在本篇中则不做赘述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;&lt;br&gt;&lt;em&gt;Effective Objective-C 2.0&lt;/em&gt;&lt;br&gt;&lt;a href=&quot;https://blog.devtang.com/2016/07/30/ios-memory
      
    
    </summary>
    
    
      <category term="iOS基础" scheme="https://hellohezhili.com/categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
      <category term="APP工作机制" scheme="https://hellohezhili.com/categories/iOS%E5%9F%BA%E7%A1%80/APP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="内存管理" scheme="https://hellohezhili.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="内存模型" scheme="https://hellohezhili.com/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="引用计数" scheme="https://hellohezhili.com/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    
      <category term="ARC" scheme="https://hellohezhili.com/tags/ARC/"/>
    
      <category term="自动释放" scheme="https://hellohezhili.com/tags/%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法基础</title>
    <link href="https://hellohezhili.com/2017/11/17/Markdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://hellohezhili.com/2017/11/17/Markdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2017-11-16T16:00:00.000Z</published>
    <updated>2020-03-27T03:53:40.087Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Reference:</strong><br><a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">Mardown语法说明</a></p></blockquote><p><strong>Markdown的宗旨：</strong>Markdown的目标是实现易读易写。<strong>可读性无论如何都是最重要的。</strong></p><h2 id="与HTML的兼容"><a href="#与HTML的兼容" class="headerlink" title="与HTML的兼容"></a>与HTML的兼容</h2><p>Markdown对HTML兼容，Markdown之外的标签可以使用HTML撰写。<br>需要注意的是<strong>HTML区块标签</strong>需要在前后加上空行和其他内容隔开，且要求开始和结尾标签不能用制表符(tab)或空格来缩进。<br><strong>在HTML区块标签间的Markdown格式语法不会被处理</strong>，但Markdown语法在HTML区段标签间是有效的，同时<strong>HTML区段标签</strong>也可以在Markdown段落中直接使用，。</p><h3 id="amp-与-lt"><a href="#amp-与-lt" class="headerlink" title="&amp;与&lt;"></a>&amp;与&lt;</h3><p>在Markdown的HTML区段中的如果出现这两个特殊字符，Markdown在转换时会将其自动转换为HTML的实体。</p><hr><h2 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown的链接有行内式和参考式两种，行内式易写，参考式易读。</p><h4 id="行内式链接"><a href="#行内式链接" class="headerlink" title="行内式链接"></a>行内式链接</h4><p>语法为<code>中括号</code>+<code>小括号</code>，中括号中是链接文字，小括号内为链接和title（title在鼠标悬停在链接上显示的提示信息），链接可以为同一主机的相对地址，title用双引号包起来，title可有可无。</p><p>链接使用+地址定义：</p><pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.</code></pre><h4 id="参考式链接"><a href="#参考式链接" class="headerlink" title="参考式链接"></a>参考式链接</h4><p>语法为<code>中括号</code>+<code>中括号</code>，第二个中括号中为链接的标识，然后在任何位置（一般为文末或者段后）用<code>标记</code>:<code>链接地址</code>+<code>&quot;title&quot;</code>的方式将链接内容定义出来即可，链接标识不区分大小写，可以为空，为空时为隐式标识，即标识为前面中括号中的内容。</p><p>链接使用：</p><pre><code>This is [an example][id] reference-style link.</code></pre><p>地址定义：</p><pre><code>[id]: http://example.com/  &quot;Optional Title Here&quot;</code></pre><hr><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>Markdown可为段落中的文字加<em>斜体</em>、<strong>粗体</strong>和<del>删除线</del>三种方式来进行内容强调。方法是为要强调的文字前后分别加<code>*</code>、<code>**</code>和<code>~~</code>，其中<em>斜体</em>和<strong>粗体</strong>分别会为文字加上<code>&lt;em&gt;</code>和<code>&lt;strong&gt;</code>标签。</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>如果要标记一小段的行内代码，可以使用反引号<code>`</code>将其包起来，如果要在代码段中使用反引号，可以使用一个以上的反引号的开始和结束代码段:<code>代码段中有`</code>。行内代码中的<code>&amp;</code>和<code>&lt;&gt;</code>同样会被转换为对应的HTML实体。</p><hr><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>插入图片和插入连接的语法基本相同，也分为行内式和参考式，区别是插入图片需要在前面加上<code>!</code>，第一个<code>[]</code>中是图片的替代文字，并不会显示。Markdown不支持指定图片宽高，如果有需求可以使用HTML的<code>&lt;img&gt;</code>标签。</p><hr><h2 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h2><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><p>Markdown的段落由一个或多个连续的文本行组成，一个段落的前后要求各有至少一个的空白行。<br>Markdown允许段落中换行（插入换行符），并不会把换行符都转换为<code>&lt;br /&gt;</code>,连按两个空格再换行，Markdown才会将此换行符转为<code>&lt;br /&gt;</code>。</p><hr><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown的标题支持<strong>Setext</strong>（底线）和<strong>atx</strong>两种形式的标题，但一般使用<strong>atx</strong>形式，即在行首插入1~6个<code>#</code>，对应1~6阶标题。</p><hr><h3 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h3><p>Markdown使用<code>&gt;</code>标记区块引用，Markdown允许只在段落的首行添加<code>&gt;</code>标记，同时区块引用可以嵌套，添加不同数量<code>&gt;</code>即可，而且在区块内也可以使用Markdown语法。</p><blockquote><h4 id="区块（示例）"><a href="#区块（示例）" class="headerlink" title="区块（示例）"></a>区块（示例）</h4><blockquote><blockquote><p><code>三级区块</code></p></blockquote></blockquote></blockquote><hr><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ol><li>Markdown的列表可分为有序列表和无序列表。有序列表使用数字接一个英文句点作为标记，数字可以是乱序的（会自动排），但最好保持有序。无序列表使用<code>*</code>,<code>+</code>和<code>-</code>作为标记，他们的功能一样，<strong>建议</strong>在做列表嵌套时使用不同的标记来做区分。<em>第一级的列表标记一般放在最左边，但也可以缩进（最多3个空格，4个空格=一个tab，会被视为嵌套）</em>。</li></ol><ul><li><strong>注意：如果列表项目间用空行分开，在输出HTML时项目内容将会用<code>&lt;p&gt;</code>标签包起来。</strong></li><li>列表的项目下允许有多个段落，每个项目下的段落都必须缩进一个tab。</li><li><p>列表项目中可以嵌套区块引用，需要在区块前加空行，并对区块进行一个tab的缩进，如下：</p><blockquote><p>嵌套的区块 </p></blockquote></li><li><p>列表项目中还可以嵌套代码块，代码块需要前面加空行，并进行两个tab的缩进，如下：</p><pre><code>// 这就是代码printf(&quot;hello, world&quot;);</code></pre></li><li><p>列表下也可以嵌套表格</p><p>  |左对齐标题     |右对齐标题       |居中对齐标题     |<br>  |:–          |–:           |:–:           |<br>  |短文本        |中等文本        |稍微长一点的文本 |<br>  |稍微长一点的文本|短文本         |中等文本        |  </p></li><li>如果一定会在句首出现数字+句点+空白，那么可以在句点前加上反斜杠<code>\</code>。</li></ul><hr><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>和其他区块一样，表格前也需要有空白行，使用<code>|</code>来区分列，第一行为标题，第二行指明同一列的文字对齐方式<code>:--</code>表示左对齐，<code>--:</code>表示右对齐，<code>:-:</code>表示居中对齐，<code>---</code>表示默认对齐方式，即标题居中内容靠左。表示对齐的符号可以有多个<code>-</code>，但<code>-</code>和<code>:</code>加起来要不少于三个。<br>示例：</p><table><thead><tr><th style="text-align:left">左对齐标题</th><th style="text-align:right">右对齐标题</th><th style="text-align:center">居中对齐标题     </th></tr></thead><tbody><tr><td style="text-align:left">短文本</td><td style="text-align:right">中等文本</td><td style="text-align:center">稍微长一点的文本 </td></tr><tr><td style="text-align:left">稍微长一点的文本</td><td style="text-align:right">短文本</td><td style="text-align:center">中等文本        </td></tr></tbody></table><hr><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>Markdown中使用一个tab的缩进和一个段落（前后加空行）即可插入代码块，代码块会持续到没有没有缩进的那一行,也可以不使用缩进，而是在代码块的前后加上各加一行三个（或以上）反引号<code>`</code>。<br>在转换的时候，Markdown会将代码用<code>&lt;pre&gt;</code>和<code>&lt;code&gt;</code>标签包起来，在代码块中，Markdown语法不会被转换，而缩进的制表符也会被移除，同时<code>&amp;</code>、<code>&lt;</code>和<code>&gt;</code>这种HTML特殊符号也会自动转为HTML实体，例如：</p><pre><code>&lt;div class=&quot;footer&quot;&gt;    &amp;copy; 2004 Foo Corporation&lt;/div&gt;</code></pre><hr><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>可以使用三个及以上的<code>*</code>、<code>-</code>和减号来建立一个分隔线，分隔线行内不能有其它东西（<code>*</code>和<code>-</code>之间可以插入空格），例如：</p><hr><p>分隔线还有分隔出单独一段的效果，为了避免直接在文字后加<code>-</code>，而和<strong>Setext</strong>（底线）标题语法混淆，分隔线前应留一个空白行，或建议使用<code>****</code>。</p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>Markdown支持用比较简短自动链接形式来处理网址和电子邮箱，只需要用尖括号包起来即可。<br>如邮箱<a href="mailto:&#121;&#111;&#117;&#x78;&#x69;&#x61;&#110;&#103;&#64;&#113;&#x71;&#46;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#121;&#111;&#117;&#x78;&#x69;&#x61;&#110;&#103;&#64;&#113;&#x71;&#46;&#x63;&#111;&#109;</a>，网址<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a>。值得一提的是邮箱地址的字符会被Markdown转换为对应的16进制码的HTML实体，以防御一些邮箱收集机器人。</p><hr><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>Markdown中的语法符号要直接显示而不表示语义的时候，可以在符号前面加<code>\</code>来转义。<br>对应的符号有：</p><pre><code>\   反斜杠`   反引号*   星号_   底线{}  大括号[]  中括号()  小括号#   井号+   加号-   减号.   英文句点!   惊叹号</code></pre><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.appinn.com/markdown/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mardown语法说明&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="工具教程" scheme="https://hellohezhili.com/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Markdown" scheme="https://hellohezhili.com/tags/Markdown/"/>
    
  </entry>
  
</feed>
