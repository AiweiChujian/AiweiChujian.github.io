<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[七、组件化架构]]></title>
    <url>%2F2019%2F10%2F04%2FAPP%E6%9E%B6%E6%9E%84%2F%E4%B8%83%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[组件组件是软件系统中可独立部署的最小实体，组件化架构就是一套定义组件划分以及组件间相互协作方式的设计规则。 在编译后的二进制文件可进行外部链接之后，就有了组件的概念，它是将软件系统拆分后获得的部件，它比模块的划分要高一个级别，拆分时重视组件的重用性，拆分后强调组件的独立部署能力。 组件可被独立部署的特性，也意味着组件可以被独立开发，在iOS开发中，对于需要多人合作的大型APP，组件可被独立开发的特性能极大的提升整体开发效率，设计良好的组件能被跨APP的重用，这也满足了大型APP团队的实际需求，同时将单工程APP拆分成多个组件，配合组件化架构中组件间的解耦方案，也能最低程度的限制APP中代码的耦合度。 PS：基于动态链接，在组件的概念上进一步演进的插件化技术，在iOS系统中出于对安全性的考虑，一直被苹果限制使用。 组件化1. 组件构建原则在iOS APP的组件化架构中，架构都是有模式可循的，如何将APP组件化，即如何对代码进行划分以构建一个组件，才是开发实践中需要反复思考，并真正考验设计能力的问题。组件的划分需要兼顾研发性和复用性，还需要考虑组件间的依赖关系，并且具备时效性，是随项目而不断演化的，组件构建原则（出自《Clean Architecture》）能够指导组件化的决策过程。 组件聚合 复用/发布等同原则（REP）：组件复用的最小粒度应等同于其发布的最小粒度，也就是说，有一个共同的主题或者大方向的类和模块应该放到同一个组件中； 共同闭包原则（CCP）：会同时修改且因为相同目的而修改的类和模块应该放到同一个组件中，不会同时修改且不会因为相同目的而修改的类和模块应该放到不同组件中； 共同复用原则（CRP）：不要强迫一个组件的用户依赖它们不需要的东西，也就是说，不是紧密相连的类和模块不应该放在同一个组件中。 以上原则从不同角度指导了组件聚合，彼此间是相互拉扯的，构建组件时需要根据项目当前的实际情况进行综合考虑，没有最佳，只有更适合。 组件耦合 无依赖环原则（ADP）：组件依赖关系图中不应该出现环，依赖环最直接的后果便是会破坏组件的独立性，使组件独立维护、测试和发布都变得非常困难； 稳定依赖原则（SDP）：依赖关系必须要指向更稳定的方向，容易变更的组件不应该被太多的其它组件所依赖，被许多组件所赖的组件必须得是稳定的； 稳定抽象原则（SAP）：组件的抽象化程度通常和其稳定性保持一致，即抽象化程度越高的组件其稳定性通常也越高，同时还更利于扩展。 在iOS组件化架构的实践中，为组件引入一个中间件的中介者模式，是被广泛使用的架构方案，中间件打破了组件间的依赖关系，同时让组件的依赖都指向了中间件，但组件间实际的依赖逻辑依然存在，减少组件耦合的原则，在组件化设计时依然具有指导意义。 根据无依赖环原则，需要避免组件间直接或间接的循环依赖，打破循环依赖的主要手段包括：将相互依赖的部分放入一个组件中（或者为它们新建一个组件）；以及在其中一方的组件中引入抽象，实现依赖反转。结合稳定依赖原则和稳定抽象原则可以知道，一个被多方依赖的组件应该是一个稳定的组件，而通常抽象程度越高的组件就越稳定。 PS：《Clean Architecture》中提出了组件稳定性和抽象程度的量化方法，根据稳定性和抽象程度的指标可以综合分析系统中组件设计与“优秀”设计模式之间的契合度，这种衡量在某些情况中可能具有不错的参考价值。 2. iOS组件化工具在iOS8之后苹果允许APP有自己的Embedded Frameworks（详见APP的编译过程），所以iOS开发中能将源码打包成静态库或动态库的包管理工具（CocoaPods、Carthage、Swift Package Manager等），都可以作为实现iOS组件化的工具，甚至利用Xcode的Workspace与Projects，或者Project与Targets，也都能实现iOS项目的组件化，这里仅以使用最多的CocoaPods简述创建一个组件的过程。 利用CocoaPods来实现iOS项目的组件化，将拆分后的组件代码做成CocoaPods的私有库，一个组件就是一个私有库，私有库的索引推送在私有源上，在组件使用者的Podfile中指明私有源，再引入私有库，即引入了组件： 创建一个远程仓库作为私有源，通过pod repo add命令（Useage: pod repo add MYSpecs https://xxxx/myspecs.git）将私有源添加到自己的CocoaPods中； 通过pod lib create命令（Useage: pod lib create MYComponent）为组件创建CocoaPods库，再为CocoaPods库创建远程仓库，根据组件的实际情况和远程仓库地址配置CocoaPods库的podspec文件（Podspec语法参考(翻译)）； 在CocoaPods库中的组件代码编译通过之后，可对库的podspec文件进行本地验证（pod lib lint）和远程验证（pod spec lint），最后将podspec文件推送（pod repo push）到私有源上。验证和推送podspec文件时，需要cd到文件所在的目录，常用的可选参数有： –sources：如果组件库依赖了其他私有库/组件，需要通过此参数指明私有源； –use-libraries：如果组件库依赖了静态的三方库，需要添加此参数，否则会提示找不到这些库； –use-modular-headers：如果组件库的podspec中声明自己以静态库的方式被导入，而组件库依赖的某些三方库没有指明自己的moudle name，需要添加此参数； –skip-import-validation：如果组件库依赖的某些库，缺少对x86芯片指令集的支持（模拟器），需要通过此命令跳过组件库的导入验证； 在组件使用者的podfile中通过source指明私有源，再通过pod正常引入私有库，即引入了组件； podfile其实是简写的Ruby代码，在pod install和update时可以设置环境变量，然后在podfile中通过ENV[&#39;key&#39;]获取，再根据变量做if-else的条件判断，然后执行不同的逻辑，同时podfile中引入一个库时，可以为库指定地址，根据这两点，就可以让一个podfile根据不同参数而去分别引入开发/发布的组件库，一个工程既可作为开发时的壳工程，也可以作为发布时的主工程。 PS：podfile中还可以为库指定本地地址，从而让正在开发中的组件跳过lint和push的步骤，直接集成到整个项目中，进行调试，提高开发效率，podfile语法参考：Podfile语法中文参考文档。 架构模式拆分后的组件可以被独立部署（开发），但组件间可能存在复杂的依赖关系，这些依赖让拆分后项目的架构异常复杂且难以维护，组件化之后的项目需要一套架构方案，来简化组件间的依赖，同时还要有方便的组件间协作方式。iOS组件化架构由蘑菇街团队分享之后而广为流传，在蘑菇街的组件化架构方案中，通过为组件添加中间件以实现的中介者模式，来解决组件间依赖和协作的问题，在后续开发者的实践中，中介者模式也基本被认为是iOS组件化架构的最佳解决方案。 iOS组件化架构中，通常引入中间件来作为组件的中介者，组件间的协作方法都被抽象后由中间件直接响应，组件都只需要单向依赖中间件，中间件内部再将协作方法转发给具体的组件，iOS组件化架构实际上就是对中介者模式的应用。 中间件方案蘑菇街分享了自己组件化架构的中间件MGJRouter（蘑菇街 App 的组件化之路），casatwy指出其有多项不足（没必要的注册、注册后block对内存的占用、以及基于openUrl设计导致传参困难等），并分享了自己的中间件方案CTMediator，后续蘑菇街又说明MGJRouter还存在一套基于protocol-class的补充方案，casatwy继续评判… 在那场论战中蘑菇街方案的问题肯定是客观存在的，但casatwy的部分观点也有待商榷，总之通过那场论战可以知道，iOS组件化架构的中间件并没有一套业内统一认可和使用的方案，只要抓住iOS中基于中间件的组件化架构，就是对中介者模式的应用这一本质，完全可以设计或修改出适合自己项目的中间件。 AWMasterAWMaster是一套基于protocol来抽象组件间协作方法，通过消息转发的备援接收者来转发协作方法的中间件方案，它有以下特点： 不将协作方法高度抽象为中间件的一个通用方法，而是仅抽象为协议（但保留了对openUrl远程调用的支持），方便协作方法的维护、调用和传参； 保留了对协作方法的注册，通过protocol和class进行注册，注册后维护方法和class的映射关系，CTMediator也并非不需要注册，而是将注册隐藏在了强制的命名规范之中（Target_targetName），这种隐晦的方式方便使用，但不利于理解，考虑在后续大版本中再更新为此方式； 基于消息转发的备援接收者来完成协作方法的转发，方法的调用和转发都更自然，也比CTMediator中完整的消息转发（NSInvocation）性能更优； 额外提供协作方法的群发功能，满足一个协作方法需要被多个组件响应的特殊需求。 总结iOS组件化架构的关键就两点：1. 对单工程项目的组件化拆分，以及拆分后利用包管理等工具对组件进行管理；2. 根据中介者模式，为组件引入中间件，解决组件间依赖和协作的问题。熟悉架构中使用的包管理（或其它）工具、理解中介者模式并清楚架构中选用的中间件的工作方式，便能掌握项目中的组件化架构，组件化架构最终需要反复思考的问题依然是组件的设计与演进。]]></content>
      <categories>
        <category>APP架构</category>
      </categories>
      <tags>
        <tag>组件化架构</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InjectionⅢ]]></title>
    <url>%2F2019%2F03%2F24%2F%E5%AE%9E%E7%94%A8%E7%AC%94%E8%AE%B0%2Finjection%E2%85%A2%2F</url>
    <content type="text"><![CDATA[工具简介InjectionⅢ是作者John Holdsworth开源的一款iOS热重载工具，当APP在模拟器上编译运行后，使用它可以即时的执行项目中代码的改动，无需重新编译整个项目，从而极大的提高代码的调试效率。 InjectionⅢ大概的工作原理是： 在APP启动时，以加载NSBundle的形式在APP中运行一个Client端； InjectionⅢ作为Server端监视指定目录下文件的改动，当文件发生改动时将改动的文件重新编译为一个动态库； 动态库编译完成后，通过socket通信通知Client端，让APP去加载这个动态库（dlopen）； 动态库加载完成后，再通过Runtime的class_replaceMethod将原来类中的方法都替换为动态库中新类的方法； 最后再调用文件中的类及其对象的injected方法，以便在其中调用修改后的代码； 最终完成了对当前文件中代码改动的动态调试； 工具教程1.安装InjectionⅢ可以在Mac的应用商店中下载，也可以通过源码安装：clone或者下载源码，构建源码中的InjectionⅢ.xcodeproj工程即可。如果通过源码安装，卸载时删除构建源码时生成的xcode插件即可，终端命令： 1rm -rf ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/InjectionPlugin.xcplugin 2.使用首先在InjectionⅢ中通过Open Project或Add Directory添加需要监视的文件目录，并勾选File Watcher。 然后在application:DidFinishLaunching:中加载Injection的动态库： 12345678#if DEBUG // iOS [[NSBundle bundleWithPath:@"/Applications/InjectionIII.app/Contents/Resources/iOSInjection.bundle"] load]; // tvOS// [[NSBundle bundleWithPath:@"/Applications/InjectionIII.app/Contents/Resources/tvOSInjection.bundle"] load]; // macOS// [[NSBundle bundleWithPath:@"/Applications/InjectionIII.app/Contents/Resources/macOSInjection.bundle"] load];#endif 再在需要被监视改动的代码文件中添加类重载后的代码执行入口： 123456789+ (void)injected&#123; // 代码改动或调用改动的代码&#125;- (void)injected&#123; // 代码改动或调用改动的代码&#125; 最后运行工程，当控制台输出“💉 Injection connected 👍”，即表示InjectionⅢ正常运行。 APP运行中，对代码文件做出修改并通过Command+s保存后，被修改文件中的所有类的+injected及其对象的-injected方法都会被调用，在方法中直接添加调试代码或调用发生改动的代码，即可对运行中的APP进行动态调试。 3.注意在使用InjectionⅢ时需要注意以下几点： InjectionⅢ只能在模拟器中使用，目前还不能进行真机调试； InjectionⅢ动态调试时，新增的类/方法/属性/变量会生效，删除的类/方法/属性/变量仍然可以动态访问； InjectionⅢ只监视当前文件的改动，如果要动态新增类，需要在当前文件中新增； 问题记录Could not find file记录日期：2020-04-03 错误提示：如下（目标、文件名等已省略） 12345💉 *** Compiling /xxx.m ***💉 *** Re-compilation failed (... .../com.johnholdsworth.InjectionIII/Data/command.sh)fatal error: malformed or corrupted AST file: &apos;could not find file &apos;... .../Pods/BaiduMapKit/BaiduMapKit/BaiduMapAPI_Search.framework/Headers/BMKPOISearchResult.h&apos; referenced by AST file &apos;... .../PrefixHeader.pch.gch&apos;&apos;note: after modifying system headers, please delete the module cache at &apos;/... ...&apos;1 error generated. 错误原因：PrefixHeader中引用了BaiduMapKit，而BaiduMapKit中对文件的引用（包括BMKPOISearchResult.h），有两处文件名的大小写不正确，导致InjectionⅢ对变动的文件重新编译时失败。 错误分析：XCode中import文件名大小写不正确时会报“Non-portable path”的警告，在InjectionⅢ这儿即导致了重编译的失败，同时信息中也说明InjectionⅢ重编译时使用了PrefixHeader.pch等system headers的编译缓存。]]></content>
      <categories>
        <category>实用笔记</category>
      </categories>
      <tags>
        <tag>injectionⅢ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五大设计原则]]></title>
    <url>%2F2019%2F02%2F23%2F%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E5%9F%BA%E7%A1%80%2F%E4%BA%94%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[本文类容基于《Clean Architecture》 五大设计原则包括：单一职责原则（SRP)、开闭原则（OCP）、里氏替换原则（LSP）、接口隔离原则（ISP）和依赖反转原则（DIP），它们是经受过时间检验和筛选的软件设计指导思想，这种指导既适用于架构设计，也适用于程序设计，遵循设计原则，便于写出更具灵活性（易读、易扩展、易维护和易重用）的软件。 SRP: 单一职责原则单一职责原则最初的描述是：“一个软件模块（类）都应该有且仅有一个被修改的原因”，更易于理解的描述为：“任何一个软件模块（类）都应该只对某一类行为者负责”，在开发实践中，单一职责原则主要讨论的是函数和类之间的关系，即哪些函数是适合归属于一个类的。 对单一职责原则的理解主要在于 “职责” 两个字，职责不等于功能，而是和行为者（可以理解为函数的调用方）相对应，职责的划分应视具体的行为者而定。例如有一个Rectangle类，它有一组负责计算面积、周长等的函数，还有一组负责绘制展示的函数，如果它们分别被计算模块和渲染模块所使用，那么Rectangle便应该被拆分为两个不同的类，如果它计算函数的结果，最后也仅被渲染模块用于展示，那么这些函数都归一个类就是没有问题的。 OCP: 开闭原则开闭原则认为软件模块应该对扩展开发，对修改关闭，也就是一个设计良好的软件模块应该在不需要修改的前提下就可以轻易被扩展。 开闭原则是设计原则的总则，它阐明了对良好设计最本质的需求，其它设计原则都在或直接或间接的满足了开闭原则。在开发实践中，满足开闭原则最简单易行的技巧，便是多使用抽象（抽象类，接口，协议等），面向接口编程、面向协议编程都是满足开闭原则的极好实践。 LSP: 里氏替换原则里氏替换原则强调的是子类型对基类型的可替换性，在可以使用基类型的地方使用其子类型，程序的行为应该依然保持不变。 可替换性使程序可以不用添加大量复杂的应对机制，开发实践中，多态便满足里氏替换原则，多态不仅存在于继承体系的父类和子类之间，也存在于接口/协议类型和实现类型之间。 ISP: 接口隔离原则接口隔离原则指出，任何软件模块都不应该依赖它不需要的方法，否则容易带来意料之外的麻烦（因为不相干方法的变动而引发自身的重新编译/部署等），所以在设计时应保持接口的隔离。 开发实践中，按功能和需求设计小接口，大接口由小接口组合而成，将能很好的满足接口隔离原则。单一职责原则指导了如何进行类的划分，接口隔离原则指导了如何进行接口的划分，很容易被混为一谈，但实际上它们的观察角度是相反的：单一职责原则关注的是服务的提供者，强调提供者的职责应该单一，这样能减少引起自身修改的原因，而接口隔离原则关注的是服务的使用者，强调使用者应该依赖的功能要纯粹，这样能避免不相干的变更为自身带来麻烦。 DIP: 依赖反转原则依赖反转原则认为，高层次的模块不应该依赖低层次模块的实现细节，而是应该由低层次模块依赖于高层次模块的需求抽象，因为抽象层是稳定的，而具体实现是容易经常变动的。 依赖反转原则提出一种特定的解耦形式，为高层次模块添加需求抽象，使得代码的控制流方向和依赖方向发生反转。依赖反转原则能提升系统的灵活性和稳定性，但严苛的执行依赖反转原则是不可能也没有必要的，在实践中，要避免对依赖反转原则的过度设计，对于稳定可靠的底层模块（如系统和平台设施），或者本已将实现细节隐藏在稳定的抽象接口后面的底层模块，再做依赖反转就是完全没有必要的。]]></content>
      <categories>
        <category>编程通用基础</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>单一职责原则</tag>
        <tag>开闭原则</tag>
        <tag>里氏替换原则</tag>
        <tag>接口隔离原则</tag>
        <tag>依赖反转原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六、MVC-VS设计模式]]></title>
    <url>%2F2019%2F01%2F12%2FAPP%E6%9E%B6%E6%9E%84%2F%E5%85%AD%E3%80%81MVC-VS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Reference:App Architecture MVC+VC是MVC的一种变体，所不同的是它将view state视为model层的一部分，用view state model进行存储，ViewController观察view state model，并且相应地更新 view 层级。 MVC+VS中的反馈回路： MVC+VS对MVC的改进在于：提供了一种一致的处理view state变更的方法，让view state可以被持久化，同时对view state的数据管理也变成了单向数据流。 MVC+VC中view state的数据流： 除了对view state的处理变成了单向数据流，MVC+VS中对view state使用model抽象还带来了三点好处： Model通过接口和程序其余部分交流，在有需要时，对接口中的实现进行替换，并不会影响到接口和对接口的使用 Model为action提供了单一的事实来源，让重构和测试可以只关注单一的某个点 对Model的观察和响应可以被不同的action重用，所以结构的扩展性会更好 关于view state model有两点需要特别注意： 虽然view state model与文档(数据)model是同一层抽象，并遵循相同的使用规则，但还是应该保持分离，这是因为文档(数据)与view state生命周期并不相同 view state model中仅仅是存储了代表view state的简单值，并不包含对数据的变形(这部分逻辑依然写在ViewController中)，这是其和MVVM中的view-model最本质的区别 一、MVC+VS的实现1.构建与MVC和MVVM中先构建ViewController不同，MVC+VS中需要首先构建view state，然后在view state所触发的观察回调中，去构建ViewController，再由ViewController构建其他部件。但由于view state的观察者就是ViewController，因此在view state的构建之前需要至少一个ViewController，所以第一个ViewController即Root ViewController比较特殊，它在view state之前构建。 2.将View连接到数据MVC+VS从view state model和文档(数据)model中拉取数据，并订阅这些数据，然后将这些数据关联到view上去。需要注意的是MVC+VS的标准模式是，文档(数据)model对象的标识应该存储在view state model中，这就意味着对文档(数据)model的观察是依赖于view state的，对文档(数据)model的观察必须在对view state model的观察之后。 绝大多数应用场景中，ViewController的文档(数据)model的标识符在ViewController的生命周期中都不会更改，但如果有需要改变的情况，必须在view state model的观察回调里面，重新加载文档(数据)model，并重新创建创建对文档(数据)model的观察。 3.更改Model更改model的回路MVC+VS和MVC中是一样的：view将action传递给ViewController，ViewController直接更改model，同时ViewController中观察了model，当model变更时做相应的view更新。 4.更改View StateMVC+VS为view state的处理添加了一条和文档数据处理相似的路径：view将action传递到ViewController，ViewController更改view state model，同时ViewController中观察了view state model，当view state model变更时做相应的view更新。 ####状态恢复MVC+VS的架构在view state model中维护了完整的view state，将view state model序列化保存，再根据其构建ViewController和ViewController的层级，即可完成状态恢复，状态恢复时的代码路径和初始构建的代码路径是一致的。 5.测试MVC+VS和MVC中都使用集成测试，但实现上有很大的不同，第一个不同在于MVC+VS中不再需要先构建ViewController树，而是构建Root ViewController和view state model即可，包括ViewController树在内的其余部分都将作为view state的响应被自行创建出来。这样就可以通过提供view state model作为根ViewController的输入，以特定的状态构建出app的一个新的实例(状态恢复)。 MVC+VS书写测试时的另外一个不同在于研究对action的响应时，MVC中研究对action的响应，可能需要等待动画或其他异步更改的完成，MVC+VS中“对于view action的响应所造成的view state更改” 与 “view state更改引起view层级中的更新”这两段路径的测试是可以分离开的。也就是说可以直接验证view state来确保某个action确实对数据进行了合适的变更，而不需要等待action执行动画并且最终更新view，这部分路径的测试代码会变得好写很多。至于view state的变更引起view更新的这段路径，则可以为它编写单独的测试。 二、MVC+VS的优缺点MVC+VS最大的好处在于为view state变更的通讯创建了一致的机制，对view state使用观察者模式也保证了UI的同步；同时原本发生在ViewController之间的通讯，现在也可以通过view state来完成；最后，因为view state model上维护了完整的view state，所以也能很方便的完成状态日志、状态恢复、时间旅行调试等功能。 MVC+VS在实践中一个比较麻烦的问题在于并不是总能在UIKit更新view层级之前捕获到view state的变化，比如NavigationController返回按钮和返回手势所引起的层级变动，这需要我们设置NavigationController的delegate，在页面层级变动完成，而这种变动又不是由view state的变更所引起时(由返回按钮和返回手势所引起)，去对view state进行更新和处理，其他类似的情况也需要我们去添加代码支持。 三、MVC+VS架构的优秀经验1.数据的依赖注入在对象初始化的时候将数据作为参数传递进去就叫依赖注入，在MVC+VS中为ViewController设置初始的view state model时便是选用的这种方式，这样可以避免直接访问单例，更方便书写测试，同时这也比初始化时先设置为nil再等之后提供非nil的方式更加简单，这种方式也可以用于其他基于ViewController的模式中。 2.全局View State通讯但view state会被多个ViewController或view共享时，使用单例来保存view state以提供全局的view state通讯，往往比在这些ViewController或view的共同祖先中保存view state更加的简单直接，它还不需要去考虑ViewController或view层级间的通讯管道。 3.简化本地View State可以把一个简化版的MVC+VS应用到MVC的单个ViewController中：将部分view state抽象出来，用一个对象存储(字典或自定义类)，将这个对象设置为ViewController的属性，并对这个属性进行观察，在该属性变更的时候对view做这部分view state的更新，这种方式在一定程度上能缓解复杂的ViewController中view state的交互问题。]]></content>
      <categories>
        <category>APP架构</category>
      </categories>
      <tags>
        <tag>MVC+VS</tag>
        <tag>MVCS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五、MVVM设计模式]]></title>
    <url>%2F2019%2F01%2F06%2FAPP%E6%9E%B6%E6%9E%84%2F%E4%BA%94%E3%80%81MVVM%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Reference:App Architecture Model-View-ViewModel(MVVM)是一种基于MVC进行改进的模式，它将所有model相关的任务（观察model变更，将model数据变形，以及更新model）从controller层抽离出来，放到新的叫做view-model的一层对象中。引入view-model层的主要目的有两点： 鼓励将model和view之间的关系构建为一系列的变形管道。 将view应该展示的状态通过一套独立于app框架的接口进行呈现。 在MVVM中为了保持view与view-model的同步，MVVM强制使用某种形式的绑定，这通常通过响应式编程来完成。MVVM在一定程度上解决了MVC最大的两个问题，首先通过将model观察的代码以及其他显示和交互逻辑移动到围绕着数据流构建的隔离的view-model中，解决了MVC中ViewController里不规则的状态交互所带来的有关问题，在很大程度上缓解了ViewController肥大的问题；然后view-model还为场景的view state提供了一套干净的接口，让它可以独立于app框架进行测试，解决了MVC难以测试的问题。 MVVM+C中APP的反馈回路： 在MVVM+C中，协调器在APP启动完成的最后阶段创建，对于MVVM而言，协调器并非是强制需要的部件，但引入协调器来负责维护ViewController的层级，可以进一步分担ViewController的工作，让其变得更加的简单，这符合MVVM的架构思路，协调器分担的职责主要为：管理其他controller的展示，同时协调model数据和controller之间的通讯。协调器的工作方式有两种： 作为ViewController的delegate，ViewController把导航行为直接转发给协调器。 把导航行为先转发给view-model，然后让协调器去观察view-model，以获取导航事件。 第一种更加简单直接，但如果导航事件是依赖于当前view的状态或者model数据的话，第二种做法将更加合理，同时第二种做法也更利于代码测试。 一、MVVM的实现1.构建MVVM构建的方式和MVC很相似：ViewController充分了解程序的结构，并且对其它所有部件进行构建和连接。此外，相比起MVC主要有三点不同： 必须创建view-model。 必须建立起view-model和view之间的绑定。 Model由view-model拥有，而不是由controller所拥有。 view-model的创建有三种方式：在ViewController创建时创建默认值、作为参数传递给ViewController的依赖注入和在ViewController加载后延迟创建。 2.将View连接到数据在MVVM+C中，将View连接到数据的数据管道： 协调器为每个ViewController的view-model设置初始的model对象。 view-model将设定值和其他model数据及观察量进行合并。 view-model将数据变形为view所需要的形式。 ViewController使用响应式编程框架来将准备好的值绑定到各个view上去。 3.更改ModelMVVM-C中，View Action的事件回路和在MVC中各层之间的路径相似，不同在于，在ViewController和model之间插入了一层额外的用于协调的view-model： view通过target/action机制、delegate、或者响应式编程框架扩展，将View Action传递给ViewController； ViewController接收到View Action时调用view-model的相应接口； view-model的接口中直接更改model； view-model观察model的变更，并在变形后通过可观察值暴露给ViewController； ViewController中已经将可观察值和view进行了绑定，将会在这些值变化时更新view。 4.更改View State同MVC一样，部分view state依然隐式存储在view中，但原本那些由ViewController通过属性所保存的view state，在MVVM-C中由view-model显式地进行表示。view-model只负责那些会被view行为影响的view state，对于既不依赖于任何的view-model属性，也不是view-model所依赖的view state，并不需要通过view-model管理。 更改view state的事件回路和更改model的事件回路近似，只是少了view-model更改model，并观察model的变更且变形为可观察值的步骤： view通过target/action机制、delegate、或者响应式编程框架扩展，将View Action传递给ViewController； ViewController接收到View Action时调用view-model的相应接口； view-model的接口中直接更改自己存储的view state可观察值； ViewController中已经将可观察值和view进行了绑定，将会在这些值变化时更新view。 对于影响ViewController层级的view state变更，MVVM+C中根据协调器的工作方式不同，可以由ViewController通过delegate直接将事件传递给协调器处理，也可以将事件处理为view-model的可观察值，协调器订阅这些课观察者，当消息触发时，做相应的视图层级管理。 5.测试MVVM通过引入view-model层，提供了清晰且独立于app框架的接口，所以对于view-model及以下层次的代码，使用接口测试将非常方便，而对ViewController及View中的代码逻辑的测试则依赖于Xcode的UI测试或人工测试。MVC使用的集成测试，更偏向于功能而不是代码，虽然代码覆盖率比接口测试更高，但却难以编写和维护；相比而言，MVVM的接口测试由于只需要关注自己编写的view-model和接口，而且很少需要异步测试，其编写和维护都要方便得多。 接口测试的经典模式是：构建输入，再构建用来传递输入的接口，然后从接口中读取结果。MVVM中在配置测试环境和数据后，需要做的测试工作主要包括展示测试和行为测试： 展示测试：对view-model上所暴露的每一个可观察量，对初始值进行测试然后执行操作，并测试后续的条件。 行为测试：测试初始条件，执行操作，然后测试接下来的条件。 二、MVVM的优缺点MVVM的优点主要是低耦合和方便测试，此外的利于分工合作和方便代码迁移和复用，都是低耦合的延伸。MVVM也有一些自身的缺点，它们主要体现在： 更多的代码：因为引入view-model层，最直观的感受就是类变得更多，在处理简单的场景时代码量增多，但在处理相对复杂的状态交互时，MVVM更加清晰的逻辑，反而会让编码工作变得更加简单。 更难以调试的BUG：MVVM一般选用响应式编程来做数据绑定，这会使得一处的BUG被快速的传递到别的地方，当你在某处发现问题时，定位它是因为数据变形管道上的哪一步出了BUG，将会更加的不容易。 不利于重用的view：有的MVVM中对于view采用双向绑定，不仅将model的数据绑定到view上，还将view的action和model进行绑定，这将降低view的可重用性，应避免对view使用双向绑定，而是应该将view的action通过通用的方式传递给ViewController，再由ViewController调用view-model的接口做相应处理。 基于响应式编程：MVVM中通常都会使用响应式编程来做数据绑定，这比其它方案更加方便简洁，响应式编程的学习曲线稍加陡峭，但理解响应式编程对编码工作者绝对大有裨益。 三、MVVM与响应式编程响应式编程是一种用来描述数据源和数据消费端之间数据流动的模式，响应式编程将这种流动描述为一个变形管道。MVVM并非必须使用响应式编程，但观察model数据并将其变形为view-model上的一系列可观察值，再在ViewController中将这些可观察值绑定到view上，对于这条路径，在MVVM中通常是推荐使用响应式编程来完成，也可以使用基于KVO等技术的其他方案，但那需要做更多的额外工作，而且使用起来也没有响应式编程这种对口的方案方便。 四、MVVM架构的优秀经验1.引入额外的层MVVM在MVC基础上引入view-model这额外的一层抽象来构建数据管道，将抽象的数据(model中的)变形为特定的数据(view里的)，这种模式也可以在程序中的其他部分使用，例如： App-model：构建一个App-model，将用户凭证、系统服务信息(如网络是否可用)等数据合并、变形，然后作为可观察值提供给其他view-model使用，这种model也可以称之为setting-model。 Session-model：用于追踪当前登录会话的细节，可能需要在view-model和主 model之间，或者view-model和其他接口之间，进行网络请求的处理。 数据流-model：model版本的协调器，用来将导航状态作为数据进行建模，并将导航状态和model数据合并，直接为view-model提供可观察的model数据。 Use case：Use case指的是那些用来对主model进行切片准备，并且用来简化所要执行操作的任意类型的接口或者model。Use case和view-model很像，但是它并不被绑定在一个单独的ViewController上，而是可以在view-model之间进行传递或者共享，从而在多个view-model中提供可重用的功能。当一个app有多个view显示同样的底层数据时，我们可以使用共通的Use case对象来对从model获取数据和将数据写回model的操作进行简化。 2.引入协调器协调器是独立于MVVM的模式，它也可以用于其他APP架构中，通过引入协调器可以减轻ViewController的职责，让ViewController无需知道其他ViewController的信息，同时也让页面层级管理的逻辑集中在了一起，方便代码的维护。 3.分离数据变形MVVM中通过view-model将数据变形的逻辑从ViewController中抽离了出来，这种分离让ViewController变得更加整洁，让数据变形的代码更加清晰，同时也更易于测试。如果有需要，即使不是在MVVM中，也可以通过添加辅助对象来同样的对数据变形逻辑进行分离，特别是数据变形牵涉到比较多的数据和逻辑的时候。]]></content>
      <categories>
        <category>APP架构</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八、视图的显示原理]]></title>
    <url>%2F2018%2F12%2F25%2FAPP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F%E5%85%AB%E3%80%81%E8%A7%86%E5%9B%BE%E7%9A%84%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Reference:绘制像素到屏幕上iOS 保持界面流畅的技巧iOS界面渲染流程分析iOS开发-视图渲染与性能优化 显示逻辑iOS的APP运行起来后，主线程的RunLoop可以被用户交互、定时任务、GPU通知等所唤醒，唤醒后处理事件，完成对视图的更改；在RunLoop再次休眠前，根据所做的更改，由CPU完成视图约束更新、布局和绘制；再通过OpenGL ES（或Metal）生成纹理，提交给GPU；GPU对纹理进行合成渲染，将渲染结果提交到帧缓存区；最后屏幕根据自己的刷新率，定期获取帧缓存区中的数据进行显示。 垂直同步屏幕都有一个固定的刷新率，屏幕会按照这个频率去将GPU帧缓存区（FrameBuffer）中的内容重新显示，目前iOS设备屏幕的刷新率都是60Hz（59.97Hz）。 在一帧画面的显示过程中，如果帧缓存区的数据发生了替换，屏幕就会显示“撕裂”画面（一部分上一帧画面，一部分下一帧画面），GPU通过垂直同步机制（V-Sync）来解决这个问题：屏幕在完成一帧画面的显示后会发出一个VSync（垂直同步信号），VSync的产生频率和屏幕的刷新率一致，GPU收到VSync后再替换帧缓存区中的数据。 GPU渲染一帧数据需要时间，如果在收到VSync之后才开始渲染需要立即显示的画面，显然就会有延时，所以便需要双缓冲机制：屏幕显示FrameBuffer中的内容时，GPU便开始向BackBuffer中准备下一帧的数据，当屏幕显示完成，GPU收到VSync后，下一帧已经渲染完成，GPU直接修改指针，完成FrameBuffer和BackBuffer的替换，并继续为BackBuffer准备新一帧的数据。 iOS设备都使用双缓存，并开启垂直同步，iOS的GPU在收到VSync后，会通过IPC通信唤醒APP主线程的RunLoop，在APP中CPU完成计算，然后在主线程RunLoop再次休眠前，将显示内容提交给GPU渲染，GPU最后再将渲染结果提交到帧缓存区供屏幕显示。 CPU处理参与模块APP运行期间，CPU负责管理视图层，并在显示时，为其生成GPU所需的纹理。CPU处理过程中，参与模块之间的架构如图： 在iOS中，OpenGL ES将逐步被新的渲染引擎Metal所替换，Metal针对iOS设备做了高度优化，详情可参见Metal。 CALayer与UIView在CoreAnimation中，一个CALayer表示一个视图，管理着显示相关的信息，CALayer上的属性并不是用实例变量存储的，而是都保存在一个内部字典中；UIView是UIKit对CALayer的装饰，在显示之外主要是添加了支持用户交互相关的功能，UIView背后都有一个CALayer，UIView显示相关的属性和方法（比如 frame/bounds/transform等），都是对背后CALayer属性和方法的映射，通常通过UIView上更加便利的高级API来操作视图，在实现特殊显示需求时，则需要跨过UIView去操作其背后的CALayer。 处理流程在每一轮视图更新周期中，iOS系统内CPU处理的工作可分为以下五步： Handle Events: 处理各种事件，完成视图的更改，记录需要更新的视图； Layout: 根据所做的变更，完成视图层的约束更新与布局； Display: 完成视图绘制（drawRect）和文本的绘制； Prepare: 解码图片，将压缩的图片格式转为位图； Commit: 根据视图层和内容内容生成纹理，提交给GPU合成渲染； APP通过主线程的RunLoop来Handle Events（四、事件处理机制（RunLoop）），在更改视图的布局和显示内容时，系统不会立即更新视图，而是在RunLoop再次休眠前，集中对需要更新的视图更新约束和布局（七、UIView的布局与刷新），再将视图的显示内容处理成位图，最终与根据视图生成的纹理一起，打包提交给GPU合成渲染。 内容处理在生成纹理时，视图的布局、颜色等基础信息可直接转换到纹理中，显示内容则需要由CPU处理成位图，再转换为CALayer的contents，最后生成位图纹理提交给GPU，需要处理的内容有三类：图形绘制、图像解码和文本绘制，同样的纹理在GPU中可以被复用，CPU只需要告知新的位置即可，所以如果显示内容没有变更，那么它们通常只在第一次显示时需要处理。 图形绘制iOS中图形绘制通过CoreGraphics或者UIKit中的绘图API来完成，它们的底层都是基于Quartz 2D的，图形绘制时，内容需要写入到一个上下文中（CGContext），可以通过CGBitmapContextCreate创建位图上下文，UIKit中维护着一个上下文栈，使用UIKit的绘图API时（如UIBezierPath等），绘制内容会被写入最顶层的上下文，可以通过UIGraphicsGetCurrentContext来获取最顶层的上下文，还提供了UIGraphicsPushContext和UIGraphicsPopContext来控制这个上下文栈，UIGraphicsBeginImageContextWithOptions函数则会创建一个位图上下文，并将其压入UIKit的上下文栈顶，需要注意的是，CoreGraphics创建的上下文是以左下角为原点，UIKit自动创建的上下文则以左上角为原点。 自定义UIView的子类如果实现了-drawRect:方法，在绘制时，CoreAnimation会为视图的CALayer申请一个后备存储（CABackingStore），再为后备存储创建绘图上下文，UIKit会将其压入自己的上下文栈顶，-drawRect:中便是对UIKit的栈顶上下文进行绘制，完成绘制后，上下文中的数据会被保存到后备存储中，后备存储则被设置为视图CALayer的contents。 图像解码图像通常以JPEG或PNG的压缩格式保存在文件中，在根据图像文件生成UIImage，并赋给UIImageView显示时，系统完成了图像的加载，但要在第一次显示的纹理提交前（Prepare阶段）才对图像进行解码，得到位图数据，生成一个CGImage，作为UIImageView的CALayer的contents，系统对图像的加载和解码都在主线程中进行。 JPEG是一种有损压缩，PNG是无损压缩，JPEG的解码比PNG复杂得多，在APP编译打包时，Xcode会对PNG进行优化，优化后的PNG可以被iOS读取，并且解压的速度更快。 文本绘制文本在绘制前需要排版（TextLayout），UIKit中文本显示视图（UILabel和UITextView）的文本排版和绘制都在主线程中完成，其中TextLayout的计算开销较大，详情推荐阅读深入理解Autolayout与列表性能，绘制则是由CoreText和CoreGraphics合作生成一张位图，与图形绘制相似，绘制好的位图数据被存放在一个后备存储（CABackingStore）中，作为文本显示视图的CALayer的contents。 GPU渲染Tile-Based渲染移动端GPU都使用了Tile-Based渲染技术，Full-Screen和Tile-Based在渲染时都会将屏幕分成多个Tile进行处理，但移动端中GPU对渲染缓存的访问开销更大，Tile-Based将顶点处理和像素处理分开进行，在一帧的顶点处理完成后，再一次性访问渲染缓存，按Tile顺序进行像素处理，减少了渲染时GPU对帧缓存区的操作次数，提升了性能的同时也减少了耗电。 Tile-Based的渲染流程： Command Buffer: 接收渲染引擎（OpenGL ES或Metal）传递的渲染指令； Tiler: 调用顶点着色器，进行顶点处理，将顶点数据分块（Tiling）； Parameter Buffer: 接收顶点处理的结果和相应的渲染参数； Renderer: 调用像素着色器（又叫片元着色器），进行像素处理； Render Buffer: 缓存渲染完毕的数据； 视图渲染需要将纹理合成显示，屏幕上每一个像素的颜色都需要进行混合计算，当源纹理是完全不透明的，目标像素的颜色就等于源纹理上的颜色，使用不透明的图层和没有alpha通道的位图，可以有效的减轻GPU渲染合成时的运算压力。 渲染等待在Tile-Based的渲染中，每一帧的顶点处理和像素处理相对独立，再加上CPU处理，iOS会将它们安排在相邻的三帧中，一帧的渲染命令提交后，会在之后的第三帧显示。 离屏渲染离屏渲染（Offscreen Rendering）是将内容渲染到一个屏幕渲染缓存之外的缓存区，离屏渲染在普通渲染之后进行，再与前面的渲染结果合并（Compositing），离屏渲染的结果可以被复用，离屏缓存区的大小大概是屏幕缓存区的两倍。离屏渲染可以避免内容的重复渲染，但会触发多次的环境切换，开销本身就不小，开启离屏渲染是否会提示整体的渲染速度，需要根据具体的情况进行权衡。 离屏渲染可以手动强制开启，也可以在一些视图设置后，由CoreAnimation自动开启。通过设置shouldRasterize将CALayer光栅化，可以强制对视图离屏渲染，光栅化是指将几何数据转换为像素数据，开启光栅化的CALayer会作为位图，并由离屏渲染进行处理。CALayer的Shadow（阴影）和Mask（遮罩）将自动触发离屏渲染，Mask实际上是一个拥有alpha值的位图，每个CALayer都可以有一个关联的Mask，有的视图的圆角便是通过Mask实现的，更多设置视图自动触发离屏渲染的实例可以参考文章iOS 阴影，圆角，避免离屏渲染。 画面丢帧由于垂直同步机制，CPU或者GPU如果未在两个VSync之间（16.67ms）完成内容的提交，那一帧就会被丢弃，屏幕继续显示之前的内容，画面显示发生丢帧。FPS是屏幕每秒显示的帧数，iOS在显示动画时，理想值是60FPS，为了不让用户感觉到明显的卡顿，FPS应保证不低于30，可以借助CADiplayLink对FPS进行监控（参考YYText/YYFpsLabel），当因为丢帧产生画面卡顿时，基于iOS视图的显示原理，可行的优化思路如下： Handle Events: 不要在主线程中执行耗时过长的代码，尽量避免在一个周期中多次调整视图的frame/bounds/center等属性； Layout: 减少视图的层级，使用清晰的约束，缓存布局和TextLayout的结果等； Display: 自定义视图实现文本和绘图的异步绘制； Prepare: 用解码效率更高的PNG替换JPEG，提前异步完成图片的解码； Commit: 避免引入不必要的视图和视图层级； 普通渲染: 尽量使用不透明图层和不含alpha通道的图片，以减轻渲染时的合成计算； 离屏渲染: 动态列表中应避免触发离屏渲染，静态内容是否使用离屏渲染需要权衡； 在优化视图显示速度，提升动画流畅度方面，iOS中一些成熟的第三方方案，可以作为直接的工具或重要的参考： Panda: 官方Autolayout的替代方案，优化了对Cassowary算法的使用，对布局和TextLayout进行缓存，支持异步绘制等，可以优化视图的约束跟新与布局阶段； YYText: 自定义的文本显示相关视图，异步绘制文本，并缓存文本排版和绘制的结果，可以优化视图的文本绘制阶段； AsyncDisplayKit: fackbook开源的异步显示框架，充分利用CPU的并行计算能力，延迟创建和更新视图，异步进行布局和绘制的计算，提前对部分图层合并绘制等，对视图显示各阶段均有优化，框架比较重量级，引入Flexbox布局，有一定的门槛，本身也建议仅在确实需要优化的页面使用。]]></content>
      <categories>
        <category>APP工作原理</category>
      </categories>
      <tags>
        <tag>渲染</tag>
        <tag>视图刷新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四、MVC设计模式]]></title>
    <url>%2F2018%2F12%2F22%2FAPP%E6%9E%B6%E6%9E%84%2F%E5%9B%9B%E3%80%81MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Reference:App Architecture MVC基于经典的面向对象原则:对象在内部对它们的行为和状态进行管理，并通过类和协议的接口进行通讯。MVC中view对象通常是自包含且可重用的；model对象独立于表现形式之外，且避免依赖程序的其他部分；controller层负责将model层和view层撮合到一起工作，controller对另外两层进行构建和配置，并对model对象和view对象之间的双向通讯进行协调。 MVC中APP的反馈回路： iOS中标准的MVC是三种不同的子模式的集合: 组合模式：view被组装成为层级，该层级按组区分，由controller对象进行管理 策略模式：controller对象负责协调view和model，并且对可重用的、独立于app的view在app中的行为进行管理 观察者模式：依赖于model数据的对象必须订阅和接收更新 在所有模式中，MVC通常都是代码量最少，设计开销最小的模式。MVC模式有两个主要的缺陷，其一是view controller拥有太多的职责，所导致的“massive view controller”；同时MVC也难以测试，特别是单元测试和接口测试非常困难，而比较可行的集成测试的编写也并非易事。 一、MVC的实现1.构建Cocoa MVC程序的创建过程会完成对三个对象的创建：UIApplication对象，Application delegate，以及主窗口的根ViewController。这三个对象的默认配置文件分别为：Info.plist，AppDelegate和Main.storyboard。同时它们又提供了对后续启动流程进行配置的地方，这三个对象都属于Controller层级，所以说Controller层负责了所有的构建工作。 MVC app中的View不直接引用model对象，View将保持独立可重用，model对象将被存储在ViewController中，ViewController将变成了个不可重用的类，model对象赋予了ViewController对应的身份。 2.将View连接到数据在MVC中Controller根据初始的model对View进行配置，并观察model，在model的变更通知到到达时做相应的View变更。 在ViewController上设置一个初始model值时，有三种不同的方式: 通过判定controller在controller层级上的位置以及controller的类型，直接访问一个全局的model对象 开始时将model对象的引用设置为nil并让所有东西保持为空白状态，直到另一个controller提供了一个非nil值 在controller初始化时将model对象当作参数传递进来(也就是依赖注入) 在构建阶段结束后，对于view层级的变更应该遵循MVC中观察者模式的部分，只发生在观察的回调中。 观察者模式是在MVC中维持model和view分离的关键。这种方式的优点在于，不论变更究竟是源自哪里(比如，view事件、后台任务或者网络)，我们都可以确信UI是和model数据同步的。而且，在遇到变更请求时，model将有机会拒绝或者修改这个请求，即使model被以其他方式(比如一个网络事件)改变，或者是model拒绝这次变更时，UI也会正确更新。这是一种确保view层始终与model层同步的十分健壮的方式。 3.更改ModelView Action的事件回路： view通过target/action机制和delegate等方式将View Action传递给ViewController； ViewController接收到变更model的View Action时直接更改model； ViewController通过观察者模式响应model变更并更新view。 4.更改ViewStateMVC的model层起源于典型的基于文档的app：任何在保存操作中写入文档的状态都被当作是model的一部分来考虑。其他的任意状态（包括像是导航状态，临时的搜索和排序值，异步任务的反馈以及未提交的更改）传统意义上是被排除在MVC的model定义之外的，我们把这些状态统称为view state。在MVC中，这些被我们统称为view state的“其他”状态没有被包含在模式的描述中。 依照传统的面向对象的原则，任意的对象都可以拥有内部状态，这些对象也不需要将内部状态的变化传达给程序的其余部分。基于这种内部处理，view state不需要遵守任何一条程序中的清晰路径。任意view或者controller都可以包含状态，这些状态由View Action进行更新。view state的处理尽可能地在本地进行:一个view或者ViewController可以独自响应用户事件，对自身的view state进行更新。 如果想要在view层级的不同部分共享view state，有两种方式： 找到它们共同的祖先，并在那儿管理状态 使用单例来管理状态 实际操作中，将view state放到层级的顶层controller对象中的做法（即第一种方式）并不常⻅，因为这会要求层级的每一层之间存在通讯的管道。 5.测试自动测试可以由好几种不同形式进行。从最小的粒度到最大的粒度，它们包括: 单元测试：将独立的函数独立出来，并测试它们的行为 接口测试：使用接口输入并测试接口输出得到的结果，输入和输出通常都是函数 集成测试：在整体上测试程序或者程序的主要部分 单元测试只花了十多年的时间就成为了app中最常⻅的测试方式。不过即使是现在，许多app除了人工测试以外并没有进行常规的自动测试。如果想要在代码层级对MVC的controller和model层进行自动测试，可行的选项是写集成测试，但想要正确书写集成测试，需要大量关于Cocoa框架是如何操作的知识，这并非易事。在MVC中，我们需要从window开始构建ViewController树和view树，在树构建出来后便可以选择以新创建出来的树作为单个集成测试单元进行测试：书写代码触发事件，然后与我们的预期进行验证。 二、MVC的问题观察者模式失效第一个问题是，model和view的同步可能失效。当围绕model的观察者模式没有被完美执行时，这个问题就会发生。常⻅的错误是，在构建view时读取了model的值，而没有对后续的通知进行订阅。另一个常⻅错误是在变更model的同时去更改view层级。解决方法只有严格地遵守观察者模式：当读取model值时，也需要对它进行订阅。 肥大的ViewControllerViewController需要负责处理view层(设置view属性，展示view等)，但是它同时也负责controller层的任务(观察model以及更新view)，最后，它还要负责model层(获取数据，对其变形或者处理)。结合它在架构中的中心⻆色，这使得我们很容易在不经意间把所有的职责都赋予ViewController，从而迅速让程序变得难以管理。 关于肥大的ViewController最主要的争论不是关于代码的行数，而在于所保存的状态的数量。当整个文件就像ViewController这样是一个单独的类的时候，所有的可变状态都将被文件中的各个部分共享，每个函数需要精诚合作，来共同读取和维护这些状态，避免彼此矛盾，这无疑是会让代码的可读性和可维护性都越来越差。 三、MVC的改进观察者模式最好是有一种方式，能让对View的初始设定和在viewDidLoad中对model建立观察者之间没有时间空隙。使用键值观察(KVO)来替代通知是可选项之一，但是，在大部分情况下这通常需要同时观察多个不同的键路径，这让KVO和通知的方式相比，实际上并没有更加稳定。在Swift中KVO由于需要每个被观察的属性都声明为dynamic，这也让它在Swift中远远没有在Objective-C中那样流行。 对观察者模式最简单的改进方式是，将NotificationCenter进行封装并为它实现KVO所包含的初始化的概念。这个概念会在观察被建立的同时发送一个初始值，这允许我们将设定初始值和观察后续值的操作合并到一个单一管道中去。另外一种可行的思考是，将观察者模式替换为在MVVM中比较常用的响应式编程，这样可以借助一些响应式编程框架，将对初始值的设定与后续观察都合并在一次订阅操作中，同时也保证了model与view的同步，例如在ReactiveCocoa中，对KVO的封装也让这类代码的书写非常地方便。 肥大ViewController的问题ViewController主要的工作为：观察model，展示view，为它们提供数据，以及接收View Action。造成肥大ViewController的原因就是ViewController通常还负责了主要工作之外的无关工作，这些额外的工作有的应该被分散到较小层级的Controller中，这些Controller各自管理一个较小部分的view；有的则可以通过接口和抽象将其封装起来，作为工具类使用；还有的功能则是应该移动到model层中，比如排序、数据获取和处理等方法，它们与app的数据和专用逻辑相关，把它们放在model中会是更好的选择。 所以解决肥大ViewController的主要思路有： 使用较小层级的Controller通过将主要的view的逻辑分散到它们自己的更小的controller中，简化场景的view依赖，在父ViewController中剩下的工作就只有集成和布局了 将部分任务封装成工具类可以创建工具类来执行像是获取用户位置信息这种异步任务，这样，在controller中需要的代码就只是创建任务和回调闭包 将数据相关的逻辑放在model中例如排序、数据获取和处理等方法，包括数据网络层的获取与处理，交由model管理将更加的合理 属于各个部件的逻辑应当尽可能地集成到各自的部件中去，将部分ViewController中的代码抽离出来，在本质上并没有降低整个程序的复杂度，但是这么做确实降低了ViewController本身的复杂度。 降低ViewController的复杂度的其他手段还包括： 使用代码而不是segue如果不使用segue，而是选择用代码来定义view层级，能在构建阶段有更多的控制力，其中最大的优点在于，可以更好地掌控依赖，这样可以让页面跳转时对ViewController的配置更加的方便可控。 在扩展中进行代码重用在不同的ViewController间共享代码，最常⻅的方法是创建一个包含共通功能的父类，另一种选择是使用扩展(类别)。相较于继承，这种重用代码的方式，在降低ViewController复杂度的同时，并没有提高继承链的复杂度。 利用ChildViewController进行代码重用ChildViewController是在ViewController之间共享代码的另一种选项，它符合使用较小层级Controller的思路，是降低ViewController复杂度同时提高代码重用的有效方式。 提取协调controller许多大的ViewController都有很多⻆色和职责，除了一些具体的任务可以抽离成工具类之外，其他的一些职责事务也可以通过对象提取出来，对这些提取出来的事务对象做泛型抽象后，还能在其他有相似事务的ViewController中重用 苹果将controller的主要职责分为协调controller(coordinating controller)和调解controller(mediating controller)。一个协调controller是app特定的，而且一般来说是无法重用的(即ViewController的主要工作部分)。调解controller则是一个可重用的controller对象，通过配置，它可以被用来执行特定的任务。通常，用来遵守某个协议的代码(比如ViewController中遵守UITableViewDataSource的部分)，比较适合被提取为调解controller，再将提取出来的对象进行泛型抽象，让部分差异化逻辑通过block等方式从外面传递进来，这个提取出来的对象，便能用于有相似调解controller逻辑的ViewController中。需要注意的是，分离controller的逻辑能降低ViewController的复杂度，但是当两个部件紧密耦合在一起，并且需要对很多状态进行通讯和共享的时候，分离后所带来的开销可能会非常大，反而使得事情变得更加复杂，这时不分离反而是更好的选择。 简化View配置代码如果ViewController需要构建和更新非常多的view，那么将这部分view配置的代码提取出来，对于降低ViewController的复杂度也非常有效，特别是对于那些不需要双向通讯的配置]]></content>
      <categories>
        <category>APP架构</category>
      </categories>
      <tags>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七、UIView的布局与刷新]]></title>
    <url>%2F2018%2F12%2F18%2FAPP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F%E4%B8%83%E3%80%81UIView%E7%9A%84%E5%B8%83%E5%B1%80%E4%B8%8E%E5%88%B7%E6%96%B0%2F</url>
    <content type="text"><![CDATA[Reference:先进的自动布局工具箱深入理解 Autolayout 与列表性能 Update CycleUIKit/QuartzCore为主线程的RunLoop添加了Observer，监听kCFRunLoopBeforeWaiting（休眠前）和kCFRunLoopExit（退出）事件，在事件的回调函数中会对视图的更新约束、布局和绘制任务进行处理，再汇总处理后的结果，提交给GPU渲染，每一轮的处理就是视图的一个更新周期（update cycle）。 使用了Autolayout的视图，一个更新周期可分为三个步骤：更新约束 (UpdateConstraints) 、布局（LayoutSubviews）和绘制（DrawRect）。这三步依次进行，每一步都依赖前一步的操作，但并不是单向的，比如在布局的过程中更改了自身的约束，就会再次触发更新约束，并再次布局，所以需要注意避免陷入无限循环的逻辑。 视图层级中未使用Autolayout时，可理解为视图的更新周期中没有更新约束的步骤。 UpdateConstraints当视图的约束发生了变化，或者手动调用-setNeedsUpdateConstraints将视图标记为需要更新约束之后，视图会被添加到全局容器中，然后在下一个更新周期中更新约束： 视图的约束更新方法是-updateConstraints，更新约束时会自下而上（从subview到superview）的调用约束更新方法； ViewController根视图的约束更新方法调用后会调用ViewController的-updateViewConstraints方法； -updateConstraints和-updateViewConstraints中对视图约束的更新会在本次更新周期中被计算。 Autolayout在视图更新约束完成之后，系统会将约束条件转换为一个线性规划问题，再基于Cassowary算法进行求解，然后根据计算结果对视图布局，这个过程就是Autolayout。Autolayout的深入分析可以参见文章：深入理解 Autolayout 与列表性能，了解以下几点有助于理解Autolayout： 系统中负责Autolaout求解的类是NSISEnginer，一个window上的view复用同一个NSISEnginer对象，这种情况能发挥出Cassowary算法增量更新机制的优势； Autolayout增加了约束的更新和求解，自然会带来性能的影响，在iOS12之后，Autolayout完成了优化，性能的消耗已经和手写布局（frame）一样随视图嵌套而呈线性增长，可以放心使用； Autolayout的计算和布局都在主线程中完成，并且增加了Text layout时的计算工作，相比而言，Text layout对性能的影响更大； Autolayout在计算完成后并不操作视图的frame，-setFrame:方法不会被执行，Autolayout是将计算结果作用于视图的Alignment Rect； 更多Autolayout的使用技巧参见：先进的自动布局工具箱 LayoutSubviews与视图更新约束相似，当视图的层级、center、bounds等布局内容发生了变化，或者手动调用-setNeedsLayout为视图做了标记之后，视图会被添加到全局容器中，在下一个更新周期中进行布局： 视图的布局方法是-layoutSubviews，布局过程会自上而下（从superview到subview）调用布局方法； ViewController根视图的布局方法调用前后会分别调用-viewWillLayoutSubviews和-viewDidLayoutSubviews； LayoutSubviews系列方法中对视图布局的设置都会在本次更新周期中被使用； -layoutSubviews使用时需要调用super的实现； -layoutSubviews中如果改变了约束，会引起约束更新和布局的迭代，注意不要产生无限循环的情况。 DrawRect当视图的绘制内容发生了变化（例如改变了背景色），或者手动调用-setNeedsDisplay/-setNeedsDisplayInRect:方法标记视图需要重绘之后，视图会被添加到全局容器中，在下一个更新周期中重绘： 视图的绘制方法是-drawRect:，绘制方法的调用与superview或subview无关； -setNeedsDisplayInRect:是标记视图局部需要重绘，rect参数会在重绘时传入绘制方法中； 将View的contentMode设置为UIViewContentModeRedraw之后，视图frame的变化也会引起视图的重绘； LayoutIfNeeded视图的约束和布局发生变化或手动标记之后，会在下一个更新周期被集中处理，这个过程被叫做Deferred Layout Pass。在开发中有时需要在本轮的Deferred Layout Pass之前知道约束和布局更新的结果，系统提供了-layoutIfNeeded方法来立刻刷新视图的约束与布局： -layoutIfNeeded是同步操作，方法执行完成即可通过视图获得刷新后的布局； 视图约束与布局发生变化或手动标记之后，调用-layoutIfNeeded才会刷新； 未添加到window上的视图，调用-layoutIfNeeded方法时，需要新建NSISEnginer进行计算，性能比添加到window后，通过共用的NSISEnginer计算是差； 系统还提供了-systemLayoutSizeFittingSize方法来立刻获取视图刷新后的布局，它计算时总会新建NSISEnginer，但做了计算优化，且计算完成后不会操作视图的frame； 已添加到window上的视图，在需要时优先使用-layoutIfNeeded，未添加到window上的视图，如果仅仅是为了获取布局计算的结果，优先使用-systemLayoutSizeFittingSize。]]></content>
      <categories>
        <category>APP工作原理</category>
      </categories>
      <tags>
        <tag>autolayout</tag>
        <tag>layoutsubviews</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三、网络层的架构设计]]></title>
    <url>%2F2018%2F12%2F16%2FAPP%E6%9E%B6%E6%9E%84%2F%E4%B8%89%E3%80%81%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Reference:App Architecture 添加网络的挑战为程序添加网络支持时，会面临一些额外的挑战，这不是某个架构所特有的问题，也和本节中对于网络层如何架构的讨论无关，但是对于一款需要从网络中获取数据的APP，或多或少都需要清楚对于这些问题的思考： 额外的失败来源：任何从网络获取数据的尝试，都可能由于一系列的理由以失败而告终。我们必须考虑如何优雅地处理这些错误，而且经常还要为展示这些错误创建额外的UI。 获取最新数据副本：持续从网络监听数据要比观察本地数据困难得多，这往往导致我们需要周期性地手动获取数据。 多端间的数据冲突：网络引入了多端更新同一个数据的可能性，这可能导致潜在的冲突。网络上的数据可能会有独立于app的更改、引用的资源可能会在不通知客户端的情况下直接失效、两个客户端有可能更新了同样的对象。 对于两个客户端更新了同样的对象，这必须让服务器从两者间选择出哪一个应该胜出，并且告诉每一个客户端冲突的解决方案，可以参考iCloud关于解决文档冲突的方式和相关思考。 添加网络层的方式为APP添加网络层有两种常见的方式： Controller层持有网络：将model层移除，并让controller来处理网络请求。数据直接从网络获取，从网络获得的数据不会被持久化，而是由controller负责将它们以处理view state相同的方式缓存在内存中。这种方式非常的简单直接，主要问题在于不同的controller之间进行数据共享变得非常麻烦。 Model层持有网络：保留model层，并在model的下方加入了一个网络层。model负责触发和管理网络请求，并按照需要，用请求的结果来更新model，model的变更依然通过观察者模式传递给controller。在这种方式中，封装的网络服务可以提供接口直接由model层调用，也可以观察model的变更然后进行数据同步的网络活动，后者model层和网络层之间的耦合更低；因为保留了model层，利于不同controller间数据共享的同时，也可以很方便的做离线缓存。 Controller层持有网络1.获取初始数据controller发起网络请求，并且在数据返回时对view进行配置，controller只维护前一次请求所获取的数据的内存缓存。因为网络获取数据是一种延时操作，所以需要添加数据获取过程处于不同的状态、已经状态变更的额外逻辑。 2.更改数据数据的更改现在也是一个通过网络执行的异步任务，view action传递到controller中，controller发起数据变更的网络请求，并且在数据返回时更新view。 3.思考&amp;讨论Controller层持有网络将大量的新的职责放到了controller中，包括发起网络请求，处理结果，以及处理网络失败等，这可以通过将这些代码封装为网络服务来减少controller中的代码。不过在这种方式还存在其他弊端：controller负责进行网络请求并持有数据，实际上数据的逻辑已经等同于view state，如果app中没有其他部分依赖这些数据，这种方式也可以良好工作，但如果数据需要在不同controller中进行使用，缺少model层让数据共享变得更加麻烦，而且即使当前不需要共享，也需要考虑到未来可能会有变更，所以从一开始就选择对未来友好的方式可能会更加明智。 Model层持有网络1.加载初始数据创建model对象，调用model的数据加载方法，在model的方法中，去触发相应的网络请求，根据请求的结果，model更新自己，而controller则观察model的变更并更新相应的view即可。 2.更改数据controller与model进行交互，就好像model只是本地数据一样，网络则发生在model层的背后。但对于model如何触发网络请求，则有两种不同的可选方式： model直接发起网络请求：在model数据变更的相应接口中，直接发起网络请求，同步数据的变更。 网络服务观察model的变更：封装的网络服务观察model，model在数据变更时触发某种通知，网络服务在接收到信号时，再发起相应的网络请求。 第二种方式让model层和网络层进一步的解耦，同时因为封装了相应的网络服务，可以使用一个更改队列来对这一类网络请求做统一管理，并对待处理更改队列进行持久化，这样即使APP离线时(断网、退出、崩溃)本地更改也不会丢失。 3.讨论&amp;思考model持有网络为代码增加了一些复杂度，但也具有更多的能力：保留了model，让controller之间的数据共享更加方便，同时也很容易做数据的离线缓存；通过添加网络服务部件来管理数据同步的网络请求，可以在APP中立即更新数据，而不用等服务器的响应，但同时也需要增加额外的代码，来追踪未提交的变更，并对变更提交时可能发生的冲突进行处理。Model层持有网络是对APP未来变更和扩展更加友好的方式，是更加推荐的网络层架构模式。]]></content>
      <categories>
        <category>APP架构</category>
      </categories>
      <tags>
        <tag>APP网络层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、APP架构的设计模式]]></title>
    <url>%2F2018%2F12%2F12%2FAPP%E6%9E%B6%E6%9E%84%2F%E4%BA%8C%E3%80%81APP%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Reference:App Architecture iOS开发官方钦定的设计模式是MVC，而MVC及其两种变形：MVVM+C和MVC+VS，是学习iOS APP架构最需要掌握的三种设计模式，实践源码可以参考链接。这三种设计模式都是基于场景进行的架构，它们其实都是观察者模式、策略模式和组合模式三种设计子模式的集合。 MVCS：在有的地方会提到一种称为MVCS的架构，它在Model层与Controller层之间加入了一个Service层，在iOS中一般又特指负责Model数据同步、缓存、持久化等服务的Store层，它所分离的逻辑在MVC中可以属于Model层，也可以属于Controller层。但在App Architecture一书中并没有将MVCS列为一种单独的架构，同时MVCS中的S层除了可能减轻了Controller的职责也未见其它裨益，而减轻Controller的职责通过封装服务类也能办到，事实上App Architecture一书中在阐述MVC架构的Demo中就用一个全局的服务Store负责了所谓MVCS架构中S层的工作，可见MVCS中为每个场景都分离一个S层的做法也确实没那么必要，其本质上和MVC架构也没多少区别。 MVCMVC源于Smalltalk中所发展出的分离展示部分的理念，也就是view层和model层应该被完全隔离开，这带来了一个强烈的需求，那就是要引入一个支持对象来辅助两者之间的通讯，这个支持对象在MVC中就是Controller。MVC中Controller对象负责处理model层和view层范畴之外的所有任务。Controller层接收所有的view action，处理所有的交互逻辑；发送所有的model action，接收所有的model通知，对所有用来展示的数据进行准备，最后再将它们应用到View的变更上去。构建和导航任务也由Controller负责。 1.构建Model和View：MVC中View和Model的构建都由Controller负责，App对象负责创建最顶层的view controller，这个view controller将加载view，并且要么显式地创建和持有model层，要么通过一个延迟创建的model单例来获取model。 2.变更ViewMVC中，Controller需要观察model，在收到model变更的通知时去变更View。当一个更改model的View action发生时，为了保证单向数据流原则，Controller应避免去直接操作View层级，标准的做法是：View action转变为model变更，然后model发送通知，Controller订阅model通知，并且在当通知到达时再更改View层级。 3.更改ModelMVC中，Controller主要通过target/action机制和delegate来接收view事件。Controller知道自己所连接的view，而view在编译期间并不知道Controller接口的信息。当一个View事件到达时，Controller有能力改变自身的内部状态，更改model，或者直接改变View层级。 4.View StateMVC中View State可以按需要被储存在View或者Controller的属性中，MVC中那些只影响View或Controller状态的action通常也不需要通过model进行传递，而页面层级或导航状态也由Controller进行维护。 5.测试MVC中View Controller与app的其他部件紧密相连，这导致层级间缺乏清晰的边界，单元测试和接口测试都十分困难，集成测试是MVC最可行的测试手段。 MVVM+CMVVM+C就是MVVM加Coordinator(协调器)。MVVM在每个场景中使用View-model来描述场景中的表现逻辑和交互逻辑，使用Coordinator来管理View controller层级。View-model在编译期间不包含对view或者controller的引用，它暴露出一系列属性来描述每个view在显示时应有的值。将这些值设置到View上的工作，通常由预先建立的绑定来完成(响应式编程)，绑定会保证当这些显示值发生变化时，把它设定到对应的View上去。Coordinator(协调器)是在场景间切换时负责提供逻辑的对象。协调器持有对model层的引用，并且了解View controller树的结构。MVVM-C中的View controller通过delegate的机制将Viewcontroller的信息告诉协调器，协调器据此显示新的Viewcontroller并设置它们的 model数据。MVVM+C中view controller不再拥有内部的View state，这些状态也被移动到了View-model中，view controller 仅仅只是View层级的一部分。 1.构建Model：在MVVM中model的创建和MVC中相同，通常由一个顶层controller负责。不过model对象属于view-model，而不再属于view controller。View：view层级的创建也和MVC中一样，通过storyboard或者代码来完成。和MVC不同的是，view controller不再直接为每个view获取和准备数据，而是由view-model负责。View-Model：View controller在创建的时候会一并创建view-model，并且将每个view绑定到view-model所暴露出的相应属性上去。 2.变更View在MVVM中，和MVC不同，view controller不监听model。View-model将负责观察model，并将model的通知转变为Viewcontroller可以理解的形式。View controller订阅view-model的变更(响应式编程)，当一个view-model事件来到时，再由Viewcontroller去更改View层级。 3.更改Model在MVVM中，view controller接收View事件的方式和MVC中一样(target/Action和delegate)。不过，当一个View事件到达时，view controller不会去改变自身的内部状态、view state、或者是model，而是调用view-model上的方法，再由view-model改变内部状态或者model。 4.View State在MVVM中，View state要么存在于View自身之中，要么存在于view-model里。和MVC不同，view controller中不存在任何View state。View-model中的View state的变更，会被controller观察到，不过controller无法区分model的通知和View state变更的通知。在MVVM+C中，Viewcontroller层级将由协调器进行管理。 5.测试在MVVM中，因为view-model的引入，View层与controller层是解耦合的，所以可以使用接口测试来测试view-model，而不需要像MVC里那样使用集成测试，接口测试要比集成测试简单得多。 MVC+VSMVC+VS是为标准的MVC带来单向数据流方式的一种尝试，通过MVC+VS能加深编程人员对view state和单向数据流的理解。在MVC+VS中，我们明确地在一个新的model对象中，对所有的view state进行定义和表达，我们把这个对象叫做view state model。我们不从 view 中去读取view state，而是从view state model中去获取它们。MVC+VS也具有独到的优点，例如：任意的状态恢复，完整的用户界面日志，以及极为强大的调试能力(通过设置不同的view state)。 1.构建在MVC+VS中和MVC一样，model和view的构建工作依然由view controller负责，但MVC+VS中view controller还需要使用和订阅view state。 2.变更View在MVC+VS中Controller同时对文档model和view state model进行观察，并且只在变更发生的时候更新view层级(单向数据流原则)。 3.更改Model当view action发生时，view controller去变更文档model(这和MVC相同)或者变更model state。MVC+VS中不会去直接改变view层级，所有的view变更都要通过文档model和view state model的通知来进行。 4.View StateView State被明确地从view controller中提取出来,由view state model维护，处理的方法和model一样：controller观察view state model，并且对应地更改view层级。 5.测试在MVC+VS中，使用和MVC里类似的集成测试，但是测试本身会非常不同：所有的测试都从一个空的根view controller开始，然后通过设定文档model和view state model，这个根view controller可以构建出整个view层级和view controller层级。一旦view层级被构建，我们可以编写两种测试。第一种测试负责检查view层级是不是按照我们的期望被建立起来，第二种测试检查view action有没有正确地改变view state。]]></content>
      <categories>
        <category>APP架构</category>
      </categories>
      <tags>
        <tag>MVCS</tag>
        <tag>MVC</tag>
        <tag>MVVM</tag>
        <tag>MVC-VS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、APP架构概论]]></title>
    <url>%2F2018%2F12%2F08%2FAPP%E6%9E%B6%E6%9E%84%2F%E4%B8%80%E3%80%81APP%E6%9E%B6%E6%9E%84%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[Reference:App Architecture 1. 软件架构和APP设计模式软件架构是软件设计中的分支，它关注两个方面： 如何将软件分解成不同的接口和概念层次部件； 这些部件自身和部件之间的不同操作中所使用的控制流和数据流路径。 一个好的APP架构依赖于一套有力的设计规则来定义部件的划分以及部件之间的相互协作方式，在架构中一套被重复使用的设计规则称为设计模式。 app的设计模式基本就是一套分层规则，app中不同的部件会被归纳到某个类型中去，将这些不同的种类叫做层次：一个层次指的是，遵循一些基本规则并负责特定功能的接口和其他代码的集合。 2. Model和ViewModel和View是APP架构中最常见也是最基础的两个分层。 Model：Model层是APP的内容，它不依赖于任何APP框架，程序员对Model层有完全的控制。它通常包括model对象和协调对象。 View：View层几乎是完全依赖于APP框架的部分，它使Model层可见，并允许用户进行交互，从而将Model层转变为一个APP。 在APP中，View对象通常会构成一个单一的view层级，view controller也通常会形成 view controller层级。model对象却不需要有明确的层级关系，在程序中它们可以是互不关联的独立 model。 model层的最重要的意义在于：它为我们的程序提供一个表述事实的单一来源，让程序的行为有清晰的规则可以依据，这会让编程逻辑清晰、行为正确。如果 model 层能做到和应用框架分离，我们就可以完全在 app 的范围之外使用它。 3. 反馈回路用户界面是一个同时负责展示和输入功能的反馈设备，APP的逻辑就是一个反馈回路。用户发起的事件会导致view的响应，我们把由此引起的代码路径称为view action，当一view action被送到model层时，它会被转变为model action，将view action转变为model action的操作,以及路径上的其他逻辑被叫做交互逻辑。一个或者多个model对象上状态的改变叫做model变更。Model的变更通常会触发一个model通知，当view依赖于model数据时，通知会触发一个view变更，将model通知和数据转变为view 更改的操作，以及路径上的其他逻辑被叫做表现逻辑。 4. 单向数据流有些状态可能是在文档model之外进行维护的，例如导航状态。在app中非文档model的状态被叫做view state。在Cocoa里，大部分view对象都管理着它们自己的view state，controller对象则管理剩余的view state。当所有的状态都在model层中被维护，而且所有的变更都通过完整的反馈回路路径进行传递时，我们就将它称为单向数据流。即：任意的view对象或者中间层对象只能够通过 model发出的通知来进行创建和更新(换句话说view或者中间层不能通过捷径来更新自身或者其他的view)时，这个模式通常就是单向的。在遵循单向数据流的模式中，就实现了model与应用框架的解耦。 5. APP的任务一个程序的正常工作方式为：view必须依赖于model数据来生成和存在，我们配置view，让它可以对model进行更改，并且能在model得到更新时也得到更新。所以我们需要决定APP中如何执行下列任务： 构建：谁构建model和view，以及将两者连接起来？ 变更view：如何将model数据的变化应用到view上去？ 更新model：如何处理view action？ 处理view state：如何处理导航及其他model state以外的状态？ 测试：为达到一定程度的测试覆盖，采取怎样的测试策略？ 我们研究APP设计模式，就是研究一个设计模式如何处理以上五个APP任务。]]></content>
      <categories>
        <category>APP架构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS开发中好用的三方轮子]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C%2FiOS%E4%B8%89%E6%96%B9%E8%BD%AE%E5%AD%90%E5%88%86%E7%B1%BB-OC%2F</url>
    <content type="text"><![CDATA[收录的库以Objective C为主，Swift三方库参见[]； 以⚠️标记表示作者已多年(3年及以上)未更新；* 以🚫标记表示作者已声明不再维护升级。 1.用户界面层(User Interface)视图控件对于更新不够频繁或自定义接口不够丰富的视图控件，最好直接使用其源码，而不是通过Cocoapods导入 MJRefresh：下拉刷新，上拉加载 MBProgressHUD：好用易扩展的活动指示器 SVProgressHUD：轻量级的活动指示器 TWMessageBarManager：轻量的通知和警告提示库⚠️ TSMessages：轻量的通知和警告提示库 JDStatusBarNotification：顶部状态栏提醒 UIActivityIndicator-for-SDWebImage：为网络图片加载添加活动指示 PYSearch：一种使用样式较广的搜索页面 YYText：富文本 DTCoreText：富文本，可解析Html和CSS TTTAttributedLabel：富文本label M80AttributedLabel：富文本label SDCycleScrollView：轮播图 FSCalendar：日历插件 PGDatePicker：时间/日期选择器 DZNEmptyDataSet：无数据时的展示视图 SGPagingView：标签指示器 iCarousel：卡片的旋转切换 ZJPickerView：各列会联动的选择器 LMReport：常见报表表格样式 PPBadgeView：为各种视图添加badge WZLBadge:为视图添加badge WMPageController：分页视图控制器 FlatUIKit：扁平化风格的UIKit⚠️ JSQMessagesViewController：聊天消息类框架🚫 JVFloatLabeledTextField：带浮动标签的文本输入框 SWTableViewCell：支持左滑和右滑的tableViewCell⚠️ MGSwipeTableCell：支持左滑和右滑的tableViewCell tapkulibrary：自定义控件库，包括HUD、进度条、日历、CoverFlow等 MWPhotoBrowser：简单的照片浏览控件⚠️ ZZCircleProgress：可定制的环形进度条 BFNavigationBarDrawer：NavigationBar下的tool菜单 SXFiveScoreShow：五项素质评分所组成的五角星 UUChatTableView：IM聊天界面的封装 HyPopMenuView：类似微博效果的弹出菜单 DXPopover：带小箭头的弹出视图 DOPDropDownMenu：下拉菜单 ActionSheetPicker-3.0：底部弹窗选择器 MultilevelMenu：多级选择器，Swift实现 层级管理 CWLateralSlide：侧边抽屉效果的视图容器 ViewDeck：侧边抽屉效果的视图容器 ECSlidingViewController：双层子视图容器实现侧滑效果 MMDrawerController：轻量的侧边抽屉效果的视图容器⚠️ RDVTabBarController：三方封装的tabBarController 页面布局 Masonry：Autolayout代码布局库 PureLayout：Autolayout代码布局库 UITableView+FDTemplateLayoutCell：tableVeiwCell高度的自动布局 动画特效 GPUImage：图片添加滤镜⚠️ Shimmer：为视图添加流光效果 FXBlurView：添加毛玻璃效果🚫 NYXImagesKit：常规的图片处理 AwesomeMenu：弹射动画展开的菜单 Canvas：无需编码就能添加动画效果的库⚠️ JazzHands：在scrollview中绘制关键帧动画⚠️ pop：pop动画引擎 popping：基于pop引擎的动画库 pop-handapp：基于pop引擎的动画实例 VCTransitionsLibrary：转场动画库⚠️ UI层优化 FDFullscreenPopGesture：简化返回手势的管理 KMNavigationBarTransition：优化转场时的导航栏样式 ZYCornerRadius：避免离屏渲染的圆角设置 FastImageCache：本地图片的快速加载与渲染 Texture：通过异步绘制来提升性能的UI框架 nui：用类CSS的语法来简化UI样式的设置⚠️ LEETheme：简化APP主题的管理 2.业务逻辑层(Bussiness Logic)APP任务 IQKeyboardManager：键盘事务管理 AYCheckVersion：更新检查 iVersion：更新检查🚫 Appirater：去AppStore评分 CocoaLumberjack：App的日志管理库 NSLogger：带mac客户端的日志分析工具 功能组件 TZImagePickerController：图片选择器 ZFPlayer：视频播放器及控制器 PNChart：图表绘制库(OC) Charts：图标绘制库(Swift) WebViewJavascriptBridge：OC和JS的交互库 AGEmojiKeyboard：emoji表情输入面板 ZFSetting：快捷构建设置界面 TOCropViewController：图片裁剪 EZAudio：音频波形图绘制⚠️ 便捷工具 ReactiveObjC：函数响应式编程框架 KVOController：方便安全的KVO工具 PromiseKit：Promise设计模式处理异步任务的库 JKCategories：系统库的类扩展 Colours：颜色库扩展 FormatterKit：为很多数据类型提供了格式化的转换 nimbus：开源的iOS开发框架 BlocksKit：为一些常用的系统接口提供block版本 Bolts-ObjC：GCD、NSOperation之外的多任务管理库 RegexKitLite：通过正则表达式处理字符串⚠️ Objective-C-RegEx-Categories：提供便捷的正则表达式使用接口⚠️ 3.数据访问层(Data Access)网络传输 AFNetworking：网络请求库 XMNetworking：基于AF的封装，使用方便，适合中小型项目 YTKNetwork：基于AF的封装，功能完备，适合复杂网络请求项目 MKNetworkKit：轻量的网络请求库 Reachability：判断网络可达性 RestKit：专注于RESTful API的网络请求、JSON解析、CoreData存储的框架 SDWebImage：根据网络连接获取图片 SocketRocket：facebook家的轻量级socket连接库⚠️ CocoaAsyncSocket：异步socket通讯 SocketRocket：webSocket客户端 XMPPFramework：XMPP通信框架 转换处理 GZIP：数据压缩与解压 MJExtension：JSON字典和模型相互转换 Mantle：JSON字典和模型的转换 json framework：JSON数据解析 JSONModel：JSON字典和模型的转换 hpple：XML/HTML解析 本地持久化 YYCache：NSCoding归档缓存 Realm：移动端本地数据库 MagicalRecord：对CoreData的封装 FMDB：对SQLite数据库的封装 KeychainItemWrapper：keychain钥匙串管理⚠️ SAMKeychain：keychain钥匙串管理 GVUserDefaults：对NSUserDefaults的方便存取 4.测试调试(Test &amp; Debug)调试类三方库在Cocoapods导入时需设置其编译环境仅包含Debug，即需要在三方库的引入后面加上:configurations =&gt; [&#39;Debug&#39;]；测试类三方库要注意仅加到测试target下。 FLEX：强大的调试工具集 YKWoodpecker：优酷（阿里）开源的调试工具集 MLeaksFinder：VC和VC上的View的内存泄漏检查工具 FBRetainCycleDetector：对象的循环引用检查工具 JxbDebugTool：网络请求调试工具⚠️ NetworkEye：Http网络请求调试工具 PonyDebugger：通过Chrome调试网络流量和数据存储 KIF：基于XCTest的UI测试框架 Kiwi：BDD行为驱动开发测试框架]]></content>
      <categories>
        <category>实战经验</category>
      </categories>
      <tags>
        <tag>三方库合集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Appledoc]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%AE%9E%E7%94%A8%E7%AC%94%E8%AE%B0%2FAppledoc%2F</url>
    <content type="text"><![CDATA[工具简介Appledoc是一款开源工具，使用它可以根据指定路径下代码文件中的注释，为项目生成Apple风格的API文档。 工具教程1.安装appledoc可以通过Homebrew安装，终端执行命令brew install appledoc即可，不过这种方式不会一并安装文档模板（template），所以更推荐通过appledoc项目的源文件来安装： 12345678# 1. clone appledoc文件git clone git://github.com/tomaz/appledoc.git# 2. 进入appledoc目录cd ./appledoc# 3. 运行appledoc安装脚本sudo sh install-appledoc.sh 2.使用代码注释appledoc支持导出Markdown语法书写的注释，同时也支持导出Xcode通过Command + Option + /为方法添加的标准注释，附Xcode标准注释的关键字： 12345678910/** @brief 方法简要描述 @param 方法参数说明 @exception 方法会抛出异常 @see 参看相关的 Method/Function/枚举 @discussion 方法详细说明 @warning 警告 @bug BUG @return 返回值 */ 导出文档appledoc的命令格式为appledoc [OPTIONS] &lt;paths to source dirs or files&gt;，常用的appledoc命令如下： 1appledoc -i *.m --keep-undocumented-objects --keep-undocumented-members -h --no-publish-docset --no-create-docset --no-install-docset -c "公司名称" -p "项目名称" -o "输出地址" "源文件目录" 命令的最后是需要导出文档的源文件目录，中间是命令参数，appledoc所支持的更多命令参数可通过appledoc --help进行查看。 命令成功执行后通常是在指定的输出地址下生成一个名为docset-installed.txt的文件（示例命令是直接在输出地址中生成html文档），里面记录了导出的文档的地址，导出的文档一般在~/Library/Developer/Shared/Documentation/DocSets/目录下，文档为.doset格式，可通过右键-显示包内容查看其内容。 Aggregate可以通过为项目添加Aggregate Target，再为Aggregate添加Run Script，最后再编译Aggregate的方式来方便快速的为项目生成API文档。 添加Aggregate：Xcode中依次File -&gt; New -&gt; Target... -&gt; Aggretgate进行添加； 添加Run Script：在添加的Aggregate的Build Phases中添加Run Script； Run Script示例: 12345678910111213141516171819company=&quot;组织名称&quot;; companyID=&quot;组织ID&quot;;outputPath=&quot;$&#123;PROJECT_DIR&#125;&quot;;filePath=&quot;$&#123;PROJECT_DIR&#125;&quot;appledoc \-i *.m \--keep-undocumented-objects \--keep-undocumented-members \-h \--no-publish-docset \--no-create-docset \--no-install-docset \--company-id &quot;$&#123;companyID&#125;&quot; \-c &quot;$&#123;company&#125;&quot; \-p &quot;$&#123;PROJECT_NAME&#125;&quot; \-o &quot;$&#123;outputPath&#125;&quot; \--exit-threshold 2 \&quot;$&#123;filePath&#125;&quot; 3.注意使用appledoc的注意事项： appledoc不会导出//注释的内容，需要导出的单行注释可以使用///； Xcode9.3之后不再支持集成自定义文档，使用appledoc集成文档时会报Error，但不影响文档的导出，详见Issue；]]></content>
      <categories>
        <category>实用笔记</category>
      </categories>
      <tags>
        <tag>appledoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四、内存管理]]></title>
    <url>%2F2018%2F07%2F14%2FiOS%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%2F%E5%9B%9B%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Reference:Effective Objective-C 2.0理解 iOS 的内存管理内存管理基础Objective-C 中的内存分配iOS中的block是如何持有对象的 程序都是加载到内存中运行，了解APP工作机制，第一步先了解APP是如何使用内存的。 简述程序加载到内存中运行时，在内存中分静态数据(只读)和动态数据(读写)两部分，其中动态部分中堆的分配与释放由程序做内存管理，iOS中使用引用计数机制配合自动释放池来做内存管理，又使用ARC来简化引用计数和自动释放的编程： 引用计数：对于堆中的对象，想要保留时使其引用计数+1，想要释放时使其引用计数-1，当对象的引用计数为0时，系统会销毁对象回收内存； ARC技术：依赖编译器的静态分析，在编译时为对象插入保留、释放、自动释放等引用计数管理代码，并在运行时对引用计数管理代码做优化; 自动释放：自动释放标记使对象引用计数延迟-1，即自动释放池销毁时，对象在此自动释放池管理范围内被标记了几次，就会做几次引用计数-1； 概览 要点 内存中静态数据不会发生变化，栈则由系统自动管理，编程中内存管理是对堆的分配和回收； iOS中使用引用计数来管理内存，又使用ARC来简化引用计数的编程； 自动释放池满足了对象归当前调用者所有，但又需要延迟释放的引用计数管理需求； ARC中指向对象的指针都需表明自己对对象的所有权，普通指针通过所有权修饰符指明，属性的成员变量则通过属性修饰符指明； 推荐用__autoreleasing来修饰结果参的形参，这样可以减少ARC的开销； 现在的ARC中虽然不再需要使用@autoreleasepool { }来消除大量的局部对象所造成的内存峰值，但依然可以保留这种写法以兼容较老的版本； CoreFoundation中的对象不由ARC管理，当和ARC管理的OC对象互相转换时，需视情况指明对象所有权是否发生变化； ARC中需要注意对象间相互引用、performSelector相关接口和异常捕获时可能出现的内存泄露； block分为全局block、栈block和堆block，MRC中需要持有一个block时，使用它的copy总是没错，ARC中可以将block直接赋值给变量，因为ARC会视情况自动copy； ARC中block会保留其捕获的环境局部变量对对象的引用，所以可能造成循环引用，可以使用弱引用指针来避免循环引用，还可以结合临时强引用指针来避免block执行期间对象被释放； NSString和NSMutableString都是抽象类，iOS中字符串的实际类型为NSCFString、NSCFConstantString和NSTaggedPointerString，它们在内存中的生命周期和管理方式各不相同； 当出现内存问题时，Xcode自带的僵尸对象可以调试野指针问题，Instruments中的Leaks可以检查内存泄露问题，三方框架FBRetainCycleDetector可以检查对象的循环引用问题； 详情1.内存模型程序在内存中运行时分静态数据和动态数据：静态数据只读，存储在代码段(.text)和数据段(.data + .bbs)，中这部分数据占用的内存在运行时不会发生变化，在程序终止后被清理；动态数据可读写，存储在栈(stack)和堆(heap)中，这部分数据占用的内存会随着程序运行而动态变化，其中栈的使用由系统管理，而堆的的使用则需要程序进行管理。 栈由高位向低位增长，是因程序中函数运行而临时占用的内存，由系统的入栈和出栈操作来自动管理。堆由低位向高位增长，需要由程序自行管理，编程中的内存管理即是指对堆的分配与回收，运行中不再使用的内存却未回收便是内存泄露，还在使用的内存却被回收了便是野指针问题。 栈的内存变化：每一个函数的调用就会向栈中压入一个函数的帧，函数帧中包括函数的形参、局部变量和返回地址等信息，有多少层函数调用就会压多少个帧，当函数执行结束时其函数帧就会出栈，并回到函数的返回地址继续执行，随着函数执行时函数帧的入栈与出栈，程序对栈的占用也随之发生变化。 2.引用计数iOS中使用引用计数来做内存管理，对象的创建方法为其在堆中分配内存，并将引用计数初始为1，对象创建后想要保留时使其引用计数+1，想要释放时使其引用计数-1，当对象的引用计数为0时，系统会销毁对象回收内存。 引用计数手动管理方法： retain release autorelease 引用计数初始为1的创建方法： alloc new copy mutableCopy 通过以上方法创建的对象归调用者所有，需要调用者在使用后将其引用计数-1 3.ARC技术ARC编程时指向对象的引用(指针)都需要表明对对象的所有权，普通指针通过所有权修饰符指明(如果没有显示声明所有权修饰符，则缺省为__strong)，属性的成员变量则通过属性修饰符指明，编译时则依据指针对对象的所有权添加引用计数管理代码(引用计数管理的相关C函数，而非MRC中的OC方法)，运行时对于引用计数管理代码又做了适当的优化。ARC既简化了引用计数管理代码的编程，又优化了引用计数管理代码的执行，Objective-C和Objective-C++的对象都可以依赖ARC进行内存管理，CoreFoundation中的对象则需要手动管理引用计数。 ARC中的所有权修饰符ARC中有以下4种所有权修饰符： __strong：强引用，默认的修饰符，使引用计数+1，对应属性修饰符中的strong、copy和retain； __weak：弱引用，不会引起引用计数变化，对象释放后会自动指向nil，对应属性修饰符中的weak； __unsafe_unretained：不安全的弱引用，不会引起引用计数变化，对象释放后不会自动指向nil，容易造成野指针，但比__weak性能更好，对应属性修饰符中的assign和unsafe_unretained; __autoreleasing：自动释放引用，会使引用计数+1，并在自动释放池释放时延迟-1，常用于申明结果参的形参。 NSNotificationCenter对Observer的引用在iOS9之前是unsafe_unretained的，需要在对象dealloc前removeObserver，否则容易出现野指针问题，iOS9之后对Observer的引用改为了weak，在对象dealloc时没有removeObserver也不再有野指针的问题。 ARC与CoreFoundationCoreFoundation中的对象不由ARC管理，依然需要手动管理引用计数，ARC中CF对象和OC对象进行相互转换时，需要通过关键字指明转换后对象所有权的变化： __bridge：用于CF和OC对象的相互转换，不发生所有权的变化，引用计数不变。CF对象转OC对象，则对象依然需要在CF中手动管理引用计数；OC对象转CF对象，则对象由ARC管理，CF中可以不对其做手动的引用计数管理。 __bridge_retained：等效于CFBridgingRetain，用于OC对象转CF对象，CF保留一次对象的所有权，引用计数+1。相当于转换完成后再调用了一次CFRetain。 __bridge_transfer：等效于CFBridgingRelease，用于CF对象转OC对象，CF释放一次对象的所有权，引用计数-1。相当于转换完成后再调用了一次CFRelease。 ARC中的内存泄露ARC为程序自动添加了引用计数管理代码，但如果编程过程中不注意，依然可能出现内存泄露的情况： 循环引用造成的内存泄露：A直接或间接的保留了B，B又直接或间接的保留了A，就会出现循环引用，这在block的使用中尤其容易出现，循环引用的对象在互相等对方释放自己，最终是都不会释放，造成内存泄露。ARC可以使用弱引用来避免循环引用的出现，也可以在出现循环引用后手动解除引用环。 performSelector相关API造成的内存泄露：当派发的选择子不明确的时候，ARC中编译器不知道是否应该为返回的对象添加释放的代码，所以ARC选择不添加释放代码的保守做法，这样当选择子是new、alloc、copy和mutableCopy这些应当由调用者释放返回对象的方法时，就会造成内存泄露。可以添加额外的判断，当选择子是需要调用者释放返回对象的方法时，将返回对象转为CoreFoundation对象，再用__bridge_transfer转回OC对象，使其引用计数-1来避免内存泄露。 异常捕获代码造成的内存泄露：异常捕获代码@try{ } @catch{ } @finally{ }的@try{ }中出现异常时会跳过后面的代码，进入@catch{ }中继续执行，如果@try{ }中创建并持有了临时对像，那么即使ARC为其添加了释放代码，也不会被执行，如此便会造成内存泄露。解决的办法是避免在@try{ }中使用new、alloc、copy和mutableCopy等方法来创建并持有对象，或者为文件添加-fobjc-arc-exceptions标识让ARC生成额外的代码来做处理(影响运行期性能)，更推荐的做法其实是避免使用异常捕获代码。 在OC的编程中并推荐编写异常安全代码(异常捕获)，因为OC的语言设计中认为只有严重到需要程序终止的错误才应该抛出异常，那么既然抛出异常时程序应该终止，也就无需捕获异常书写异常安全代码。对于可被接受或进一步处理的错误，OC中推荐通过返回nil/0或使用NSError来传递错误信息，并在接收到错误信息后做相应处理。 4.自动释放有时不想再保留对象但又不想对象被马上释放时，比如函数中生成的对象作为函数的返回值，可以使用autorelease来标记对象，让对象在其所在的自动释放池drain时自动释放，达到延迟释放的效果。 autorelease与__autoreleaseMRC和ARC中分别用autorelease和__autorelease为对象做自动释放标记，在一个自动释放池管理范围内对象被标记了几次自动释放，自动释放池drain时就会为其做几次引用计数-1。 ARC中通常用来__autorelease声明结果参(二级指针形参)的实参，关于这种使用场景需要清楚的有： 强引用的局域对象在出了作用域时引用计数-1，__autoreleasing指向的局域对象，会延迟释放，即离开作用域引用计数也不会-1，而是在当前自动释放池释放时才引用计数-1； 强引用形参会使引用计数+1，但是是函数作用域的局域对象，出了函数作用域引用计数-1，__autoreleasing修饰的形参不会使引用计数+1，出了函数作用域也不会-1； 当形参是结果参时(二级指针)如果传入的实参未做autoreleasing修饰，为结果参赋值时，ARC会添加一个autoreleasing的指针指向所赋的结果，使结果参返回后延迟释放；如果实参已经有__autoreleasing修饰，则在为结果参赋值时ARC不会添加额外的代码。 autoreleasePool关于自动释放池需要清楚的有以下几点： 每个线程通过自己的自动释放池栈维护着线程中添加的自动释放池，对象被标记为自动释放时会添加到栈顶的自动释放池中； 每个线程都会为其自动释放池栈中创建一个默认自动释放池，主线程会监听main runloop的活动并通过入栈和出栈来周期性的新建和销毁自动释放池，子线程的默认自动释放池在使用时懒加载，在线程退出时清空； @autoreleasepool { }添加了自动释放池，但在离开其作用域后就已经释放了，可用其来做精细内存管理； 在MRC和早期的ARC中推荐用@autoreleasepool { }来消除内存峰值，现在的ARC中生成的局部对象，在离开局部作用域后就已经被释放了，已经不需要自动释放池来消除内存峰值，但依然可以保留这种写法以兼容老版本。 5.Block与内存管理Block自身的内存管理block其实是一个结构体，但也有一个指向类的isa指针，所以也可视为一种特殊的对象。block的isa指向抽象类NSBlock的子类__NSMallocBlock__、__NSStackBlock__或__NSGlobalBlock__，根据其实际类的不同可将block分为堆block、栈block和全局block，它们在内存中有不同的管理方法： 全局block(__NSGlobalBlock__)：和C函数一样储存在代码段，无需内存管理； 栈block(__NSStackBlock__)：类似于函数中的局部变量，由系统自动管理； 堆block(__NSMallocBlock__)：和普通对象一样由引用计数进行管理，支持ARC； 声明一个block时，block可以使用环境变量，对环境中全局变量和静态变量的使用不会影响block的类型，可如果使用了环境中的局部变量，声明的block将会是一个栈block，如果没有使用环境中的局部变量，则将会是一个全局block。对栈block进行copy会得到一个其在堆中的拷贝，而栈block的生命周期仅限于其声明时的作用域，所以若要持有一个栈block，MRC中需要手动调用栈block的copy来使用堆block，而ARC中则在将栈block赋值给变量时就自动进行了copy，而又因为全局block和堆block的copy返回的都是其自身，所以在需要持有一个block时，使用它的copy总是没错。 Block中对象的内存管理ARC中block会保留其捕获的环境局部变量对对象的引用，也就是说如果block中出现的环境局部变量是一个强引用指针，则block也会对该指针指向的对象强引用，如果捕获的环境局部变量是弱引用指针，则block对指针指向的对象也是弱应用，至于环境局部变量是自动释放引用指针，则不能在block中使用。 因为block的上述特性，如果block中要使用的局部变量是一个强引用指针，且指针指向的对象直接或间接的又强引用了该block，则会出现循环引用，造成内存泄露。针对这种情况，可以先用一个弱引用指针指向要使用的对象，再在block中使用弱引用指针，则能避免循环引用；而如果还需要防止block中代码执行期间，弱引用指针指向的对象被释放掉，则又可以在block中用先用一个临时的强引用指针来持有弱引用指针指向的对象，这个临时的强引用指针，作为block的局部变量，对对象的持有在block的作用域结束时即会释放。 6.NSString的内存问题iOS中NSString和NSMutableString都是抽象类，字符串的实际类型为：NSCFString、NSCFConstantString和NSTaggedPointerString，它们在内存中的存储和管理方式都各不相同： __NSCFString：对象字符串，运行时创建，存储在堆中，通过引用计数管理； __NSCFConstantString：常量字符串，编译期创建，存储在常量区，无需内存管理； NSTaggedPointerString：变量字符串，运行时创建，存储在指针变量中(栈中)，系统自动管理； 在创建一个字符串时，得到的字符串的实际类型遵循以下规律： NSCFConstantString和NSTaggedPointerString是NSString的直接子类，NSCFString是NSMutableString的直接子类，所以创建一个可变字符串和对字符串mutableCopy得到的必然是__NSCFString； 字面量语法生成的NSString在编译期创建，实际类型为NSCFConstantString，再次创建相同的NSCFConstantString时不会重复创建，而是指向相同的常量字符串； withFormart:系列方法创建的NSString在运行时创建，实际类型为NSCFString或NSTaggedPointerString：当字符串支持Tagged Pointer优化时则创建的NSString实际类型为NSTaggedPointerString，否则为NSCFString； withString:系列方法和copy得到的NSString实际类型和原字符串实际类型一致； Tagged Pointer：由于在64位系统中一个指针的长度已经达到了8个字节，对于一些信息量较少的对象(如NSSting、NSNumber、NSDate等)，其本身需要的内存空间可能都不足8个字节，再将其创建在堆中，并用一个8个字节长度的指针去指向它，就有一些性能和内存上的浪费，针对这种情况苹果为这些类引入了各自的Tagged Pointer对象进行优化 – 用指针的前后各半个字节存储对象的标记信息，中间的7个字节存储对象的值，对象不再保存在堆中，而是直接保存在指针中。对于NSString，如果字符串可以被ASCII编码、六位编码或五位编码，并被存储在7个字节中，则运行时创建的NSString实际类型为NSTaggedPointerString，但即使是五位编码(五位表示一个字符)，7个字节中最多保存(7*8)/5 = 11个字符，所以运行时创建的NSString如果大于11个字符则必然为__NSCFString 7.内存问题调试可以使用Xcode自带的僵尸对象功能来调试野指针问题，使用Instruments中的Leaks来检查内存是否泄露，当出现内存泄露时可以使用三方框架FBRetainCycleDetector来检查对象的循环引用，至于相关工具如何使用，在本篇中则不做赘述。]]></content>
      <categories>
        <category>iOS编程进阶</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
        <tag>引用计数</tag>
        <tag>ARC</tag>
        <tag>autoreleasePool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、ObjC的反射机制]]></title>
    <url>%2F2018%2F06%2F30%2FiOS%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%2F%E4%BA%8C%E3%80%81ObjC%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[反射是指程序在运行时可以访问、检测和修改程序本身的状态或行为的一种能力，OC是基于Runtime运行时系统的动态语言，具有强大的反射能力。OC的反射机制通常是指NSFoundation中为反射功能提供的一系列API，它们是基于Runtime的封装，是Runtime编程的子集。 1. 获取对象类型NSFoundation的根类NSObject中实现了-class方法，默认情况下它返回的是isa指向的类，但它可以被子类重写（比如KVO中），造成此方法返回的类和isa指向的类不一致的情况；Runtime提供了Class object_getClass(id obj)函数来获取对象所属的类，此函数直接返回对象isa所指向的类；NSFoundation中还提供了类方法+class，该方法返回的就是当前类，而不是类的类（元类）。 2. 对象检测方法NSFoundation中根类NSObject实现了一系列方法，来对对象的类型、协议、方法等做检测判断： 12345678910// @protocol NSObject- (BOOL)isKindOfClass:(Class)aClass;- (BOOL)isMemberOfClass:(Class)aClass;- (BOOL)conformsToProtocol:(Protocol *)aProtocol;- (BOOL)respondsToSelector:(SEL)aSelector;// @interface NSObject+ (BOOL)instancesRespondToSelector:(SEL)aSelector;+ (BOOL)conformsToProtocol:(Protocol *)protocol;+ (BOOL)isSubclassOfClass:(Class)aClass; 3.消息派发NSFoundation中根类NSObject实现一系列Perform Selector，它们有的是对objc_msgSend的封装，有的则是基于线程的RunLoop来实现的： 123456789101112131415// @protocol NSObject- (id)performSelector:(SEL)aSelector;- (id)performSelector:(SEL)aSelector withObject:(id)object;- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;// @interface NSObject (NSDelayedPerforming)- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;// @interface NSObject (NSThreadPerformAdditions)- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait;- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg; Perform Selector中有返回值的API要注意返回的对象可能会内存泄露，进行延迟派发、派发给其他线程、以及当前线程异步派发时，要注意判断目标线程的RunLoop是否运行。 4. 反射方法NSFoundation中还提供了字符串和Selector、类、协议互相装换的API，以方便放射功能的使用： 12345678NSString *NSStringFromSelector(SEL aSelector);SEL NSSelectorFromString(NSString *aSelectorName);NSString *NSStringFromClass(Class aClass);Class __nullable NSClassFromString(NSString *aClassName);NSString *NSStringFromProtocol(Protocol *proto);Protocol * __nullable NSProtocolFromString(NSString *namestr);]]></content>
      <categories>
        <category>iOS编程进阶</category>
      </categories>
      <tags>
        <tag>反射机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、ObjC的动态特性(Runtime)]]></title>
    <url>%2F2018%2F06%2F23%2FiOS%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%2F%E4%B8%80%E3%80%81ObjC%E7%9A%84%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7(Runtime)%2F</url>
    <content type="text"><![CDATA[Reference:Objective-C Runtime Programming GuideiOS Runtime详解 简述Runtime抽象的说OC的运行时系统，实质点讲它是一个由C和汇编编写的库（后逐步用C++重写）。这个库完成了OC对C的扩展，在编译期，通过它实现了OC向C/C++的装换；同时在运行时，它是OC面向对象和动态特性的基石：它让OC可以动态的创建类和对象、并通过方法调用来完成函数的动态绑定，进行消息的传递和转发。 概览/1.png) 要点 类和对象都有个指向类的isa指针，所以类又称类对象，对象的isa指向所属类，类的isa指向元类； 所有元类的isa都指向根类（NSObject）的元类，包括它自己； 类别可以为类添加属性，但不能添加成员变量，可以用关联对象来代替成员变量，保存属性的值； 消息决策时先在当前类的方法缓存中查找，再去继承链上的方法列表中查找，继承连上找到后，会缓存到当前类的方法缓存中； 消息转发的系列方法中要注意调用父类的方法，以便处理当前类未处理的消息； 详解Runtime的代码是开源的，从objc4-493版本开始，Runtime的实现代码逐步用C++进行重写，本文参照的源码是最后一个没有C++的版本objc4-437.3。 面向对象1.对象源码中对象的定义： 123typedef struct objc_object &#123; Class isa;&#125; *id; 对象的定义是一个结构体，内部只有一个指向所属类的isa指针。 2.类源码中类的定义： 123456789101112131415161718typedef struct objc_class *Class;struct objc_class &#123; Class isa;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; Meta Class类的结构体中也有一个指向所属类的isa指针，还有一个指向父类的super_class指针，类的isa指向的是类的类，被称之为元类；元类的super_class指针指向元类的父类，元类的isa指针则都指向根元类（即NSObject的元类）；值得注意的是根元类的super_class指向的是根类（即NSObject），isa指针依然指向根元类（即它自己）。 对象、类和元类之间的关系如图：/2.png) 类对象：对象和类都有isa指针指向所属的类，甚至在C++实现的Runtime版本中，类的结构体直接继承自对象的结构体，所以说类也是对象，称之为类对象，类对象和元类是一一对应的，都是运行时由系统创建的单例。 objc_ivar_list类中struct objc_ivar_list *ivars是成员变量列表，源码中定义的成员变量其结构如下： 12345678struct objc_ivar &#123; char *ivar_name OBJC2_UNAVAILABLE; char *ivar_type OBJC2_UNAVAILABLE; int ivar_offset OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif&#125; 其中ivar_type存储的是成员变量的数据类型、内存管理、访问权限等信息编码后的结果；提供Ivar *class_copyIvarList(Class cls, unsigned int *outCount)函数来获取一个类的成员变量列表。 在类中使用@property为类同时添加了属性和成员变量，属性的本质是set和get方法，提供objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)函数获取一个类的属性列表。 objc_method_list类中struct objc_method_list **methodLists是对象方法列表，类方法就是类对象的方法，保存在元类的方法列表中，源码中方法的结构如下： 12345struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;&#125; 方法中method_name即Selector，method_types是方法的签名，method_imp则是方法的实现，提供Method *class_copyMethodList(Class cls, unsigned int *outCount)来获取一个类的对象方法列表。 objc_cache类中struct objc_cache *cache是Selector的方法缓存，其中保存的数据结构如下： 12345typedef struct &#123; SEL name; // same layout as struct old_method void *unused; IMP imp; // same layout as struct old_method&#125; cache_entry; 方法缓存的设计源于一个理念：类的某个方法调用后，接下来会有很大的概率被再次调用。当向一个对象发送消息后，需要查找Selecotr对应的实现（IMP），查找顺序是先查找当前类的方法缓存，如果没有找到，则从当前类开始，沿着继承链在类的方法列表中查找，找到后会将Selector和IMP的映射缓存在当前类的方法缓存中。 objc_protocol_list类中struct objc_protocol_list *protocols是协议列表，源码中协议的结构如下： 12345678910111213@interface Object&#123; Class isa; /* A pointer to the instance's class structure */&#125;@interface Protocol : Object&#123;@private char *protocol_name OBJC2_UNAVAILABLE; struct objc_protocol_list *protocol_list OBJC2_UNAVAILABLE; struct objc_method_description_list *instance_methods OBJC2_UNAVAILABLE; struct objc_method_description_list *class_methods OBJC2_UNAVAILABLE;&#125; 协议是一个继承自Object的类，其内有该协议遵循的协议列表、对象方法列表、和类方法列表；提供Protocol **class_copyProtocolList(Class cls, unsigned int *outCount)函数来获取一个类的协议列表。 3.类别源码中类别的结构如下： 1234567struct objc_category &#123; char *category_name OBJC2_UNAVAILABLE; char *class_name OBJC2_UNAVAILABLE; struct objc_method_list *instance_methods OBJC2_UNAVAILABLE; struct objc_method_list *class_methods OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;&#125; 通过类别可以为类添加属性，但不能添加成员变量，类别添加属性时，可以通过objc_setAssociatedObject添加关联对象，代替成员变量来保存属性的值。 主类和类别中的方法、协议等都是在Runtime初始化函数_objc_init中map_images时，添加到类的列表中，类别虽然后添加，但却是插在列表前面，所以类别的方法可以覆盖主类中的同名方法。 _objc_init中的回调map_images完成后，类、协议、类别等已经初始化完成，然后在load_images触发时，再调用各个类和类别的+load方法，所以在iOS中+load调用时，App相关的类都已完成初始化，因此，在iOS中+load方法的不安全指的是不能保证其他类的+load已经执行，而不是指其它类未完成初始化，关于+load的执行顺序总结如下： 父类的+load执行后子类的+load才执行； 所有类的+load执行后类别的+load才执行； 类别之间、没有依赖关系的类之间，+load执行的顺序与编译顺序相同（即buildPhases -&gt; Compile Sources中的文件顺序）； initialize：除了+load方法还可以选择在initialize方法中做类的初始化相关工作，关于initialize的调用规则需要分清以下几点： initialize是在类的加载完成之后，第一次调用类的方法之前被调用； 子类的initialize中不需要显式的调用父类的方法，父类的initialize会被自动的调用； Category中的initialize会覆盖类中的initialize方法； 消息传递Runtime通过方法调用来实现函数的动态绑定，即所调用的函数地址不是编译期硬编码在指令中，而是需要在运行期读取。方法调用又叫消息传递，消息由selector及其参数所构成，消息传递的核心是objc_msgSend函数： 1id objc_msgSend(id self, SEL op, ...); 在objc_msgSend函数中，第一个参数是消息的接收类/对象，第二个参数是selector，后面才是消息的参数，所以在一个方法实现的内部，有两个默认的参数self和_cmd，它们分别代表方法调用者自身和方法的selector。 消息传递，即对象进行方法调用，到执行对应实现，所执行的步骤大致如下： 根据对象/类的isa指针找到对象/类所属的类/元类； 先在当前类/元类的方法缓存中查找selector对应的IMP，找到IMP则去执行对应的函数实现； 方法缓存中没找到，则沿着继承链在类/元类的方法列表找查找selector对应的方法； 找到对应方法后，将方法中的IMP和selector的映射添加到当前类/元类的方法缓存中，并执行IMP对应的函数实现； 如果最终沿着继承链没有找到对应的方法，则启动消息转发机制； 消息转发当一个消息在类及其继承链上最终没有找到对应的方法实现，将启动消息转发机制，消息转发的流程如图： /3.png) 启动消息转发后，消息的接收者还有三次机会来对消息做出处理： 动态方法解析：在+resolveClassMethod:/+resolveInstanceMethod:中，如果为消息动态的添加了一个类/对象方法，则重新再发送一次消息，如果没有为消息动态的添加方法，则继续消息转发的下一步（与动态解析方法返回YES/NO没有关系）； 备援接受者：在-forwardingTargetForSelector:中如果返回了一个非nil的备援接受者，则将消息发送给备援接受者，如果返回nil，则继续消息转发的下一步； 转发消息：需要先在-methodSignatureForSelector:返回消息对应的方法签名，再在-forwardInvocation:中处理NSInvocation，如果没有返回方法签名，则会调用-doesNotRecognizeSelector:方法，并抛出异常； 在为当前类实现以上消息转发方法时，对于没有处理的消息，都应调用父类的方法，交由父类处理。在第三步转发消息时，方法签名可以参看官方文档Type Encodings，处理NSInvocation时，可以简单的转发给另外一个target，但这就跟返回备援接受者效果一样，一般如果消息转发需要走到这一步，则是需要编辑NSInvocation来更改消息内容，比如追加参数、更换selector等。 应用Runtime是OC动态特性的基石，使用它可以实现OC语言层面的拓展，Runtime的应用非常的广泛，Runtime实现的功能也非常的实用，Runtime编程可以参见Objective-C Runtime Programming Guide，这里只对一些常见的应用做一个简单的介绍 关联对象Runtime提供了三个函数来管理关联对象： 123456//关联对象void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)//获取关联的对象id objc_getAssociatedObject(id object, const void *key)//移除关联的对象void objc_removeAssociatedObjects(id object) 关联对象一个非常常用的地方是在类别中添加属性时，代替成员变量来保存属性的值。添加关联对象时，需要指明和属性修饰符类似的关联对象内存策略，常用的有以下几个： OBJC_ASSOCIATION_ASSIGN，同@property (assign)或 @property (unsafe_unretained)； OBJC_ASSOCIATION_RETAIN_NONATOMIC，同@property (nonatomic, strong)； OBJC_ASSOCIATION_COPY_NONATOMIC，同@property (nonatomic, copy)； ISA Swizzling对象的isa指针指向了它所属的类，ISA Swizzling是指修改对象isa指向的类的技术。Runtime提供Class object_setClass(id obj, Class cls)函数来修改一个对象所指向的类，ISA Swizzling只会影响做了替换操作的对象，不会影响到整个类，替换示例： 12345678BOOL swizzlingObjClass(id obj, Class newCls)&#123; if (class_getInstanceSize(newCls) &lt;= class_getInstanceSize([obj class])) &#123; object_setClass(obj, newCls); return YES; &#125; return NO;&#125; 上面的示例中使用了size_t class_getInstanceSize(Class cls)来比较ISA Swizzling前后类的实例的大小，这是因为将要ISA Swizzling的对象的内存是已经分配好的，如果替换后类的实例大于替换之前分配的内存，会导致EXC_BAD_ACCESS错误，所以ISA Swizzling时，替换后的类一般为替换前类的子类，而且子类中没有新增任何成员变量或合成属性。KVO就是通过ISA Swizzling技术来实现的。 当对某个类A的对象添加KVO之后，KVO机制会动态的创建一个A的子类（通常命名为NSKVONotifying_A），然后让被观察对象的isa指向这个子类，在子类中重写了-class方法，让-class依然返回原来的类，并重写了被观察keyPath的setter方法，在setter方法中调用了-willChangeValueForKey:和-didChangeValueForKey:，当通过setter方法更改被观察的值时，观察者就能收到通知。 Method SwizzlingRuntime允许动态的新增、替换方法的实现，用新的实现替换原有方法的实现，就叫做Method Swizzling。一种特殊的Method Swizzling - 交换两个已有方法的实现，配合类别可以为原方法添加hook，完成对没有源码的原方法的修改。简单的hook使用method_exchangeImplementations即可实现，但实际上hook时有许多需要注意的问题，安全而健壮的hook可以参看文章Objective-C Method Swizzling。 Zombie ObjectsZombie Objects是Xcode中用来调试野指针（EXC_BAD_ACCESS）这类内存问题的工具，它充分的应用了Runtime技术：它首先通过Method Swizzling替换原来的-dealloc方法，当对象引用计数为0的时候，会调用新的__dealloc_zombie方法；新的方法中又使用ISA Swizzling技术让对象的isa指向僵尸类，然后释放对象的引用，但并不释放当前对象；最后当程序再向本该已释放的对象发送消息时，在僵尸类的消息转发中就会输出调试信息。 Zombie Objects中__dealloc_zombie打大致实现（非源码）： 123456789101112131415161718192021- (void)__dealloc_zombie&#123; Class cls = object_getClass(self); const char *clsName = class_getName(cls); char *zombieClsPrefix = "_NSZombie_"; char *zombieClsName = malloc(strlen(zombieClsPrefix)+strlen(clsName)+1); strcpy(zombieClsName, zombieClsPrefix); strcat(zombieClsName, clsName); // 查看是否存在相同的僵尸对象类名，不存在则创建 Class zombieCls = objc_lookUpClass(zombieClsName); if (!zombieCls) &#123; Class baseZombieCls = objc_lookUpClass("_NSZombie_"); zombieCls = objc_duplicateClass(baseZombieCls, zombieClsName, 0); &#125; // 释放引用。 objc_destructInstance(self); // ISA Swizzling object_setClass(self, zombieCls);&#125; YYModelYYModel运用Runtime面向对象的特性，为根类NSObject添加扩展，实现JSON数据和OC模型之间自动转换。YYModel非常的轻量级，代码也非常的直观，其他利用Runtime特性实现JSON与OC模型互相转换的库还有很多（如：MJExtension），它们对Runtime的利用更加复杂，功能也相对丰富。 JSPatchJSPatch是一个热修复库，它的基本原理是：JS传递字符串给OC，OC通过Runtime动态调用接口和替换OC方法的实现。JSPatch对Runtime的应用还包括动态的注册类，为类添加方法等，示例代码如下： 123Class cls = objc_allocateClassPair(superCls, "JPObject", 0);class_addMethod(cls, selector, implement, typedesc);objc_registerClassPair(cls);]]></content>
      <categories>
        <category>iOS编程进阶</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
        <tag>消息转发</tag>
        <tag>Swizzling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六、UIView的生命周期]]></title>
    <url>%2F2018%2F06%2F13%2FAPP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F%E5%85%AD%E3%80%81UIView%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[UIView和UIViewController是UIKit中负责和控制展示与交互的核心类，通常将从它们的创建到视图加载（load）、显示（display）、移除（remove）的过程称为视图的生命周期，清楚这个周期内系统函数的执行顺序，有助于开发者掌控视图的展示过程，在合适的地方添加代码来实现自己的需求。 构建UIView和UIViewController有三种创建方式：code（代码）、xib和storyboard，任何构建方式最后都需要调用指定构造方法（NS_DESIGNATED_INITIALIZER），它们各有两个指定构造方法，不同创建方式在指定构造方法调用前后执行的函数各有不同： 构建顺序 UIView UIViewController code -initWithFrame: -init（或其它自定义构造方法）-initWithNibName: bundle: xib -initWithCoder:-awakeFromNib: -init（隐式使用xib）-initWithNibName: bundle: storyboard -initWithCoder:-awakeFromNib: -initWithCoder:-awakeFromNib: 构建过程容易混淆的地方主要有以下两点： UIView通过xib和storyboard创建时调用了-initWithCoder:和-awakeFromNib:，UIViewController通过toryboard创建时也调用了它们，通过xib创建时调用的却不是它们； 通过xib创建UIViewController时调用的是-initWithNibName: bundle:，而通过code创建时调用的也是这个指定构造函数； 加载当ViewController创建后，它的根视图是懒加载的，加载前后会分别调用-loadView和-viewDidLoad函数，关于ViewController的根视图加载过程需要注意以下几点： -loadView和-viewDidLoad都需要触发根视图的加载过程才会被调用，如果没有触发根视图的加载过程（view在使用前通过代码赋了非空的值），则它们都不会执行； -loadView中可以设置根视图，这儿设置的根视图，可以覆盖xib创建的根视图，但会被storyboard创建的根视图覆盖； 显示ViewController展示它的视图和View被添加到superview上显示时函数调用顺序如下： UIViewController UIView -viewWillAppear:-loadViewIfNeeded-viewWillLayoutSubviews-viewDidLayoutSubviews-viewDidAppear:-viewWillLayoutSubviews-viewDidLayoutSubviews -willMoveToSuperview:-didMoveToSuperview-willMoveToWindow:-didMoveToWindow 显示过程需要注意的有： -viewWillAppear:之后会自动调用-loadViewIfNeeded，确保根视图已完成加载； LayoutSubviews相关方法在-viewWillAppear:和-viewDidAppear:前后都会被调用； 移除ViewController的视图不再展示和View从superview上移除时调用的函数顺序如下：| UIViewController | UIView || — | — || -viewWillDisappear:-viewWillLayoutSubviews-viewDidLayoutSubviews-viewDidDisappear: | -willMoveToSuperview:-willMoveToWindow:-didMoveToWindow-didMoveToSuperview | 关于ViewController的disappear和View的移除需要注意的是： disappear过程也会触发LayoutSubviews相关方法； View的MoveToWindow和MoveToSuperview方法之间的顺序难以保证（只能确定will和did的先后顺序）； 汇总以展示一个通过code创建的ViewController，并在-viewDidLoad方法中添加了一个subView为例，视图生命周期相关函数的交叉顺序如下： 1234567891011121314151617181920212223242526272829// Appear过程-[ViewController init]-[ViewController initWithNibName:bundle:]-[ViewController loadView]-[ViewController viewDidLoad]-[SubView initWithFrame:]-[SubView willMoveToSuperview:]-[SubView didMoveToSuperview]-[ViewController viewWillAppear:]-[ViewController loadViewIfNeeded]-[SubView willMoveToWindow:]-[SubView didMoveToWindow]-[ViewController viewWillLayoutSubviews]-[ViewController viewDidLayoutSubviews]-[SubView layoutSubviews]-[SubView layoutSubviews]-[ViewController viewDidAppear:]-[ViewController viewWillLayoutSubviews]-[ViewController viewDidLayoutSubviews]// Disappear过程-[ViewController viewWillDisappear:]-[ViewController viewWillLayoutSubviews]-[ViewController viewDidLayoutSubviews]-[SubView willMoveToWindow:]-[SubView didMoveToWindow]-[ViewController viewDidDisappear:]-[SubView willMoveToSuperview:]-[SubView didMoveToSuperview]]]></content>
      <categories>
        <category>APP工作原理</category>
      </categories>
      <tags>
        <tag>UIView生命周期</tag>
        <tag>loadView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五、事件传递机制（Responder Chain）]]></title>
    <url>%2F2018%2F03%2F13%2FAPP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F%E4%BA%94%E3%80%81%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%EF%BC%88Responder%20Chain%EF%BC%89%2F</url>
    <content type="text"><![CDATA[UIEvent用户对设备的交互行为，最终会在APP中被包装为UIEvent，由对应的APP进行响应和处理，用户的交互行为到UIEvent的过程如下： 用户通过硬件产生一个交互，硬件将信息传递给系统； 系统的IOKit生成IOHIDEvent，并发送给SpringBoard； SpringBoard再通过系统端口将事件传递给对应的APP； APP主线程的RunLoop中，由UIKit注册了一个Source1，监听对应端口，接收SpringBoard传递的事件； 监听的处理函数中根据传递的事件生成UIEvent，再提交到Application的事件队列中依次处理。 UIEvent有不同的类型，主要有以下几类： touches：屏幕的触控事件； motion：陀螺仪对应的时间，晃动（motionShake）是其子类型（subtype）; remoteControl：遥控器（tvOS），耳机等产生的遥控时间； presses：物理按键（物理Home键等）的按压事件。 2020-05补充：iOS13.4之后UIEvent新增了scroll、hover和transform类型，对应设备新的交互方式。 UIRespnderUIResponder是UIKit中的一个抽象类，它有一个nextResponder属性指向下一个UIResponder，UIKit通过UIResponder实现了职责链模式，用于处理和传递UIEvent，iOS中将UIResponder实际子类的实例称为Responder（响应者），将Responder所构成的职责链称为Responder Chain（响应链），当事件被传递给Responder，Responder可以对事件做出响应，如果Responder不做处理，则默认将事件沿Responder Chain继续传递，直至被处理或最终被忽略。 Responder ChainUIKit中的UIResponder的实际类型为UIView、UIViewController、UIApplication和AppDelegate： 子View的nextResponder是其superView； View如果是ViewConroller的根视图，则它的nextResponder是其ViewController； ViewController的nextResponder是其parentViewController； ViewController如果是Window的根ViewController， 则其nextResponder是Window； Window的nextResponder是Application； Application的nextResponder是AppDelegate； Tip：实测touches类型以外的UIEvent在传递给Application之后，不会再继续向下传递。 UITouch不同类型的UIEvent，Application在传递给Responder Chain时有不同的处理，touches类型以外的UIEvent会直接交给FirstResponder处理或传递，touches事件则会先交给KeyWindow，再由KeyWindow通过Hit-Test找到Hit-Test View（触碰视图），然后将touches事件以及事件的UITouch对象（可能是多个）传递给Hit-Test View。 Hit-TestHit-Test是一个嵌套循环调用-hitTest:withEvent:方法的遍历过程，大致流程如下： Application调用KeyWindow的-hitTest:withEvent:方法； 方法中先判断自己能否接收touches事件（userInteractionEnabled/hidden/alpha），不能就直接返回nil； 再通过-pointInside:withEvent:方法判断触摸点是否在自己区域内，不在就直接返回nil； 倒序循环遍历subViews，嵌套调用subView的-hitTest:withEvent:方法，直到找到Hit-Test View； 当2、3条件都满足，subViews中也没有找到合适的Hit-Test View时，就返回View自己； Applicaton将touches事件和以及事件的UITouch对象传递给Hit-Test View。 Tip：可以通过覆写-hitTest:withEvent:和-pointInside:withEvent:方法来改变APP对touches事件的响应逻辑，如改变响应对象，改变触摸响应区域等。 touches事件传递给Hit-Test View之后，如果没有被识别为UIAction，也未被识别为手势，则会沿着响应链进行传递，链上的响应者通过覆写touches的传递方法，都有机会对事件作出响应，touches的传递有以下五个相关方法： 12345678910// Generally, all responders which do custom touch handling should override all four of these methods.// Your responder will receive either touchesEnded:withEvent: or touchesCancelled:withEvent: for each// touch it is handling (those touches it received in touchesBegan:withEvent:).// *** You must handle cancelled touches to ensure correct behavior in your application. Failure to// do so is very likely to lead to incorrect behavior or crashes.- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches; Tips： 覆写touches的传递方法时，如果需要继续传递，应该调用super的对应方法，而不是直接调用nextResponder的对应方法； 单点触控时UIEvent对应一个UITouch对象，多点触控则对应多个UITouch对象； 一个touches事件传递时，方法传递的UIEvent和UITouch对象是同一个（组），最后的Responder的Ended方法调用之后才销毁。 UIActionView在收到touches事件后，在经响应链传递前，还需要先做两个判断： 判断View是否为UIControl的子类：如果是，则对touches事件做UIAction识别，识别为UIAction则通过UIControl的Tareget-Action模式进行处理，touches事件不再经响应链传递； 倒序查找View所在的视图层级是否添加了UIGestureRecognizer：如果有添加，则对touches时间做手势识别，如果被识别为手势，这通过手势的Target-Action模式进行处理，touches事件默认不再经响应链传递。 UIControl中针对UIAction的识别有四个跟踪方法，如果想自定义跟踪识别，可以覆写相关的方法： 1234- (BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;- (BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;- (void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;- (void)cancelTrackingWithEvent:(UIEvent *)event; Target-Action当UIControl将touches时间识别为UIAction之后，通过Target-Action模式交个target进行处理的过程如下： 创建UIAction，调用UIControl自己的-sendAction:to:forEvent:方法，将Action转发个UIApplication对象； UIApplication对象调用-sendAction:to:fromSender:forEvent:方法，将Action分发给指定的target。 Tip：UIControl的Action在设置Target时，可以设置为nil，这样UIAction会沿着响应链寻找Target，据此可以在运行时决定Action的Target，但除非特殊需求，不建议滥用此特性。]]></content>
      <categories>
        <category>APP工作原理</category>
      </categories>
      <tags>
        <tag>UIEvent</tag>
        <tag>UIResponder</tag>
        <tag>响应链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四、事件处理机制（RunLoop）]]></title>
    <url>%2F2018%2F03%2F02%2FAPP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F%E5%9B%9B%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%88RunLoop%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Reference:深入理解RunLoopRunLoop 详解 程序运行时代码都是顺序执行的，执行完毕程序就结束退出了，了解APP工作机制的一个基础，是弄清楚APP如何实现在内存中常驻的。 概述代码在程序的线程中顺序执行，当程序所有的线程中代码都运行完毕，程序就结束并退出了，iOS与MacOS中通过RunLoop机制来让线程可以一直保持运行，并循环的处理各类事件，从而让APP常驻在内存中持续工作 。系统的某些任务也依托RunLoop来完成，了解RunLoop的运行机制将有助于了解系统任务的机制，同时理解了RunLoop能清楚一个线程中（特别是主线程中）各类任务的代码执行顺序，还将有助于多线程并发编程时的程序设计。 概览 要点 RunLoop就是让线程保持一直运行，并可以循环处理事件的机制； RunLoop线程一一对应，代码中不能直接创建，而是提供获取主线程和当前线程RunLoop的API，在第一次调取API时，API内部负责创建RunLoop，子线程的RunLoop需要手动启动； 一个RunLoop包含若干个Mode，每个Mode又包含若干个Source/Timer/Observer； RunLoop必须指定一个Mode进行运行，运行后如果Mode中一个items都没有，将会退出运行； kCFRunLoopCommonModes是一个伪Mode，用它添加的items，在其他“CommonMode”运行时，也能得到触发，NSTimer通常需要通过此Mode添加到RunLoop中； Source分为Source0和Source1，Source0需要手动显示唤醒RunLoop来处理事件，可用于线程间发送消息，Source1是基于端口的，端口有消息能自动唤醒RunLoop来处理事件，用于监听内核端口的消息； Timer是在计算好的预设时间点由内核发送时间通知，唤醒RunLoop来处理Timer事件； Observer是RunLoop的观察者，RunLoop在某些活动节点会触发其回调，可以据此在对应的时机安排自己APP需要执行的任务； RunLoop的休眠/唤醒是通过Mach陷阱切换程序的应用态/内核态来实现的； Perform Selector系列方法中延迟派发、派发给其他线程、以及当前线程异步派发时，是通过创建源并加入到对应RunLoop中来实现的，必须要目标线程的RunLoop运行，派发的Selector才会被执行，Perform Selector添加的源会在执行后从RunLoop中移除； 用GCD为主线程派发任务，也是包装成待处理的Source1，再添加到主线程RunLoop中来实现的，但GCD为子线程（并发队列）派发任务，不是通过RunLoop实行的； UIEvent是UIKit在主线程中注册一个Source1，通过端口接收到Spring Board转发的IOHIDEvent，再在回调中处理，最后包装成UIEvent的； 详解1.什么是RunLoopRunLoop是一种iOS与MacOS中让线程保持一直运行，并可以循环处理事件的机制。RunLoop在CoreFoundation中通过CFRunLoopRef对象来实现，其提供纯C函数的、线程安全的API；同时还有基于CFRunLoopRef更上层的封装：NSRunLoop，其提供面向对象的API，但不是线程安全的。 2.RunLoop与线程的关系RunLoop与线程是一一对应的，CoreFoundation与NSFoundation中都不提供直接创建RunLoop的API，而是提供了获取主线程RunLoop和当前线程RunLoop的API，在第一次调取线程的RunLoop获取API时，函数内部才为线程创建其RunLoop，并以线程为key，RunLoop为value，保存在一个全局字典中。 3.RunLoop的相关概念RunLoop中的结构如图： 一个RunLoop中包含若干个Mode，每个Mode中又包含若干个Source、Timer和Observer，Source、Timer和Observer统称为items，一个item可以添加到不同的Mode，重复添加到同一个Mode没有效果；启动RunLoop时需要指定一个Mode，Mode中至少要有一个item，否则RunLoop会立即退出；RunLoop运行期间指定Mode下的items的回调会触发，如果指定运行的Mode属于”CommondMode”，则标记为 kCFRunLoopCommonModes的items的回调也会触发；要切换Mode，必需停止RunLoop，再指定新的Mode重新启动RunLoop。 在CoreFoundation中Mode和items对应的类为：CFRunLoopModeRef、CFRunLoopSourceRef、CFRunLoopTimerRef和CFRunLoopObserverRef，下面将分别介绍它们的特性。 CFRunLoopModeRefCFRunLoopModeRef类没有对外暴露，而是提供了一系列根据mode name来管理Mode和Mode下的items（Source、Timer和Observer）的API： 12345678910// 管理Mode的接口CFRunLoopRunInMode(CFStringRef modeName, ...);CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);// 管理Mode下items的接口CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 提供的接口只能通过mode name来管理mode，当传入一个新的mode name，而RunLoop内又没有对应的Mode时，RunLoop会自动创建对应的CFRunLoopModeRef；并没有提供删除Mode的API，所以RunLoop的Mode只能增加不能删除。 系统为主线程的RunLoop默认注册了五个Mode： kCFRunLoopDefaultMode：默认Mode，主线程通常也是在此Mode下运行； UITrackingRunLoopMode：界面追踪Mode，当需要追踪触摸滑动时，主线程会被切换到此Mode，避免其他items对界面滑动的影响； UIInitializationRunLoopMode：APP刚启动时使用的Mode，启动完成后就不再使用； GSEventReceiveRunLoopMode：接收系统事件的内部Mode，开发中通常用不到； kCFRunLoopCommonModes：占位Mode，不是一个真正的Mode，可以用来添加items，不能用来启动RunLoop； 上述Mode中开发相关的有：kCFRunLoopDefaultMode、UITrackingRunLoopMode和kCFRunLoopCommonModes，其中kCFRunLoopDefaultMode和UITrackingRunLoopMode是真正的Mode，而kCFRunLoopCommonModes是一个占位Mode。用kCFRunLoopCommonModes添加的items，在RunLoop以一个“CommondMode”运行时，也能得到触发。可以用CFRunLoopAddCommonMode将一个Mode标记为”CommondMode“（既将Mode添加到CFRunLoopRef的_commonModes集合中），kCFRunLoopDefaultMode和UITrackingRunLoopMode都是”CommondMode“。 事件队列中判断Source和Timer的Block是否触发代码逻辑大致如下：1234567891011121314151617181920static Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm) &#123; ... ... while (item) &#123; struct _block_item *curr = item; item = item-&gt;_next; Boolean doit = false; if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123; doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode)); &#125; else &#123; doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode)); &#125; if (!doit) prev = curr; if (doit) &#123; ... ... &#125; &#125; ... ... return did;&#125; CFRunLoopSourceRefRunLoop的事件源有两个：输入源和定时源，输入源即Source，可以通过为Mode添加Source，来为RunLoop添加需要处理的事件，在Cocoa层官方将Source分为三类： Port-Based Sources Custom Input Sources Cocoa Perform Selector Sources CoreFoundation中输入源则分为非基于端口的Source0和基于端口的Source1，分别对应Custom Input Sources和Port-Based Sources，Cocoa Perform Selector Sources是Perform Selector系列方法创建的源，Perform Selector延迟派发时创建的是定时源，派发给其他线程或当前线程异步派发时创建的Source0，Perform Selector创建的源，在执行完后会自动从RunLoop中移除。 Source0：只包含一个回调（函数指针），需要应用手动触发，不能主动唤醒RunLoop，使用时需要先调用CFRunLoopSourceSignal(source)，将Source标记为待处理，再手动调用CFRunLoopWakeUp(runloop)，唤醒RunLoop处理Source的事件。 Source1：包含一个mach_port和一个回调（函数指针），由mach_port驱动，可以主动唤醒RunLoop，通常用于通过内核和其他线程互相发送消息。 CFRunLoopTimerRefTimer就是定时源，是RunLoop的另一个事件源，也可以通过为Mode添加Timer，来为RunLoop添加需要处理的事件。CFRunLoopTimerRef包含一个时间长度和一个回调（函数指针），它与NSTimer是toll-free bridged的，可以混用。当Timer加入到RunLoop之后，会基于XNU内核的mk_timer或GCD计时器（根据CoreFoundation的版本不同而不同），在计算好的预设时间点由内核发送通知，唤醒RunLoop处理Timer的事件。 CFRunLoopObserverRefObserver是RunLoop的观察者，包含一个回调（函数指针），当RunLoop运行到特定状态时会触发回调，并将状态传递给回调函数，会触Observer回调的状态包括： 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入循环 kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出循环&#125;; 4.RunLoop的核心逻辑CoreFoundation的版本不同，RunLoop的核心源码可能不一致，但逻辑不会有太大的出入，整体可以参考以下对CoreFoundation CF-855.17版本源码删减后的逻辑整理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201/// 公开接口一：用DefaultMode启动void CFRunLoopRun(void) &#123; /* DOES CALLOUT */ int32_t result; do &#123; result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);&#125;/// 公开接口二：用指定的Mode启动（允许设置RunLoop超时时间）SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123; /* DOES CALLOUT */ return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125;/// RunLoop的实现SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123; /* DOES CALLOUT */ if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished; /// 首先根据modeName找到对应mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false); /// 如果mode里没有source/timer/observer, 直接返回。 if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123; Boolean did = false; return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished; &#125; CFRunLoopModeRef previousMode = rl-&gt;_currentMode; rl-&gt;_currentMode = currentMode; int32_t result = kCFRunLoopRunFinished; /// 1. 通知 Observers: RunLoop 即将进入 loop。 if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); /// 10. 通知 Observers: RunLoop 即将退出。 if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); rl-&gt;_currentMode = previousMode; return result;&#125;/// 内部核心函数，进入loopstatic int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123; /// 如果当前是主线程RunLoop，且当前mode的第一次运行，会分发一个GCD端口（用于第5步） mach_port_name_t dispatchPort = MACH_PORT_NULL; Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ))); if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF(); /// 给当前模式分发GCD定时端口 mach_port_name_t modeQueuePort = MACH_PORT_NULL; if (rlm-&gt;_queue) &#123; modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue); if (!modeQueuePort) &#123; CRASH("Unable to get port for run loop mode queue (%d)", -1); &#125; &#125; /// 初始化一个GCD计时器，用于第7步对RunLoop进行超时唤醒 dispatch_source_t timeout_timer = NULL; struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context)); if (seconds &lt;= 0.0) &#123; // instant timeout seconds = 0.0; timeout_context-&gt;termTSR = 0ULL; &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT); timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); dispatch_retain(timeout_timer); timeout_context-&gt;ds = timeout_timer; timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl); timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds); dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout); dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel); uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL); dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL); dispatch_resume(timeout_timer); &#125; else &#123; // infinite timeout seconds = 9999999999.0; timeout_context-&gt;termTSR = UINT64_MAX; &#125; Boolean didDispatchPortLastTime = true; int32_t retVal = 0; do &#123; uint8_t msg_buffer[3 * 1024]; mach_msg_header_t *msg = NULL; mach_port_t livePort = MACH_PORT_NULL; __CFPortSet waitSet = rlm-&gt;_portSet; /// 2. 通知 Observers: RunLoop开始处理Timer __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); /// 3. 通知 Observers: RunLoop即将处理Source0(非port)回调 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources); /// 执行可能即时提交到队列中的block __CFRunLoopDoBlocks(rl, rlm); /// 4. 处理Source0 Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle); /// 如果Source0中有待处理的事件，执行Source0提交到队列中的block if (sourceHandledThisLoop) &#123; __CFRunLoopDoBlocks(rl, rlm); &#125; /// 标志是否等待端口唤醒 Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR); /// 5. 如果是主线程（dispatchPort是主线程才会被赋值）在进入休眠前会检查是否有通过GCD派发过来的Source1，如果有，跳过休眠到第9步进行处理 if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123; /// 首次循环是不会进入检查（didDispatchPortLastTime为true） msg = (mach_msg_header_t *)msg_buffer; if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0)) &#123; goto handle_msg; &#125; &#125; didDispatchPortLastTime = false; /// 6.通知 Observers: RunLoop即将进入休眠(sleep) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting); __CFRunLoopSetSleeping(rl); /// 7. 调用mach_msg等待接受mach_port的消息，线程将进入休眠, 直到被下面某一个事件唤醒： /// • 某个基于port的Source1有消息到达 /// • 某个Timer的时间到了 /// • RunLoop为自身设定的超时时间到了 /// • 被其他调用者手动显式唤醒 msg = (mach_msg_header_t *)msg_buffer; __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY); __CFRunLoopUnsetSleeping(rl); /// 8. 通知 Observers: RunLoop的线程刚刚被唤醒了。 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting); /// 事件处理的跳转标准 handle_msg: /// 9. 处理未处理的事件 if (MACH_PORT_NULL == livePort) &#123; /// 无端口唤醒，RunLoop正常运行不会有此情况 CFRUNLOOP_WAKEUP_FOR_NOTHING(); &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123; /// 被自身的CGD超时计时器唤醒，无需做任何处理 CFRUNLOOP_WAKEUP_FOR_WAKEUP(); &#125; else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123; /// 被定时器通知唤醒，处理定时器事件 if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123; __CFArmNextTimerInMode(rlm, rl); &#125; &#125; else if (livePort == dispatchPort) &#123; /// 主线程被GCD派发的事件唤醒，或由第5步直接跳转过来，处理派发的事件 CFRUNLOOP_WAKEUP_FOR_DISPATCH(); __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; else &#123; /// 被source1唤醒,处理Source1 CFRUNLOOP_WAKEUP_FOR_SOURCE(); mach_msg_header_t *reply = NULL; sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop; &#125; /// 执行以上各类事件时加入到队列中的block __CFRunLoopDoBlocks(rl, rlm); /// 跳出循环，停止RunLoop的各类情况 if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; /// 启动RunLoop时即指明处理完事件就返回 retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123; /// RunLoop运行超过启动时指明的超时时间 retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(rl)) &#123; /// 被外部调用者手动终止了RunLoop __CFRunLoopUnsetStopped(rl); retVal = kCFRunLoopRunStopped; &#125; else if (rlm-&gt;_stopped) &#123; /// RunLoop被标记为已停止了 rlm-&gt;_stopped = false; retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123; /// 当前Mode中Source/Timer/Observer都被移除了 retVal = kCFRunLoopRunFinished; &#125; &#125; while (0 == retVal); /// 释放RunLoop自身的超时GCD计时器 if (timeout_timer) &#123; dispatch_source_cancel(timeout_timer); dispatch_release(timeout_timer); &#125; else &#123; free(timeout_context); &#125; return retVal;&#125; 值得一提的是CF-855.17版本是CoreFoundation使用mk_timer和GCD计时器的一个过渡版本，源码中有分使用mk_timer和GCD计时器的条件编译，以上代码逻辑的整理中，只参照了使用GCD计时器的源码。 对RunLoop核心代码逻辑的关键流程概述如下： 通知Observer：RunLoop进入Loop； 通知Observer：RunLoop开始处理Timer； 通知Observer：RunLoop即将处理Source0； 执行Source0加入到事件队列中的Block； 如果是主线程RunLoop，检查是否有通过GCD派发给主线程的待处理的Source1： 没有：继续下一步； 有：跳到第9步去处理Source1； 通知Observer：RunLoop即将进入休眠； 休眠，等待被唤醒： 某个基于port的Source1有消息到达； 某个Timer的时间到了； RunLoop为自身设定的超时时间到了； 被其他调用者手动显式唤醒； 通知Observer：RunLoop刚被唤醒； 开始处理未处理的事件： 超时唤醒，不用做任何处理； Timer到时了，处理Timer的事件； 如果是主线程，处理GCD派发过来的事件； 处理基于port的Source1； 通知Observer：已经退出Loop； RunLoop的代码内部是一个do-while循环，循环的执行上述流程的第2-9步，以下情况会导致此次流程后跳出循环，退出RunLoop： 启动RunLoop时的参数指明：执行一遍事件处理流程就退出循环； 超过了启动RunLoop时指定的超时时间； 被外部调用者手动显式的终止了RunLoop； RunLoop被标记为已停止（_stopped）了； 当前Mode中Source/Timer/Observer都被移除了; RunLoop在需要时被唤醒，在不需要时进行休眠，其原理是通过mach_msg( )调用了一个Mach陷阱：mach_msg_trap( )，将线程由用户态切换为内核态，在内核态下等待消息，当有消息到达时又返回用户态进行处理，其逻辑示意如图： 5.系统中对RunLoop的应用Perform SelectorPerform Selector系列方法延迟派发创建的是定时源，派发给其他线程或当前线程异步派发时创建的Source0，再添加到指定线程的RunLoop中。所以如果使用Perform Selector延迟派发、派发给其他线程、以及当前线程异步派发时，要注意判断目标线程的RunLoop是否在运行，如果未运行则派发的任务就不会被执行。 GCD使用GCD为主线程派发任务，会唤醒主线程RunLoop，并对派发的事件进行处理，在每次主线程RunLoop休眠前，还会检查是否有GCD派发过来的事件，如果有，则会跳过休眠，开始对事件进行处理。但以上RunLoop中的逻辑，仅限于主线程中的RunLoop，通过GCD为其他线程派发的任务，则是由libDispatch处理，所以GCD将任务派发给子线程时，也不需要子线程的RunLoop处于运行状态。 UIEvent系统为APP注册了一个Source1用来接收操作系统的事件。当一个硬件事件（触摸/锁屏/摇晃等）发生后，先由IOKit.framework生成一个IOHIDEvent，并由SpringBoard接收，SpringBoard再通过mach_port转发给需要的APP；APP中系统注册的那个Source1接收到mach_port中传递过来的消息后，唤醒主线程RunLoop，在其回调中调用_UIApplicationHandleEventQueue( )进行APP内部的分发；_UIApplicationHandleEventQueue( )中会把IOHIDEvent包装成UIEvent，再通过APP的响应链传递给对应的响应者。 NSTimerNSTimer其实就是CFRunLoopTimerRef，他们之间是toll-free bridged的（Toll-Free Bridged Types）。根据版本不同RunLoop的Timer可能基于内核的mk_timer或者GCD的timer来实现的，Timer并不是绝对准时的，而是有一个宽容度（Tolerance），实际执行的时间可能在这个宽容度允许的误差之内，如果因为执行队列中其他事件造成时间超过了宽容度所允许的误差，那么这次Timer的block不会延后执行，而是会被跳过。 NSTimer默认是添加到RunLoop的kCFRunLoopDefaultMode中的，如果需要NSTimer在RunLoop切换为其他Mode运行时也会正确触发，需要通过kCFRunLoopCommonModes来添加NSTimer。 AutoreleasePoolAPP启动后，系统为主线程RunLoop注册了两个Observer来管理主线程的自动释放池： 第一个Observer只观察kCFRunLoopEntry：在其回调中调用_objc_autoreleasePoolPush( )创建自动释放池； 第二个Observer观察两个事件：在其回调中观察到kCFRunLoopBeforWaiting，会调用_objc_autoreleasePoolPop( )，再调用_objc_autoreleasePoolPush( )，以释放旧池并创建新池；回调中观察到kCFRunLoopExit，会调用_objc_autoreleasePoolPop( )来释放自动释放池； 子线程中的自动释放池会在使用时懒加载，在线程退出时释放，所以一般子线程中也无需考虑内存自动释放的问题，但是如果通过运行子线程的RunLoop来让子线程常驻，可能需要考虑为某些自动释放对象添加自动释放池来避免内存泄漏。 UIKit当更改了UI之后，比如改变了Frame、更新了UIView/CALayer的层次、或手动调用了UIView/CALayer的setNeedsLayout/setNeedsDisplay等，这个UIView/CALayer会被标记为待处理，然后提交到一个全局容器中去。系统为主线程注册了一个Observer来刷新UI，在其回调中，当观察到kCFRunLoopBeforWaiting和kCFRunLoopExit时，会调用一个函数去遍历所有待处理的UIView/CALayer，为它们执行实际的绘制和调整，来完成界面的刷新。 NSURLConnection与NSURLSessionNSURLConnection已经被NSURLSession取代，但底层的部分逻辑却在沿用，同时NSURLConnection对RunLoop的运用也可作为多线程编程设计的参考：开始网络任务时，会为NSURLConnection设置一个delegate，除了这个开始任务时的delegate线程，NSURLConnection又注册了两个新线程com.apple.NSURLConnectionLoader和com.apple.CFSocket.private，三个线程间的消息交流如图所示： CFSocket线程负责处理底层socket连接，NSURLConnectionLoader则负责居中调度。开始一个网络任务时，NSURLConnection创建了4个Source0，并添加到了delegate线程RunLoop的DefaultMode中，NSURLConnectionLoader线程本身通过一个Source1来接收底层CFSocket线程根据网络连接产生的通知，在NSURLConnectionLoader线程的Source1回调中，又通过delegate线程的4个Source0把相关的通知传递给delegate线程，在这些Source0的回调中再执行真正的delegate回调方法。 6.三方库对RunLoop的应用AFNetworking在AFNetworking2.x中通过开启子线程的RunLoop来创建了一条常驻线程，相关代码如下：1234567891011121314151617181920212223242526272829+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@"AFNetworking"]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125; + (NSThread *)networkRequestThread &#123; static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread;&#125;- (void)start &#123; [self.lock lock]; if ([self isCancelled]) &#123; [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; else if ([self isReady]) &#123; self.state = AFOperationExecutingState; [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; [self.lock unlock];&#125; AFNetworking2.x是基于NSURLConnection的，AFNetworking在常驻子线程中异步的start所有NSURLConnection，也在此线程中接收所有NSURLConnection的delegate回调，所以需要子线程常驻。 由于NSURLConnection需要delegate线程保持活跃来接收回调，如果维持一个常驻子线程来管理NSURLConnection的网络请求则开销太大了，在NSURLSession中已经改为指明delegateQueue（NSOperationQueue）来处理网络回调，AFNetworking3.x之后网络请求改为使用NSURLSession，所以也不再需要常驻子线程来处理网络回调了。 值得一提的是NSURLSession的delegateQueue的maxConcurrentOperationCount通常需要设为1，来将代理队列设置为一个串行队列，这是因为即使设置为并发队列，在回调中通常也需要加锁来处理，实际也是串行执行，直接设置为串行队列，则无需再添加加锁等操作。 ReactiveCocoa在RAC的一个Testing方法中，通过如下方法来使用RunLoop： 123do &#123; [NSRunLoop.mainRunLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.1]];&#125; while (!done); 上面代码是用来满足RAC单元测试时的需求：短暂的运行起主线程，以接收通过主线程派发的RACSignal。这种在do-while循环中设置一个超时时间来运行RunLoop的方式值得参考，在现在的ARC下，它其实起到了定时释放旧池（自动释放池）并创建新池的作用（每一次循环，ARC会自动为其添加自动释放池的创建与释放）。 TextureTexture原名AsyncDisplayKit，是一个界面性能优化框架，相较于UIKit把界面元素的创建、绘制、渲染、销毁等任务都在主线程中顺序完成，它把界面显示的相关任务进行了拆分，再把可以放到子线程的任务并发的执行，把可以推迟的任务延后执行，把可以合并的任务合并显示，以此来保证界面的流畅性。 Texture中也有对RunLoop的相关应用，相关逻辑如图所示： Texture把界面元素中必须在主线程完成的部分任务，先封装到一个全局容器中，然后在主线程RunLoop中注册了一个Observer，观察的事件和CoreAnimation的Observer观察的事件相同：kCFRunLoopBeforeWaiting和kCFRunLoopBeforeExit，但回调优先级低于CoreAnimation的回调，这样在RunLoop每次休眠前或退出时，在CoreAnimation的回调处理完成后，Texture再执行自己全局容器中提交的任务，此时这些必须在主线程完成的任务需要依赖的任务，便可能已经异步、并发的完成，此处Texture也完成了将这些异步、并发的操作同步到主线程中去。]]></content>
      <categories>
        <category>APP工作原理</category>
      </categories>
      <tags>
        <tag>RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三、APP的生命周期]]></title>
    <url>%2F2018%2F02%2F17%2FAPP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F%E4%B8%89%E3%80%81APP%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Reference:app的生命周期ios background modes 在知道APP是如何在内存中保持一直运行后之后，接下来需要知道的是APP运行时有哪些主要的状态，以及这些状态是如何切换的。 简述应用程序有 Not Running(未运行)，Inactive(未激活)，Active(激活), Background(后台)，Suspended(挂起)五个状态，当状态即将改变或已经改变时，会发送相应通知并在AppDelegate中会执行相应的回调，开发中需要视需求，在状态变换的回调方法中，添加相应的处理。 概览 要点 Not Running和Suspended是APP未运行时的两种状态，在APP的抽象对象UIApplication的的applicationState中没有这两种状态，也没有相应的通知和AppDelegate回调； 需要注意区分APP在刚启动和返回前台时分别触发的applicationDidBecomeActive:； APP进入后台前会先进入未激活状态applicationWillResignActive:； 一般的APP(没有特殊Background Modes的APP)进入后台有5s时间执行代码，之后会被挂起； 进入后台后通过beginBackgroundTaskWithExpirationHandler:可申请180s的时间 申请后台任务需和结束后台任务endBackgroundTask:需成对出现； 挂起的APP依然在内存中，但可能被系统终止，内存不足时系统优先清理内存大的挂起APP； APP将要被终止(非崩溃)时会调用applicationWillTerminate:，有5s的任务执行时间。 详细APP开始运行之后会根据配置文件info.plist创建APP的抽象对象–UIApplication，这是一个完全单例，在运行期间有且只会有一个，Not Running和Suspended是APP运行期之外的状态，UIApplication对象的applicationState属性中运行时的三种状态：active、inactive和background，当APP运行时的状态将要或已经发生变化时，会发送通知并通过代理模式回调AppDelegate中的方法，由通知接受者或AppDelegate做相应的处理。 ApplicationStateAPP未运行时的两种状态Not Running和Suspended对于编程没多少意义，需要关心的正是UIApplication对象中applicationState的状态切换，需要清楚的有以下几点： APP完成加载前是inactive，完成加载后即进入active状态 回调1：application:willFinishLaunchingWithOptions: 回调2：application:didFinishLaunchingWithOptions: 回调3：applicationDidBecomeActive: APP被中断时会进入inactive状态，结束中断时返回active状态 回调1：applicationWillResignActive: 回调2：applicationDidBecomeActive: 锁屏和home按键也都是中断，所以APP在进入后台前会先进入inactive 回调1：applicationWillResignActive: 回调2：applicationDidEnterBackground: 从后台返回前台，APP会重新进入active状态 回调1：applicationWillEnterForeground: 回调2：applicationDidBecomeActive: 普通APP进入后台一段时间后会被挂起，被挂起的APP可能会被系统终止 回调：applicationWillTerminate: 上述回调方法对应的的APP通知有： UIApplicationDidFinishLaunchingNotification; UIApplicationDidEnterBackgroundNotification UIApplicationWillEnterForegroundNotification UIApplicationDidBecomeActiveNotification; UIApplicationWillResignActiveNotification; UIApplicationWillTerminateNotification; Background ModesAPP进入后台后可以按创建时指定的特殊后台运行模式运行，APP可以拥有多种后台运行模式，但审核时如果被认为APP无需所声明的后台运行模式，则审核会被拒。后台模式可以通过info.plist中的Required background modes进行配置，也可以通过Capabilities-&gt;Background Modes进行配置(推荐方式)，APP的后台模式如下： Audio, AirPlay and Picture in Picture info.plist key: App plays audio or streams audio/video using AirPlay 音频播放、录制、使用AirPlay投放，画中画(iPad)，此类APP可以后台常驻 Location updates info.plist key: App registers for location updates 后台获取定位更新，此类APP也可以后台常驻 Voice over IP info.plist key: App provides Voice over IP services IP电话，此类APP同样会被挂起，但系统会接管其通信socket，当socket中有数据传来时，会唤醒APP并交回socket Newsstand downloads info.plist key: App processes Newsstand Kit downloads 杂志类应用，此类APP会被挂起和终止，但可使用NKAssetDownload后台下载杂志，并在下载成功后重新唤醒或启动APP External Accessory communication info.plist key: App communicates with an accessory 与MFi外设通信类APP，在外设消息到达时APP会被唤醒，有10s的执行时间 Uses Bluetooth LE accessories info.plist key: App communicates using CoreBluetooth 与Bluetooth LE设备通信类APP，在设备的消息到达时会被唤醒，有10s的执行时间 Acts as a Bluetooth LE accessory info.plist key: App shares data using CoreBluetooth 自身作为蓝牙外设的应用，此类APP可以后台常驻，但需要用户授权 Background fetch info.plist key: App downloads content from the network 后台定时更新，设置时间间隔，在间隔时间内启动应用更新数据，有30s执行时间 Remote notifications info.plist key: App downloads content in response to push notifications 静默推送，在静默推送到底时，回调对应方法下载内容，有30s执行时间 Background processing info.plist key: App processes data in the background 基于NSURLSession的后台传输，任务成功或失败时，APP会被唤醒并执行application:handleEventsForBackgroundURLSession:completionHandler:回调]]></content>
      <categories>
        <category>APP工作原理</category>
      </categories>
      <tags>
        <tag>APP生命周期</tag>
        <tag>Background Modes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、APP的加载过程]]></title>
    <url>%2F2018%2F01%2F07%2FAPP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F%E4%BA%8C%E3%80%81APP%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Reference:iOS 底层 - 从头梳理 dyld 加载流程iOS进阶 – 程序启动那些事Dyld系列之一：_dyld_start之前DYLD动态链接器dyld与ObjC从 dyld 到 runtime ExecutableAPP的加载过程就是APP中可执行文件的加载过程，了解这个加载过程之前需要先了解iOS中的可执行文件。MacOS中可以使用chmod+x命令来赋予一个文件可执行权限，但实际上可以执行的文件只有两类，第一类是脚本文件，第二类是可执行二进制文件，可执行二进制文件又分为Mach-O和Fat Binary，它们之间的区别如下： 脚本文件：脚本文件是以#!开头的文本文件，执行时会由shell根据#!后面指明的地址，找到脚本解释器，然后由脚本解释器，对文件中的脚步代码，进行解释执行； Mach-O：Mach-O是以魔数0xfeedface(32位) 或0xfeedfacf(64位)作为文件头的二进制文件，Mach-O有多种type，可执行文件的type是Executable（MH_EXECUTE），运行一个可执行的Mach-O时，系统会fork一个新进程，然后执行execve调用，解析Mach-O，执行其中的的Load Commands，启动动态链接器dyld，链接主程序与依赖库，最终得到一个新的进程镜像，在内存中运行； Fat Binary：Fat Binary就是针对不同芯片架构的Mach-O（Executable）的集合，是以魔数0xcafebabe（小端）或0xbebafeca（大端）为文件头的二进制文件，执行时根据Fat Header找到当前架构的Mach-O，再解析并加载对应的Mach-O； iOS中的App在不使用BitCode的情况下，其内部的二进制文件是一个Fat Binary，使用BitCode时，App中是与设备的芯片架构所对应的Mach-O，它们在App启动时，最终都是解析并加载一个Mach-O。 Fat Binary的大端模式和小端模式：大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中；小端模式，则是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。 Mach-OMach-O的文件结构如图： Mach-O主要由Header、Load Commands和Data所构成： Header：包含魔数、芯片类型与子类型、文件类型、加载命令数量与大小、动态链接器标识、字节顺序等信息； Load Commands：程序的加载命令，包括段与进程地址的映射、指定动态链接器、指明需要动态链接的库等等； Data：程序的原始数据段，包括_TEXT、_DATA等，加载时被映射到进程的内存空间中。 Load CommandsMach-O中Load Commands部分是程序的加载命令，这些加载命令在内核在执行execve调用时，完成对Mach-O的文件解析之后，有的由内核直接执行，有的则由动态链接器处理，这部分可以参考文章—Mach-O文件介绍之loadcommand，下面列出一些常见的加载命令及其含义： 命令 含义 LC_SEGMENT 将数据段映射到地址空间中 LC_DYLD_INFO_ONLY 动态链接相关信息 LC_SYMTAB 符号表地址 LC_DYSYMTAB 动态符号表地址 LC_LOAD_DYLINKER 动态链接器 LC_UUID 文件的唯一标识 LC_VERSION_MIN_IPHONEOS 支持的最低iOS版本 LC_SOURCE_VERSION 源码版本 LC_MAIN 设置进程的主线程入口地址和栈大小 LC_ENCRPYTION_INFO 加密信息 LC_LOAD_DYLIB 加载动态库 LC_LOAD_WEAK_DYLIB 弱加载动态库（不因库不存在而中止） LC_FUNCTION_STARTS 函数起始地址表 LC_CODE_SIGNATURE 代码签名信息 DyldExecutable类型的Mach-O的Load Commands中通过LC_LOAD_DYLINKER指明了程序的动态链接器，MacOS/iOS中默认的动态链接器是dyld（/usr/lib/dyld），dyld主要负责将主程序及其依赖库加载为镜像文件（images），并链接这些镜像文件，dyld的代码是开源的，本文中引用的源码是732.8版本。 _dyld_startdyld本身也是一个Mach-O，类型为MH_DYLINKER，在execve的调用中，完成主程序Mach-O的解析后，根据其中的LC_LOAD_DYLINKER，由内核解析并加载dyld，根据dyld的LC_UNIXTHREAD得到dyld的entry_point，即_dyld_start函数，然后通过_dyld_start执行dyld程序，开始dyld的工作。 从execve到_dyld_start的函数调用栈大致如下： 12345678910▼ execve // 启动app时, 用户态发送一个系统调用execve到内核 ▼ __mac_execve // 创建线程 ▼ exec_activate_image ▼ exec_mach_imgact ▼ load_machfile ▶︎ parse_machfile // 解析主程序的Mach-O ▼ load_dylinker // 解析完Mach-O后，根据LC_LOAD_DYLINKER所指定的地址（/usr/bin/dyld）启动动态链接器 ▼ parse_machfile // 解析dyld的Mach-O，根据它的LC_UNIXTHREAD得到dyld的entry_point，即_dyld_start ▼ activate_exec_state ▶︎ thread_setentrypoint // 设置entry_point，开始执行_dyld_start start_dyld_start中调用了start函数，start中主要是完成一些dyld的引导工作，包括rebaseDyld、栈溢出保护、获取主程序的ASLR随机数等，在start的末尾调用并返回了_main函数： 1234567891011121314151617181920212223uintptr_t start(const dyld3::MachOLoaded* appsMachHeader, int argc, const char* argv[], const dyld3::MachOLoaded* dyldsMachHeader, uintptr_t* startGlue)&#123; dyld3::kdebug_trace_dyld_marker(DBG_DYLD_TIMING_BOOTSTRAP_START, 0, 0, 0, 0); rebaseDyld(dyldsMachHeader); const char** envp = &amp;argv[argc+1]; const char** apple = envp; while(*apple != NULL) &#123; ++apple; &#125; ++apple; __guard_setup(apple);#if DYLD_INITIALIZER_SUPPORT // run all C++ initializers inside dyld runDyldInitializers(argc, argv, envp, apple);#endif uintptr_t appsSlide = appsMachHeader-&gt;getSlide(); return dyld::_main((macho_header*)appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);&#125; _main内核通过_dyld_start开始执行dyld程序，再调用start函数完成引导工作，最后调用_main函数开始执行dyld程序，_mian函数是dyld实际的逻辑入口，源码中对于_main函数的注释如下： 123456//// Entry point for dyld. The kernel loads dyld and jumps to __dyld_start which// sets up some registers and call this function.//// Returns address of main() in target program which __dyld_start jumps to// _main中所做的工作较多，大体上可以分为以下几步： 1. 加载共享缓存库在加载共享缓存库之前，_main函数中会先设置运行环境，设置运行环境的工作包括包括： 配置环境变量，将传入的参数赋值给一些环境变量； 设置上下文信息setContext，包括一些回调函数、参数、标志信息等； 检测进程是否受限configureProcessRestrictions； 根据环境变量配置打印信息DYLD_PRINT_OPTS、DYLD_PRINT_ENV； 获取程序的架构信息getHostInfo； 在设置了运行环境之后，_mian函数中通过mapSharedCache再调用了loadDyldCache函数，已确保共享缓存库已被加载： 123456789101112131415161718192021222324252627bool loadDyldCache(const SharedCacheOptions&amp; options, SharedCacheLoadInfo* results)&#123; results-&gt;loadAddress = 0; results-&gt;slide = 0; results-&gt;errorMessage = nullptr;#if TARGET_OS_SIMULATOR // simulator only supports mmap()ing cache privately into process return mapCachePrivate(options, results);#else if ( options.forcePrivate ) &#123; // mmap cache into this process only return mapCachePrivate(options, results); &#125; else &#123; // fast path: when cache is already mapped into shared region bool hasError = false; if ( reuseExistingCache(options, results) ) &#123; hasError = (results-&gt;errorMessage != nullptr); &#125; else &#123; // slow path: this is first process to load cache hasError = mapCacheSystemWide(options, results); &#125; return hasError; &#125;#endif&#125; 共享缓存库：实际上就是一个iOS系统动态库的集合，iOS中的系统动态库可以被不同的App所共享，所以系统动态库只需要在第一个App使用它时被加载，后续的App使用时，使用它第一次加载后在内存中的缓存即可，但每个App使用到的系统动态库较多，如果使用到的系统动态库需要逐个的去判断并加载的话，对App的启动速度依然有较大的影响，于是iOS中便将常用的系统动态库都合并到了一个较大的缓存文件中，这样所有App对系统动态库的使用，都只需要确保这个缓存文件已经被加载到了内存中即可，这个缓存文件就是共享缓存库，关于共享缓存库可以参考链接。 共享缓存区与共享缓存库：动态库又被称为共享库，它们会被加载到内存的共享缓存区，供不同的进程共享，共享缓存库是常用系统动态库的集合，它也会被加载到共享缓存区，供所有的进程所共享，但共享缓存区不止共享缓存库，它还可能存在App的Embedded Framework，Embedded Framework不能与外部的App共享，但可以与自己的Extension等共享。 2. 实例化主程序 App使用到的二进制可执行文件都需要被加载、解析并实例化为内存镜像，每一个Mach-O都对应一个镜像实例。实例化主程序就是生成主程序的镜像，主程序二进制文件的读取和解析是在execve中完成的，然后作为参数传递给dyld的，在dyld的_main中通过instantiateFromLoadedImage将主程序实例化为镜像，再添加到全局的镜像列表中。 1234567891011static ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)&#123; // try mach-o loader if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123; ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext); addImage(image); return (ImageLoaderMachO*)image; &#125; throw "main executable not a known format";&#125; 3. 加载插入库这一步是将环境变量DYLD_INSERT_LIBRARIES中配置的动态库加载到内存中，先判断环境变量DYLD_INSERT_LIBRARIES中是否有需要插入的动态库，如果有存在则调用loadInsertedDylib来依次加载，利用DYLD_INSERT_LIBRARIES环境变量是MacOS和iOS上非常知名的一种注入技术，通常越狱插件就是基于此来注入到应用中。 12345// load any inserted libraries if ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123; for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib); &#125; Inserted Libraries与Embedded Framework：iOS的App在启动时涉及三类动态库，首先是System Libraries（系统动态库），它们被合并到共享缓存库中，在加载到手机内存之后，由所有App所共享；然后便是Inserted Libraries，它们在启动过程中主程序实例化之后，根据DYLD_INSERT_LIBRARIES环境变量依次进行加载，越狱设备中安装的应用插件通常就是这类动态库；最后便是Embedded Framework，它们是由开发者创建的，属于App自己的动态库，iOS8之前的iOS App是不能有自己的动态库的，在iOS8之后为了满足App和Extension之间代码共享的需求，于是便有了Embedded Framework的概念，它们不能与外部App共享，在App启动过程中链接主程序时，根据LC_LOAD_DYLIB命令和依赖关系递归的加载到内存中。除了这些启动时加载的动态库，MacOS的App还可以通过dlopen()在运行时加载动态库插件，但这在iOS的App提交审核时是被禁止的。 4. 链接镜像_main函数中调用link来链接程序的镜像，启动时先链接主程序再链接插入库，通常link函数链接一个镜像时有三项主要的工作：递归的加载依赖库（App的Embedded Framework的实例化）、递归的Rebase和递归的Binding，这里732.8版本的源码与更早版本源码的做法有些许差异，它将主程序和插入库链接时的Binding先暂时跳过了，放在了主程序和插入库都链接完成之后再进行： 1234567891011121314151617181920212223242526272829303132333435void ImageLoader::link(const LinkContext&amp; context, bool forceLazysBound, bool preflightOnly, bool neverUnload, const RPathChain&amp; loaderRPaths, const char* imagePath)&#123; ... uint64_t t0 = mach_absolute_time(); uint64_t t0 = mach_absolute_time(); // 1. 递归的加载镜像的依赖库 this-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath); context.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly); ... uint64_t t1 = mach_absolute_time(); context.clearAllDepths(); // 递归刷新依赖库的层级 this-&gt;recursiveUpdateDepth(context.imageCount()); __block uint64_t t2, t3, t4, t5; &#123; dyld3::ScopedTimer(DBG_DYLD_TIMING_APPLY_FIXUPS, 0, 0, 0); // 递归的进行Rebase t2 = mach_absolute_time(); this-&gt;recursiveRebaseWithAccounting(context); context.notifyBatch(dyld_image_state_rebased, false); // 递归的进行Binding（主程序和插入库link时会跳过） t3 = mach_absolute_time(); if ( !context.linkingMainExecutable ) this-&gt;recursiveBindWithAccounting(context, forceLazysBound, neverUnload); // 递归的进行弱绑定（主程序和插入库link时会跳过） t4 = mach_absolute_time(); if ( !context.linkingMainExecutable ) this-&gt;weakBind(context); t5 = mach_absolute_time(); &#125; ...&#125; Rebase：为了增加攻击者对程序内部地址预测的难度，程序在加载到内存中时会有一个随机的地址偏移值，这项安全技术被称为ASLR（iOS中的ASLR可参考链接），因为这个随机偏移的存在，在程序每次加载到内存后都需要对内部代码中的地址做修正，启动过程中这步操作被称为Rebase，它是修复指向当前镜像内部的地址。 5. 符号绑定符号绑定包括binding和weak binding，先进行binding，再是weak binding，从源码中可以看出Binding的耗时统计并不包括weak binding： 1234567891011121314151617// Bind and notify for the main executable now that interposing has been registereduint64_t bindMainExecutableStartTime = mach_absolute_time();sMainExecutable-&gt;recursiveBindWithAccounting(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, true);uint64_t bindMainExecutableEndTime = mach_absolute_time();ImageLoaderMachO::fgTotalBindTime += bindMainExecutableEndTime - bindMainExecutableStartTime;gLinkContext.notifyBatch(dyld_image_state_bound, false);// Bind and notify for the inserted images now interposing has been registeredif ( sInsertedDylibCount &gt; 0 ) &#123; for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123; ImageLoader* image = sAllImages[i+1]; image-&gt;recursiveBind(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, true); &#125;&#125; // do weak binding only after all inserted images linkedsMainExecutable-&gt;weakBind(gLinkContext); Binding： 通常一个程序中都会包含对外部地址的引用，比如对动态库的使用，动态库不会在编译时被合并到程序中，运行时有自己的地址空间，所以无法在编译时就确定对其相关引用的具体地址，于是就有了PIC（Position Independent Code）技术：程序中指向外部的地址，在编译时先被设置为符号地址，在加载时再根据外部镜像的符号表等信息，重新把符号地址绑定为实际的地址，启动过程中符号地址重新绑定这步操作被称为Binding，它是绑定指向当前镜像外部的地址。 6. 初始化主程序_main函数调用initializeMainExecutable函数来初始化程序，初始化时先初始化插入库中的根镜像，再初始化主程序。镜像通过调用recursiveInitialization方法进行初始化，recursiveInitialization中会根据依赖关系递归的先执行依赖库的初始化工作。 Xcode中可以通过配置环境变量DYLD_PRINT_INITIALIZERS=1来打印各个依赖库的初始化方法及其调用顺序，可以发现libSystem的初始化方法始终是最先调用的。 Objc_init程序中镜像在初始化时会递归的先进行依赖库的初始化工作，从dyld的源码中可以得知，在没有插入库的情况下，libsystem通常会是第一个进行初始化的库，而libsystem的初始化方法中则调用了runtime的初始化方法_objc_init： 123456789101112131415void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);&#125; _objc_init中调用dyld的_dyld_objc_notify_register注册了三个回调方法，来接收dyld加载镜像相关事件的回调，以完成对每个镜像中的Objc相关部分的处理： 12345678910111213141516171819202122232425262728293031void _dyld_objc_notify_register(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)&#123; dyld::registerObjCNotifiers(mapped, init, unmapped);&#125;void registerObjCNotifiers(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)&#123; // record functions to call sNotifyObjCMapped = mapped; sNotifyObjCInit = init; sNotifyObjCUnmapped = unmapped; // call 'mapped' function with all images mapped so far try &#123; notifyBatchPartial(dyld_image_state_bound, true, NULL, false, true); &#125; catch (const char* msg) &#123; // ignore request to abort during registration &#125; // call 'init' function on all images already init'ed (below libSystem) for (std::vector&lt;ImageLoader*&gt;::iterator it=sAllImages.begin(); it != sAllImages.end(); it++) &#123; ImageLoader* image = *it; if ( (image-&gt;getState() == dyld_image_state_initialized) &amp;&amp; image-&gt;notifyObjC() ) &#123; dyld3::ScopedTimer timer(DBG_DYLD_TIMING_OBJC_INIT, (uint64_t)image-&gt;machHeader(), 0, 0); (*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader()); &#125; &#125;&#125; 关于处理镜像中Objc相关信息的三个回调方法： map_images：在镜像完成加载（即加载进内存中）后被调用，通过_read_images函数完成对镜像中Objc的类、协议、类别等的初始化工作； load_images：在镜像的初始化完成后被调用，主要是调用镜像中各种Objc类的+load方法，完成Objc类的加载； unmap_image：在移除镜像时被调用，主要是做镜像的Objc相关信息的清理工作。 libsystem的初始化时调用_objc_init才注册Objc的处理回调方法，这时主程序和插入库，以及它们依赖库的镜像都已经加载到内存中，所以在**注册回调的方法时，就触发了一次map_images来批量的初始化已加载镜像中的Objc信息，然后也循环的触发了load_images，来加载那些在libsystem初始化之前就已经随镜像载入内存中的Objc类。 7. 返回主程序入口最后dyld的_main函数会根据不同的情况，查找到对应的主程序入口（通常是主程序中的main函数地址）作为返回值返回，这个值最终会返回给一开始fork创建的进程，进程据此跳转到主程序入口继续运行，主程序中的代码便开始执行。]]></content>
      <categories>
        <category>APP工作原理</category>
      </categories>
      <tags>
        <tag>Mach-O</tag>
        <tag>加载</tag>
        <tag>启动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、APP的编译过程]]></title>
    <url>%2F2017%2F12%2F23%2FAPP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F%E4%B8%80%E3%80%81APP%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Reference:iOS App 的编译过程深入剖析 iOS 编译 Clang / LLVM关于bitcode, 知道这些就够了Mach-O 与静态链接 Xcode BuildXcode Build时以一个Target作为Build目标，当Target是一个iOS项目时，其实就是App的打包过程，除了对源代码文件进行编译，Xcode还做了很多其他的工作，主要包括： 准备Build环境：创建Build目录，写入辅助文件，创建目标包（.app)； 处理依赖项：如果依赖其他Target，会先Build所依赖的Target； 运行编译前脚本：如Cocoapods的Check Pods Manifest.lock； 使用LVVM编译Target中的源代码文件，并进行静态链接，生成Mach-O； 编译xib并将结果和图片等资源文件拷贝到目标包； 编译storyboard、ImageAssets，并将结果拷贝到目标包； 处理Info.plist文件、生成符号表文件dSYM； 运行编译后脚本：如Cocoapods的编译后脚本，会将Pods中编译好的依赖库和资源文件拷贝到目标包； 生成App包，并对包进行签名； 一个Target可以依赖其他Target（比如Tests Target依赖主Target），Build时会先Build依赖的Target，这是一个递归的过程。 Clang/LLVMXcode的Build过程中，对源代码文件的编译是由Clang/LLVM（或Swift/LLVM）来完成的，LLVM是编译器基础设施，LLVM将编译器分为前端（Frontend）、优化器（Optimizer）和后端（Backend），前端负责将各种语言转换为LLVM IR（中间代码），优化器负责对LLVM IR进行优化，后端则负责将LLVM IR转换为机器代码，生成二进制文件。 在LLVM的架构中，针对不同的语言，可以有不同的编译器前端，优化器也可以添加自定义优化节点（pass），针对不同的芯片架构则会有不同的编译器后端。Clang是基于LLVM的、针对C/C++/Objective-C的编译器前端，Xcode中使用Clang/LLVM对Target的源代码文件进行编译时，其工作步骤包括： 预处理：由Clang进行宏替换、头文件导入等； 词法分析和语法分析：由Clang生成符号表、生成抽象语法树AST； 生成IR：由Clang根据AST生成LLVM IR； 优化IR：Xcode中可以设置优化级别，开启bitcode，苹果还会做额外的优化工作； 根据LLVM IR生成汇编，优化后再转为机器代码，得到目标文件（Object File）； 对目标文件进行静态链接，生成Mach-O或Fat Binary（Mach-O的集合）； 一个Mach-O是针对某一特定芯片架构的二进制文件，Fat Binary就是Apple将针对不同芯片架构的多个Mach-O合并后得到的通用二进制文件。 BitCode由于Fat Binary会使用户下载的二进制文件中包含大量和当前设备芯片架构无关的内容，于是在Xcode 9之后Apple推出了基于BitCode的二进制文件瘦身方案，作为整个iOS安装包瘦身技术中的一环：BitCode是对LLVM IR进一步优化后再编码所得到的中间二进制文件，开启BitCode之后，Xcode在打包上传到App Store的构建文件中，二进制文件不再是Fat Binary，而是包含BitCode的Mach-O，提交到App Store后，再由App Store负责提取出BitCode，然后针对不同的芯片架构编译、链接、生成对应的Mach-O，这样当用户下载时，App中就只包含当前芯片架构所对应的Mach-O。 BitCode在整个编码过程所处的位置如图： 开启BitCode来进行App打包上传时，需要注意以下几点： BitCode一致性：要求App所依赖的库也必须支持BitCode，否则就会打包失败，比如App中如果使用了不支持BitCode的三方静态库（例如某些以.a形式提供的三方闭源库），就不能使用BitCode打包上传； 下载dSYM文件：符号表文件dSYM是在生成最终二进制文件后再生成的，使用BitCode时，这一步由App Store完成，所以App的dSYM文件需要到Xcode -&gt; Organizer中下载； Build ConfigureXcode中可以通过Build Pahses、Build Rules和Build Settings来控制Build的过程。 1. Build PhasesBuild Phases控制Build各阶段的工作内容，主要的Phases有： Dependencies：指定当前Target的依赖项目，可以是其他Target，Build时会先Build所依赖的项目； Headers：当Build结果的Mach-O Type是Dynamic Library或静态库Static Library时，可以在Build Phases中添加Headers Phase来指明公开的头文件； Compile Sources：所有需要编译的源代码文件，Build时会根据Build Rules和Build Settings中设置的规则进行编译，这儿也可以为单个文件添加编译参数，如-fno-objc-arc； Link Binary With Libraries：Target需要链接的静态库和动态库，它们会和编译生成的目标文件进行链接； Copy Bundle Resource：需要编译后拷贝到包中的资源文件，包括xib、storyboard、ImageAssets等等； 以上的主要Phases在Build过程中有且只有一个，除了主要的Phases，还可以按需要为Target的Build过程添加一个或多个可选的Pashes: Copy Files Phase：将指定文件拷贝到Build所生成的目标包（.app）中； Run Script Phase：执行脚本程序，例如Cocoapods的Check Pods Manifest.lock和Copy Pods Resources都是通过此方式插入到Build过程中的； 2. Build Rules在Build Rules中，可以通过更改相应脚本来对不同文件进行自定义处理，包括自定义的编译、拷贝、压缩等等。Build Rules中还罗列了Xcode对不同文件的默认处理方式，可以Copy to Target后进行自定义编辑。 3. Build SettingsBuild Settings是对Build过程中各个阶段的命令参数的设置，内容非常的繁杂，有一千项左右，在网站Xcode Build Settings上有各项的简要介绍。 Mach-O TypeMach-O是iOS/MacOS中的二进制文件，是由源码经编译再链接所生成的，同时也是Xcode所生成的应用包中最重要的产物。Mach-O又分为不同的类型，在mach-o/loader.h文件中定义了Mach-O的细分类型，从应用开发的角度，只需要关心Xcode将其生成的Mach-O所分为的五种类型即可： Executable：可单独执行的二进制文件，即可执行文件，必须有main方法作为执行入口，App打包所生产的二进制文件即为此类型； Dylib Library：动态库链接文件，打包动态库时需要注意在Build Phases中指明Headers； Static Library：静态库链接文件，打包静态库时同样需要指明Headers； Bundle：独立的动态库，同时还包含资源文件，不会被链接，需要显示加载，可在运行时通过dlopen()或NSBundle的-load方法进行加载。MacOS中可作为应用程序的插件，iOS中可通过Bundle打包资源文件，然后在Copy Bundle Resource中拷贝到App中，不过作为资源包时，Bundle中的二进制文件需要被删除； Relocatable Object File：可重定向的目标文件，即未进行静态链接的目标文件的集合，打包静态库时可选此类型，这样可以避免程序中多个静态库都依赖相同的静态库时，被依赖的静态库被重复的拷贝到程序中； Xcode中，在Build Settings -&gt; Mach-O Type中可以指定编译所生成的Mach-O的类型； 静态库与动态库源代码文件经编译所生成的二进制文件，除可执行文件之外，根据其是在编译时被链接到程序中，还是运行时被加载到程序中，又可以分为静态库和动态库，关于iOS/MacOS中的静态库和动态库，需要了解的有以下几点： Framework：framework是Xcode的一种代码打包方式，framework中包括Mach-O文件、头文件、以及相关的资源文件，根据生成的Mach-O类型的不同，framework可以是动态库，也可以是静态库。 静态库：静态库主要由头文件和二进制文件所组成，在iOS/MacOS中静态库的二进制文件可以是.a文件，也可以是Static Library和Relocatable Object File对应的Mach-O文件。程序引用的静态库，会在编译期的静态链接时被链接到目标程序中，使用静态库会使目标程序体积增大，但不会让程序对外部产生依赖。 动态库：动态库也主要由头文件和二进制文件所组成，iOS/MacOS中动态库的二进制文件为.dylib、.tbd、或者Dylib Library和Bundle对应的Mach-O。程序引用的动态库会在程序运行时（启动时或启动后）被加载，并与程序动态链接，使用动态库不会使程序体积增大，同时动态库也可以独立的升级替换，但使用动态库也让程序对外部产生了依赖，同时动态库的加载也会造成一定的性能损失。 Embedded Framework：出于安全考虑，iOS的App之间不允许使用非官方的动态库，但在iOS 8之后App可以有extension，App和extension是两个不同的进程，它们之间有代码共享的需求，于是便有了Embedded Framework，它可以被视为一种“沙盒动态库”，只在一个App及其extension之间被共享。 Swift Static Libraries：Xcode9之后是支持将Swift代码打包成静态库的framework来使用的，在Xcode9之前因为Swift的运行库不成熟，其并未被作为系统动态库所使用，Xcode打包Swift静态库时，会将Swift的运行库静态链接到所生成的静态库中，如果App使用了多个Swift静态库，就会造成App中Swift运行库的重复，Xcode9之后Swift的运行库已经被加入到系统动态库中，已不在有此限制。]]></content>
      <categories>
        <category>APP工作原理</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>Mach-O</tag>
        <tag>BitCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法基础]]></title>
    <url>%2F2017%2F11%2F17%2F%E5%AE%9E%E7%94%A8%E7%AC%94%E8%AE%B0%2FMarkdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Reference:Mardown语法说明 Markdown的宗旨：Markdown的目标是实现易读易写。可读性无论如何都是最重要的。 与HTML的兼容Markdown对HTML兼容，Markdown之外的标签可以使用HTML撰写。需要注意的是HTML区块标签需要在前后加上空行和其他内容隔开，且要求开始和结尾标签不能用制表符(tab)或空格来缩进。在HTML区块标签间的Markdown格式语法不会被处理，但Markdown语法在HTML区段标签间是有效的，同时HTML区段标签也可以在Markdown段落中直接使用，。 &amp;与&lt;在Markdown的HTML区段中的如果出现这两个特殊字符，Markdown在转换时会将其自动转换为HTML的实体。 区块元素链接Markdown的链接有行内式和参考式两种，行内式易写，参考式易读。 行内式链接语法为中括号+小括号，中括号中是链接文字，小括号内为链接和title（title在鼠标悬停在链接上显示的提示信息），链接可以为同一主机的相对地址，title用双引号包起来，title可有可无。 链接使用+地址定义： This is [an example](http://example.com/ &quot;Title&quot;) inline link. 参考式链接语法为中括号+中括号，第二个中括号中为链接的标识，然后在任何位置（一般为文末或者段后）用标记:链接地址+&quot;title&quot;的方式将链接内容定义出来即可，链接标识不区分大小写，可以为空，为空时为隐式标识，即标识为前面中括号中的内容。 链接使用： This is [an example][id] reference-style link. 地址定义： [id]: http://example.com/ &quot;Optional Title Here&quot; 强调Markdown可为段落中的文字加斜体、粗体和删除线三种方式来进行内容强调。方法是为要强调的文字前后分别加*、**和~~，其中斜体和粗体分别会为文字加上&lt;em&gt;和&lt;strong&gt;标签。 代码如果要标记一小段的行内代码，可以使用反引号`将其包起来，如果要在代码段中使用反引号，可以使用一个以上的反引号的开始和结束代码段:代码段中有`。行内代码中的&amp;和&lt;&gt;同样会被转换为对应的HTML实体。 图片插入图片和插入连接的语法基本相同，也分为行内式和参考式，区别是插入图片需要在前面加上!，第一个[]中是图片的替代文字，并不会显示。Markdown不支持指定图片宽高，如果有需求可以使用HTML的&lt;img&gt;标签。 区段元素段落和换行Markdown的段落由一个或多个连续的文本行组成，一个段落的前后要求各有至少一个的空白行。Markdown允许段落中换行（插入换行符），并不会把换行符都转换为&lt;br /&gt;,连按两个空格再换行，Markdown才会将此换行符转为&lt;br /&gt;。 标题Markdown的标题支持Setext（底线）和atx两种形式的标题，但一般使用atx形式，即在行首插入1~6个#，对应1~6阶标题。 区块引用Markdown使用&gt;标记区块引用，Markdown允许只在段落的首行添加&gt;标记，同时区块引用可以嵌套，添加不同数量&gt;即可，而且在区块内也可以使用Markdown语法。 区块（示例） 三级区块 列表 Markdown的列表可分为有序列表和无序列表。有序列表使用数字接一个英文句点作为标记，数字可以是乱序的（会自动排），但最好保持有序。无序列表使用*,+和-作为标记，他们的功能一样，建议在做列表嵌套时使用不同的标记来做区分。第一级的列表标记一般放在最左边，但也可以缩进（最多3个空格，4个空格=一个tab，会被视为嵌套）。 注意：如果列表项目间用空行分开，在输出HTML时项目内容将会用&lt;p&gt;标签包起来。 列表的项目下允许有多个段落，每个项目下的段落都必须缩进一个tab。 列表项目中可以嵌套区块引用，需要在区块前加空行，并对区块进行一个tab的缩进，如下： 嵌套的区块 列表项目中还可以嵌套代码块，代码块需要前面加空行，并进行两个tab的缩进，如下： // 这就是代码 printf(&quot;hello, world&quot;); 列表下也可以嵌套表格 |左对齐标题 |右对齐标题 |居中对齐标题 | |:– |–: |:–: | |短文本 |中等文本 |稍微长一点的文本 | |稍微长一点的文本|短文本 |中等文本 | 如果一定会在句首出现数字+句点+空白，那么可以在句点前加上反斜杠\。 表格和其他区块一样，表格前也需要有空白行，使用|来区分列，第一行为标题，第二行指明同一列的文字对齐方式:--表示左对齐，--:表示右对齐，:-:表示居中对齐，---表示默认对齐方式，即标题居中内容靠左。表示对齐的符号可以有多个-，但-和:加起来要不少于三个。示例： 左对齐标题 右对齐标题 居中对齐标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 代码区块Markdown中使用一个tab的缩进和一个段落（前后加空行）即可插入代码块，代码块会持续到没有没有缩进的那一行,也可以不使用缩进，而是在代码块的前后加上各加一行三个（或以上）反引号`。在转换的时候，Markdown会将代码用&lt;pre&gt;和&lt;code&gt;标签包起来，在代码块中，Markdown语法不会被转换，而缩进的制表符也会被移除，同时&amp;、&lt;和&gt;这种HTML特殊符号也会自动转为HTML实体，例如： &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 分隔线可以使用三个及以上的*、-和减号来建立一个分隔线，分隔线行内不能有其它东西（*和-之间可以插入空格），例如： 分隔线还有分隔出单独一段的效果，为了避免直接在文字后加-，而和Setext（底线）标题语法混淆，分隔线前应留一个空白行，或建议使用****。 其他自动链接Markdown支持用比较简短自动链接形式来处理网址和电子邮箱，只需要用尖括号包起来即可。如邮箱&#x79;&#111;&#x75;&#120;&#105;&#x61;&#x6e;&#x67;&#x40;&#113;&#113;&#x2e;&#99;&#x6f;&#109;，网址http://www.baidu.com。值得一提的是邮箱地址的字符会被Markdown转换为对应的16进制码的HTML实体，以防御一些邮箱收集机器人。 反斜杠Markdown中的语法符号要直接显示而不表示语义的时候，可以在符号前面加\来转义。对应的符号有： \ 反斜杠 ` 反引号 * 星号 _ 底线 {} 大括号 [] 中括号 () 小括号 # 井号 + 加号 - 减号 . 英文句点 ! 惊叹号]]></content>
      <categories>
        <category>实用笔记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
