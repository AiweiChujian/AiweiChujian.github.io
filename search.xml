<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[APP架构（六）--网络]]></title>
    <url>%2F2019%2F01%2F20%2FAPP%E6%9E%B6%E6%9E%846-%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[Reference:《AppArchitecture》 添加网络的挑战为程序添加网络支持时，会面临一些额外的挑战，这不是某个架构所特有的问题，也和本节中对于网络层如何架构的讨论无关，但是对于一款需要从网络中获取数据的APP，或多或少都需要清楚对于这些问题的思考： 额外的失败来源：任何从网络获取数据的尝试，都可能由于一系列的理由以失败而告终。我们必须考虑如何优雅地处理这些错误，而且经常还要为展示这些错误创建额外的UI。 获取最新数据副本：持续从网络监听数据要比观察本地数据困难得多，这往往导致我们需要周期性地手动获取数据。 多端间的数据冲突：网络引入了多端更新同一个数据的可能性，这可能导致潜在的冲突。网络上的数据可能会有独立于app的更改、引用的资源可能会在不通知客户端的情况下直接失效、两个客户端有可能更新了同样的对象。 对于两个客户端更新了同样的对象，这必须让服务器从两者间选择出哪一个应该胜出，并且告诉每一个客户端冲突的解决方案，可以参考iCloud关于解决文档冲突的方式和相关思考。 添加网络层的方式为APP添加网络层有两种常见的方式： Controller层持有网络：将model层移除，并让controller来处理网络请求。数据直接从网络获取，从网络获得的数据不会被持久化，而是由controller负责将它们以处理view state相同的方式缓存在内存中。这种方式非常的简单直接，主要问题在于不同的controller之间进行数据共享变得非常麻烦。 Model层持有网络：保留model层，并在model的下方加入了一个网络层。model负责触发和管理网络请求，并按照需要用请求的结果来更新model，model的变更依然通过观察者模式传递给controller。在这种方式中，封装的网络服务可以提供接口直接由model层调用，也可以观察model的变更然后进行数据同步的网络活动，后者model层和网络层之间的耦合更低；因为保留了model层，利于不同controller间数据共享的同时，也可以很方便的做离线缓存。 Controller层持有网络1.获取初始数据controller发起网络请求，并且在数据返回时对view进行配置，controller只维护前一次请求所获取的数据的内存缓存。因为网络获取数据是一种延时操作，所以需要添加数据获取过程处于不同的状态、已经状态变更的额外逻辑。 2.更改数据数据的更改现在也是一个通过网络执行的异步任务，view action传递到controller中，controller发起数据变更的网络请求，并且在数据返回时更新view。 3.思考&amp;讨论Controller层持有网络将大量的新的职责放到了controller中，包括发起网络请求，处理结果，以及处理网络失败等，这可以通过将这些代码封装为网络服务来减少controller中的代码。不过在这种方式还存在其他弊端：controller负责进行网络请求并持有数据，实际上数据的逻辑已经等同于view state，如果app中没有其他部分依赖这些数据，这种方式也可以良好工作，但如果数据需要在不同controller中进行使用，缺少model层让数据共享变得更加麻烦，而且即使当前不需要共享，也需要考虑到未来可能会有变更，所以从一开始就选择对未来友好的方式可能会更加明智。 Model层持有网络1.加载初始数据创建model对象，调用model的数据加载方法，在model的方法中，去触发相应的网络请求，根据请求的结果，model更新自己，而controller则观察model的变更并更新相应的view即可。 2.更改数据controller与model进行交互，就好像model只是本地数据一样，网络则发生在model层的背后。但对于model如何触发网络请求，则有两种不同的可选方式： model直接发起网络请求：在model数据变更的相应接口中，直接发起网络请求，同步数据的变更。 网络服务观察model的变更：封装的网络服务观察model，model在数据变更时触发某种通知，网络服务在接收到信号时，再发起相应的网络请求。 第二种方式让model层和网络层进一步的解耦，同时因为封装了相应的网络服务，可以使用一个更改队列来对这一类网络请求做统一管理，并对待处理更改队列进行持久化，这样即使APP离线时(断网、退出、崩溃)本地更改也不会丢失。 3.讨论&amp;思考model持有网络为代码增加了一些复杂度，但也具有更多的能力：保留了model，让controller之间的数据共享更加方便，同时也很容易做数据的离线缓存；通过添加网络服务部件来管理数据同步的网络请求，可以在APP中立即更新数据，而不用等服务器的响应，但同时也需要增加额外的代码，来追踪未提交的变更，并对变更提交是可能发生的冲突进行处理。持有网络是对APP未来变更和扩展更加友好的方式，是更加推荐的网络层架构模式。]]></content>
      <categories>
        <category>APP架构</category>
      </categories>
      <tags>
        <tag>APP架构</tag>
        <tag>AppArchitecture</tag>
        <tag>网络层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP架构（五）-- MVC+VS]]></title>
    <url>%2F2019%2F01%2F12%2FAPP%E6%9E%B6%E6%9E%845-MVC-VS%2F</url>
    <content type="text"><![CDATA[Reference:《App Architecture》 MVC+VC是MVC的一种变体，所不同的是它将view state视为model层的一部分，用view state model进行存储，ViewController观察view state model，并且相应地更新 view 层级。 MVC+VS中的反馈回路： MVC+VS对MVC的改进在于：提供了一种一致的处理view state变更的方法，让view state可以被持久化，同时对view state的数据管理也变成了单向数据流。 MVC+VC中view state的数据流： 除了对view state的处理变成了单向数据流，MVC+VS中对view state使用model抽象还带来了三点好处： Model通过接口和程序其余部分交流，在有需要时，对接口中的实现进行替换，并不会影响到接口和对接口的使用 Model为action提供了单一的事实来源，让重构和测试可以只关注单一的某个点 对Model的观察和响应可以被不同的action重用，所以结构的扩展性会更好 关于view state model有两点需要特别注意： 虽然view state model与文档(数据)model是同一层抽象，并遵循相同的使用规则，但还是应该保持分离，这是因为文档(数据)与view state生命周期并不相同 view state model中仅仅是存储了代表view state的简单值，并不包含对数据的变形(这部分逻辑依然写在ViewController中)，这是其和MVVM中的view-model最本质的区别 一、MVC+VS的实现1.构建与MVC和MVVM中先构建ViewController不同，MVC+VS中需要首先构建view state，然后在view state所触发的观察回调中，去构建ViewController，再由ViewController构建其他部件。但由于view state的观察者就是ViewController，因此在view state的构建之前需要至少一个ViewController，所以第一个ViewController即Root ViewController比较特殊，它在view state之前构建。 2.将View连接到数据MVC+VS从view state model和文档(数据)model中拉取数据，并订阅这些数据，然后将这些数据关联到view上去。需要注意的是MVC+VS的标准模式是，文档(数据)model对象的标识应该存储在view state model中，这就意味着对文档(数据)model的观察是依赖于view state的，对文档(数据)model的观察必须在对view state model的观察之后。 绝大多数应用场景中，ViewController的文档(数据)model的标识符在ViewController的生命周期中都不会更改，但如果有需要改变的情况，必须在view state model的观察回调里面，重新加载文档(数据)model，并重新创建创建对文档(数据)model的观察。 3.更改Model更改model的回路MVC+VS和MVC中是一样的：view将action传递给ViewController，ViewController直接更改model，同时ViewController中观察了model，当model变更时做相应的view更新。 4.更改View StateMVC+VS为view state的处理添加了一条和文档数据处理相似的路径：view将action传递到ViewController，ViewController更改view state model，同时ViewController中观察了view state model，当view state model变更时做相应的view更新。 ####状态恢复MVC+VS的架构在view state model中维护了完整的view state，将view state model序列化保存，再根据其构建ViewController和ViewController的层级，即可完成状态恢复，状态恢复时的代码路径和初始构建的代码路径是一致的。 5.测试MVC+VS和MVC中都使用集成测试，但实现上有很大的不同，第一个不同在于MVC+VS中不再需要先构建ViewController树，而是构建Root ViewController和view state model即可，包括ViewController树在内的其余部分都将作为view state的响应被自行创建出来。这样就可以通过提供view state model作为根ViewController的输入，以特定的状态构建出app的一个新的实例(状态恢复)。 MVC+VS书写测试时的另外一个不同在于研究对action的响应时，MVC中研究对action的响应，可能需要等待动画或其他异步更改的完成，MVC+VS中“对于view action的响应所造成的view state更改” 与 “view state更改引起view层级中的更新”这两段路径的测试是可以分离开的。也就是说可以直接验证view state来确保某个action确实对数据进行了合适的变更，而不需要等待action执行动画并且最终更新view，这部分路径的测试代码会变得好写很多。至于view state的变更引起view更新的这段路径，则可以为它编写单独的测试。 二、MVC+VS的优缺点MVC+VS最大的好处在于为view state变更的通讯创建了一致的机制，对view state使用观察者模式也保证了UI的同步；同时原本发生在ViewController之间的通讯，现在也可以通过view state来完成；最后，因为view state model上维护了完整的view state，所以也能很方便的完成状态日志、状态恢复、时间旅行调试等功能。 MVC+VS在实践中一个比较麻烦的问题在于并不是总能在UIKit更新view层级之前捕获到view state的变化，比如NavigationController返回按钮和返回手势所引起的层级变动，这需要我们设置NavigationController的delegate，在页面层级变动完成，而这种变动又不是由view state的变更所引起时(由返回按钮和返回手势所引起)，去对view state进行更新和处理，其他类似的情况也需要我们去添加代码支持。 三、MVC+VS架构的优秀经验1.数据的依赖注入在对象初始化的时候将数据作为参数传递进去就叫依赖注入，在MVC+VS中为ViewController设置初始的view state model时便是选用的这种方式，这样可以避免直接访问单例，更方便书写测试，同时这也比初始化时先设置为nil再等之后提供非nil的方式更加简单，这种方式也可以用于其他基于ViewController的模式中。 2.全局View State通讯但view state会被多个ViewController或view共享时，使用单例来保存view state以提供全局的view state通讯，往往比在这些ViewController或view的共同祖先中保存view state更加的简单直接，它还不需要去考虑ViewController或view层级间的通讯管道。 3.简化本地View State可以把一个简化版的MVC+VS应用到MVC的单个ViewController中：将部分view state抽象出来，用一个对象存储(字典或自定义类)，将这个对象设置为ViewController的属性，并对这个属性进行观察，在该属性变更的时候对view做这部分view state的更新，这种方式在一定程度上能缓解复杂的ViewController中view state的交互问题。]]></content>
      <categories>
        <category>APP架构</category>
      </categories>
      <tags>
        <tag>APP架构</tag>
        <tag>App Architecture</tag>
        <tag>MVC+VS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP架构（四）-- MVVM+C]]></title>
    <url>%2F2019%2F01%2F06%2FAPP%E6%9E%B6%E6%9E%844-MVVM%2F</url>
    <content type="text"><![CDATA[Reference:《App Architecture》 Model-View-ViewModel(MVVM)是一种基于MVC进行改进的模式，它将所有model相关的任务（观察model变更，将model数据变形，以及更新model）从controller层抽离出来，放到新的叫做view-model的一层对象中。引入view-model层的主要目的有两点： 鼓励将model和view之间的关系构建为一系列的变形管道。 将view应该展示的状态通过一套独立于app框架的接口进行呈现。 在MVVM中为了保持view与view-model的同步，MVVM强制使用某种形式的绑定，这通常通过响应式编程来完成。MVVM在一定程度上解决了MVC最大的两个问题，首先通过将model观察的代码以及其他显示和交互逻辑移动到围绕着数据流构建的隔离的view-model中，解决了MVC中ViewController里不规则的状态交互所带来的有关问题，在很大程度上缓解了ViewController肥大的问题；然后view-model还为场景的view state提供了一套干净的接口，让它可以独立于app框架进行测试，解决了MVC难以测试的问题。 MVVM+C中APP的反馈回路： 在MVVM+C中，协调器在APP启动完成的最后阶段创建，对于MVVM而言，协调器并非是强制需要的部件，但引入协调器来负责维护ViewController的层级，可以进一步分担ViewController的工作，让其变得更加的简单，这符合MVVM的架构思路，协调器分担的职责主要为：管理其他controller的展示，同时协调model数据和controller之间的通讯。协调器的工作方式有两种： 作为ViewController的delegate，ViewController把导航行为直接转发给协调器。 把导航行为先转发给view-model，然后让协调器去观察view-model，以获取导航事件。 第一种更加简单直接，但如果导航事件是依赖于当前view的状态或者model数据的话，第二种做法将更加合理，同时第二种做法也更利于代码测试。 一、MVVM的实现1.构建MVVM构建的方式和MVC很相似：ViewController充分了解程序的结构，并且对其它所有部件进行构建和连接。此外，相比起MVC主要有三点不同： 必须创建view-model。 必须建立起view-model和view之间的绑定。 Model由view-model拥有，而不是由controller所拥有。 view-model的创建有在ViewController创建时创建默认值、作为参数传递给ViewController的依赖注入、和在ViewController加载后延迟创建三种方式。 2.将View连接到数据在MVVM+C中，将View连接到数据的数据管道： 协调器为每个ViewController的view-model设置初始的model对象。 view-model将设定值和其他model数据及观察量进行合并。 view-model将数据变形为view所需要的形式。 ViewController使用响应式编程框架来将准备好的值绑定到各个view上去。 3.更改ModelMVVM-C中，View Action的事件回路和在MVC中各层之间的路径相似，不同在于，在ViewController和model之间插入了一层额外的用于协调的view-model： view通过target/action机制、delegate、或者响应式编程框架扩展，将View Action传递给ViewController； ViewController接收到View Action时调用view-model的相应接口； view-model的接口中直接更改model； view-model观察model的变更，并在变形后通过可观察值暴露给ViewController； ViewController中已经将可观察值和view进行了绑定，将会在这些值变化是更新view。 4.更改View State同MVC一样，部分view state依然隐式存储在view中，但原本那些由ViewController通过属性所保存的view state，在MVVM-C中由view-model显式地进行表示。view-model只负责那些会被view行为影响的view state，对于既不依赖于任何的view-model属性，也不是view-model所依赖的view state，并不需要通过view-model管理。 更改view state的事件回路和更改model的事件回来近似，只是少了view-model更改model，并观察model的变更且变形为可观察值的步骤： view通过target/action机制、delegate、或者响应式编程框架扩展，将View Action传递给ViewController； ViewController接收到View Action时调用view-model的相应接口； view-model的接口中直接更改自己存储的view state可观察值； ViewController中已经将可观察值和view进行了绑定，将会在这些值变化是更新view。 对于影响ViewController层级的view state变更，MVVM+C中根据协调器的工作方式不同，可以由ViewController通过delegate直接将事件传递给协调器处理，也可以将事件处理为view-model的可观察值，协调器订阅这些课观察者，当消息触发时，做相应的视图层级管理。 5.测试MVVM通过引入view-model层，提供了清晰且独立于app框架的接口，所以对于view-model及以下层次的代码，使用接口测试将非常方便，而对ViewController及View中的代码逻辑的测试则依赖于Xcode的UI测试或人工测试。MVC使用的集成测试，更偏向于功能而不是代码，虽然代码覆盖率比接口测试更高，但却难以编写和维护；相比而言，MVVM的接口测试由于只需要关注自己编写的view-model和接口，而且很少需要异步测试，其编写和维护都有方便得多。 接口测试的经典模式是：构建输入，再构建用来传递输入的接口，然后从接口中读取结果。MVVM中在配置测试环境和数据后，需要做的测试工作主要包括展示测试和行为测试： 展示测试：对view-model上所暴露的每一个可观察量，对初始值进行测试然后执行操作，并测试后续的条件。 行为测试：测试初始条件，执行操作，然后测试接下来的条件。 二、MVVM的优缺点MVVM的优点主要是低耦合和方便测试，此外的利于分工合作和方便代码迁移和复用，都是低耦合的延伸。MVVM也有一些自身的缺点，它们主要体现在： 更多的代码：因为引入view-model层，最直观的感受就是类变得更多，在处理简单的场景时代码量增多，但在处理相对复杂的状态交互时，MVVM更加清晰的逻辑，反而会让编码工作变得更加简单。 更难以调试的BUG：MVVM一般选用响应式编程来做数据绑定，这会使得一处的BUG被快速的传递到别的地方，当你在某处发现问题时，定位它是因为数据变形管道上的哪一步出了BUG，将会更加的不容易。 不利于重用的view：有的MVVM中对于view采用双向绑定，不仅将model的数据绑定到view上，还将view的action和model进行绑定，这将降低view的可重用性，应避免对view使用双向绑定，而是应该将view的action通过通用的方式传递给ViewController，再由ViewController调用view-model的接口做相应处理。 基于响应式编程：MVVM中通常都会使用响应式编程来做数据绑定，这比其它方案更加方便简洁，响应式编程的学习曲线稍加陡峭，但理解响应式编程对编码工作者绝对大有裨益。 三、MVVM与响应式编程响应式编程是一种用来描述数据源和数据消费端之间数据流动的模式，响应式编程将这种流动描述为一个变形管道。MVVM并非必须使用响应式编程，但观察model数据并将其变形为view-model上的一系列可观察值，再在ViewController中将这些可观察值绑定到view上，对于这条路径，在MVVM中通常是推荐使用响应式编程来完成，也可以使用基于KVO等技术的其他方案，但那需要做更多的额外工作，而且使用起来也没有响应式编程这种对口的方案方便。 四、MVVM架构的优秀经验1.引入额外的层MVVM在MVC基础上引入view-model这额外的一层抽象来构建数据管道，将抽象的数据(model中的)变形为特定的数据(view里的)，这种模式也可以在程序中的其他部分使用，例如： App-model：构建一个App-model，将用户凭证、系统服务信息(如网络是否可用)等数据合并、变形，然后作为可观察值提供给其他view-model使用，这种model也可以称之为setting-model。 Session-model：用于追踪当前登录会话的细节，可能需要在view-model和主 model之间，或者view-model和其他接口之间，进行网络请求的处理。 数据流-model：model版本的协调器，用来将导航状态作为数据进行建模，并将导航状态和model数据合并，直接为view-model提供可观察的model数据。 Use case：Use case指的是那些用来对主model进行切片准备，并且用来简化所要执行操作的任意类型的接口或者model。Use case和view-model很像，但是它并不被绑定在一个单独的ViewController上，而是可以在view-model之间进行传递或者共享，从而在多个view-model中提供可重用的功能。当一个app有多个view显示同样的底层数据时，我们可以使用共通的Use case对象来对从model获取数据和将数据写回model的操作进行简化。 2.引入协调器协调器是独立于MVVM的模式，它也可以用于其他APP架构中，通过引入协调器可以减轻ViewController的职责，让ViewController无需知道其他ViewController的信息，同时也让页面层级管理的逻辑集中在了一起，方便代码的维护。 3.分离数据变形MVVM中通过view-model将数据变形的逻辑从ViewController中抽离了出来，这种分离让ViewController变得更加整洁，让数据变形的代码更加清晰，同时也更易于测试。如果有需要，即使不是在MVVM中，也可以通过添加辅助对象来同样的对数据变形逻辑进行分离，特别是数据变形牵涉到比较多的数据和逻辑的时候。]]></content>
      <categories>
        <category>APP架构</category>
      </categories>
      <tags>
        <tag>APP架构</tag>
        <tag>App Architecture</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP架构（三）-- MVC]]></title>
    <url>%2F2018%2F12%2F22%2FAPP%E6%9E%B6%E6%9E%843-MVC%2F</url>
    <content type="text"><![CDATA[Reference:《App Architecture》 MVC基于经典的面向对象原则:对象在内部对它们的行为和状态进行管理，并通过类和协议的接口进行通讯。MVC中view对象通常是自包含且可重用的；model对象独立于表现形式之外，且避免依赖程序的其他部分；controller层负责将model层和view层撮合到一起工作，controller对另外两层进行构建和配置，并对model对象和view对象之间的双向通讯进行协调。 MVC中APP的反馈回路： iOS中标准的MVC是三种不同的子模式的集合: 组合模式：view被组装成为层级，该层级按组区分，由controller对象进行管理 策略模式：controller对象负责协调view和model，并且对可重用的、独立于app的view在app中的行为进行管理 观察者模式：依赖于model数据的对象必须订阅和接收更新 在所有模式中，MVC通常都是代码量最少，设计开销最小的模式。MVC模式有两个主要的缺陷，其一是view controller拥有太多的职责，所导致的“massive view controller”；同时MVC也难以测试，特别是单元测试和接口测试非常困难，而比较可行的集成测试的编写也并非易事。 一、MVC的实现1.构建Cocoa MVC程序的创建过程会完成对三个对象的创建：UIApplication对象，Application delegate，以及主窗口的根ViewController。这三个对象的默认配置文件分别为：Info.plist，AppDelegate和Main.storyboard。同时它们又提供了对后续启动流程进行配置的地方，这三个对象都属于Controller层级，所以说Controller层负责了所有的构建工作。 MVC app中的View不直接引用model对象，View将保持独立可重用，model对象将被存储在ViewController中，ViewController将变成了个不可重用的类，model对象赋予了ViewController对应的身份。 2.将View连接到数据在MVC中Controller根据初始的model对View进行配置，并观察model，在model的变更通知到到达时做相应的View变更。 在ViewController上设置一个初始model值时，有三种不同的方式: 通过判定controller在controller层级上的位置以及controller的类型，直接访问一个全局的model对象 开始时将model对象的引用设置为nil并让所有东西保持为空白状态，直到另一个controller提供了一个非nil值 在controller初始化时将model对象当作参数传递进来(也就是依赖注入) 在构建阶段结束后，对于view层级的变更应该遵循MVC中观察者模式的部分，只发生在观察的回调中。 观察者模式是在MVC中维持model和view分离的关键。这种方式的优点在于，不论变更究竟是源自哪里(比如，view事件、后台任务或者网络)，我们都可以确信UI是和model数据同步的。而且，在遇到变更请求时，model将有机会拒绝或者修改这个请求，即使model被以其他方式(比如一个网络事件)改变，或者是model拒绝这次变更时，UI也会正确更新。这是一种确保view层始终与model层同步的十分健壮的方式。 3.更改ModelView Action的事件回路： view通过target/action机制和delegate等方式将View Action传递给ViewController； ViewController接收到变更model的View Action时直接更改model； ViewController通过观察者模式响应model变更并更新view。 4.更改ViewStateMVC的model层起源于典型的基于文档的app：任何在保存操作中写入文档的状态都被当作是model的一部分来考虑。其他的任意状态（包括像是导航状态，临时的搜索和排序值，异步任务的反馈以及未提交的更改）传统意义上是被排除在MVC的model定义之外的，我们把这些状态统称为view state。在MVC中，这些被我们统称为view state的“其他”状态没有被包含在模式的描述中。 依照传统的面向对象的原则，任意的对象都可以拥有内部状态，这些对象也不需要将内部状态的变化传达给程序的其余部分。基于这种内部处理，view state不需要遵守任何一条程序中的清晰路径。任意view或者controller都可以包含状态，这些状态由View Action进行更新。view state的处理尽可能地在本地进行:一个view或者ViewController可以独自响应用户事件，对自身的view state进行更新。 如果想要在view层级的不同部分共享view state，有两种方式： 找到它们共同的祖先，并在那儿管理状态 使用单例来管理状态 实际操作中，将view state放到层级的顶层controller对象中的做法（即第一种方式）并不常⻅，因为这会要求层级的每一层之间存在通讯的管道。 5.测试自动测试可以由好几种不同形式进行。从最小的粒度到最大的粒度，它们包括: 单元测试：将独立的函数独立出来，并测试它们的行为 接口测试：使用接口输入并测试接口输出得到的结果，输入和输出通常都是函数 集成测试：在整体上测试程序或者程序的主要部分 单元测试只花了十多年的时间就成为了app中最常⻅的测试方式。不过即使是现在，许多app除了人工测试以外并没有进行常规的自动测试。如果想要在代码层级对MVC的controller和model层进行自动测试，可行的选项是写集成测试，但想要正确书写集成测试，需要大量关于Cocoa框架是如何操作的知识，这并非易事。在MVC中，我们需要从window开始构建ViewController树和view树，在树构建出来后便可以选择以新创建出来的树作为单个集成测试单元进行测试：书写代码触发事件，然后与我们的预期进行验证。 二、MVC的问题观察者模式失效第一个问题是，model和view的同步可能失效。当围绕model的观察者模式没有被完美执行时，这个问题就会发生。常⻅的错误是，在构建view时读取了model的值，而没有对后续的通知进行订阅。另一个常⻅错误是在变更model的同时去更改view层级。解决方法只有严格地遵守观察者模式：当读取model值时，也需要对它进行订阅。 肥大的ViewControllerViewController需要负责处理view层(设置view属性，展示view等)，但是它同时也负责controller层的任务(观察model以及更新view)，最后，它还要负责model层(获取数据，对其变形或者处理)。结合它在架构中的中心⻆色，这使得我们很容易在不经意间把所有的职责都赋予ViewController，从而迅速让程序变得难以管理。 关于肥大的ViewController最主要的争论不是关于代码的行数，而在于所保存的状态的数量。当整个文件就像ViewController这样是一个单独的类的时候，所有的可变状态都将被文件中的各个部分共享，每个函数需要精诚合作，来共同读取和维护这些状态，避免彼此矛盾，这无疑是会让代码的可读性和可维护性都越来越差。 三、MVC的改进观察者模式最好是有一种方式，能让对View的初始设定和在viewDidLoad中对model建立观察者之间没有时间空隙。使用键值观察(KVO)来替代通知是可选项之一，但是，在大部分情况下这通常需要同时观察多个不同的键路径，这让KVO和通知的方式相比，实际上并没有更加稳定。在Swift中KVO由于需要每个被观察的属性都声明为dynamic，这也让它在Swift中远远没有在Objective-C中那样流行。 对观察者模式最简单的改进方式是，将Noti􏰊cationCenter进行封装并为它实现KVO所包含的初始化的概念。这个概念会在观察被建立的同时发送一个初始值，这允许我们将设定初始值和观察后续值的操作合并到一个单一管道中去。另外一种可行的思考是，将观察者模式替换为在MVVM中比较常用的响应式编程，这样可以借助一些响应式编程框架，将对初始值的设定与后续观察都合并在一次订阅操作中，同时也保证了model与view的同步，例如在ReactiveCocoa中，对KVO的封装也让这类代码的书写非常地方便。 肥大ViewController的问题ViewController主要的工作为：观察model，展示view，为它们提供数据，以及接收View Action。造成肥大ViewController的原因就是ViewController通常还负责了主要工作之外的无关工作，这些额外的工作有的应该被分散到较小层级的Controller中，这些Controller各自管理一个较小部分的view；有的则可以通过接口和抽象将其封装起来，作为工具类使用；还有的功能则是应该移动到model层中，比如排序、数据获取和处理等方法，它们与app的数据和专用逻辑相关，把它们放在model中会是更好的选择。 所以解决肥大ViewController的主要思路有： 使用较小层级的Controller通过将主要的view的逻辑分散到它们自己的更小的controller中，简化场景的view依赖，在父ViewController中剩下的工作就只有集成和布局了 将部分任务封装成工具类可以创建工具类来执行像是获取用户位置信息这种异步任务，这样，在controller中需要的代码就只是创建任务和回调闭包 将数据相关的逻辑放在model中例如排序、数据获取和处理等方法，包括数据网络层的获取与处理，交由model管理将更加的合理 属于各个部件的逻辑应当尽可能地集成到各自的部件中去，将部分ViewController中的代码抽离出来，在本质上并没有降低整个程序的复杂度，但是这么做确实降低了ViewController本身的复杂度。 降低ViewController的复杂度的其他手段还包括： 使用代码而不是segue如果不使用segue，而是选择用代码来定义view层级，能在构建阶段有更多的控制力，其中最大的优点在于，可以更好地掌控依赖，这样可以让页面跳转时对ViewController的配置更加的方便可控。 在扩展中进行代码重用在不同的ViewController间共享代码，最常⻅的方法是创建一个包含共通功能的父类，另一种选择是使用扩展(类别)。相较于继承，这种重用代码的方式，在降低ViewController复杂度的同时，并没有提高继承链的复杂度。 利用ChildViewController进行代码重用ChildViewController是在ViewController之间共享代码的另一种选项，它符合使用较小层级Controller的思路，是降低ViewController复杂度同时提高代码重用的有效方式。 提取协调controller许多大的ViewController都有很多⻆色和职责，除了一些具体的任务可以抽离成工具类之外，其他的一些职责事务也可以通过对象提取出来，对这些提取出来的事务对象做泛型抽象后，还能在其他有相似事务的ViewController中重用 苹果将controller的主要职责分为协调controller(coordinating controller)和调解controller(mediating controller)。一个协调controller是app特定的，而且一般来说是无法重用的(即ViewController的主要工作部分)。调解controller则是一个可重用的controller对象，通过配置，它可以被用来执行特定的任务。通常，用来遵守某个协议的代码(比如ViewController中遵守UITableViewDataSource的部分)，比较适合被提取为调解controller，再将提取出来的对象进行泛型抽象，让部分差异化逻辑通过block等方式从外面传递进来，这个提取出来的对象，便能用于有相似调解controller逻辑的ViewController中。需要注意的是，分离controller的逻辑能降低ViewController的复杂度，但是当两个部件紧密耦合在一起，并且需要对很多状态进行通讯和共享的时候，分离后所带来的开销可能会非常大，反而使得事情变得更加复杂，这时不分离反而是更好的选择。 简化View配置代码如果ViewController需要构建和更新非常多的view，那么将这部分view配置的代码提取出来，对于降低ViewController的复杂度也非常有效，特别是对于那些不需要双向通讯的配置]]></content>
      <categories>
        <category>APP架构</category>
      </categories>
      <tags>
        <tag>APP架构</tag>
        <tag>App Architecture</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP架构（二）-- 概览]]></title>
    <url>%2F2018%2F12%2F16%2FAPP%E6%9E%B6%E6%9E%842%2F</url>
    <content type="text"><![CDATA[Reference:《App Architecture》 iOS开发官方钦定的设计模式是MVC，而MVC及其两种变形：MVVM+C和MVC+VS，是学习iOS APP架构最需要掌握的三种设计模式，这三种设计模式都是基于场景进行的架构，它们其实都是观察者模式、策略模式和组合模式三种设计子模式的集合。 MVCMVC源于Smalltalk中所发展出的分离展示部分的理念，也就是view层和model层应该被完全隔离开，这带来了一个强烈的需求，那就是要引入一个支持对象来辅助两者之间的通讯，这个支持对象在MVC中就是Controller。MVC中Controller对象负责处理model或者view层范畴之外的所有任务。Controller层接收所有的view action，处理所有的交互逻辑；发送所有的model action，接收所有的model通知，对所有用来展示的数据进行准备，最后再将它们应用到View的变更上去。构建和导航任务也由Controller负责。 1.构建Model和View：MVC中View和Model的构建都由Controller负责，App对象负责创建最顶层的view controller，这个view controller将加载view，并且要么显式地创建和持有model层，要么通过一个延迟创建的model单例来获取model。 2.变更ViewMVC中，Controller需要观察model，在收到model变更的通知时去变更View。当一个更改model的View action发生时，为了保证单向数据流原则，Controller应避免去直接操作View层级，标准的做法是：View action转变为model变更，然后model发送通知，Controller订阅model通知，并且在当通知到达时再更改View层级。 3.更改ModelMVC中，Controller主要通过target/action机制和delegate来接收view事件。Controller知道自己所连接的view，而view在编译期间并不知道Controller接口的信息。当一个View事件到达时，Controller有能力改变自身的内部状态，更改model，或者直接改变View层级。 4.View StateMVC中View State可以按需要被储存在View或者Controller的属性中，MVC中那些只影响View或Controller状态的action通常也不需要通过model进行传递，而页面层级或导航状态也由Controller进行维护。 5.测试MVC中View Controller与app的其他部件紧密相连，这导致层级间缺乏清晰的边界，单元测试和接口测试都十分困难，集成测试是MVC最可行的测试手段。 MVVM+CMVVM+C就是MVVM加Coordinator(协调器)。MVVM在每个场景中使用View-model来描述场景中的表现逻辑和交互逻辑，使用Coordinator来管理View controller层级。View-model在编译期间不包含对view或者controller的引用，它暴露出一系列属性来描述每个view在显示时应有的值。将这些值设置到View上的工作，通常由预先建立的绑定来完成(响应式编程)，绑定会保证当这些显示值发生变化时，把它设定到对应的View上去。Coordinator(协调器)是在场景间切换时负责提供逻辑的对象。协调器持有对model层的引用，并且了解View controller树的结构。MVVM-C中的View controller通过delegate的机制将Viewcontroller的信息告诉协调器，协调器据此显示新的Viewcontroller并设置它们的 model数据。MVVM+C中view controller不再拥有内部的View state，这些状态也被移动到了View-model中，view controller 仅仅只是View层级的一部分。 1.构建Model：在MVVM中model的创建和MVC中相同，通常由一个顶层controller负责。不过model对象属于view-model，而不再属于view controller。View：view层级的创建也和MVC中一样，通过storyboard或者代码来完成。和MVC不同的是，view controller不再直接为每个view获取和准备数据，而是由view-model负责。View-Model：View controller在创建的时候会一并创建view-model，并且将每个view绑定到view-model所暴露出的相应属性上去。 2.变更View在MVVM中，和MVC不同，view controller不监听model。View-model将负责观察model，并将model的通知转变为Viewcontroller可以理解的形式。View controller订阅view-model的变更(响应式编程)，当一个view-model事件来到时，再由Viewcontroller去更改View层级。 3.更改Model在MVVM中，view controller接收View事件的方式和MVC中一样(target/Action和delegate)。不过，当一个View事件到达时，view controller不会去改变自身的内部状态、view state、或者是model，而是调用view-model上的方法，再由view-model改变内部状态或者model。 4.View State在MVVM中，View state要么存在于View自身之中，要么存在于view-model里。和MVC不同，view controller中不存在任何View state。View-model中的View state的变更，会被controller观察到，不过controller无法区分model的通知和View state变更的通知。在MVVM+C中，Viewcontroller层级将由协调器进行管理。 5.测试在MVVM中，因为view-model的引入，View层与controller层是解耦合的，所以可以使用接口测试来测试view-model，而不需要像MVC里那样使用集成测试，接口测试要比集成测试简单得多。 MVC+VSMVC+VS是为标准的MVC带来单向数据流方式的一种尝试，通过MVC+VS能加深编程人员对view state和单向数据流的理解。在MVC+VS中，我们明确地在一个新的model对象中，对所有的view state进行定义和表达，我们把这个对象叫做view state model。我们不从 view 中去读取view state，而是从view state model中去获取它们。MVC+VS也具有独到的优点，例如：任意的状态恢复，完整的用户界面日志，以及极为强大的调试能力(通过设置不同的view state)。 1.构建在MVC+VC和MVC一样，model和view的构建工作依然由view controller负责，但MVC+VC中view controller还需要使用和订阅view state。 2.变更View在MVC+VS中Controller同时对文档model和view state model进行观察，并且只在变更发生的时候更新view层级(单向数据流原则)。 3.更改Model当view action发生时，view controller去变更文档model(这和MVC相同)或者变更model state。MVC+VS中不会去直接改变view层级，所有的view变更都要通过文档model和view state model的通知来进行。 4.View StateView State被明确地从view controller中提取出来,由view state model维护，处理的方法和model一样：controller观察view state model，并且对应地更改view层级。 5.测试在MVC+VS中，使用和MVC里类似的集成测试，但是测试本身会非常不同：所有的测试都从一个空的根view controller开始，然后通过设定文档model和view state model，这个根view controller可以构建出整个view层级和view controller层级。一旦view层级被构建，我们可以编写两种测试。第一种测试负责检查view层级是不是按照我们的期望被建立起来，第二种测试检查view action有没有正确地改变view state。]]></content>
      <categories>
        <category>APP架构</category>
      </categories>
      <tags>
        <tag>APP架构</tag>
        <tag>App Architecture</tag>
        <tag>MVC</tag>
        <tag>MVVM</tag>
        <tag>MVC+VS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP架构（一）-- 概论]]></title>
    <url>%2F2018%2F12%2F08%2FAPP%E6%9E%B6%E6%9E%841%2F</url>
    <content type="text"><![CDATA[Reference:《App Architecture》 1. 软件架构和APP设计模式软件架构是软件设计中的分支，它关注两个方面： 如何将软件分解成不同的接口和概念层次部件； 这些部件自身和部件之间的不同操作中所使用的控制流和数据流路径。 一个好的APP架构依赖于一套有力的设计规则来定义部件的划分以及部件之间的相互协作方式，在架构中一套被重复使用的设计规则称为设计模式。 app的设计模式基本就是一套分层规则，app中不同的部件会被归纳到某个类型中去，将这些不同的种类叫做层次：一个层次指的是，遵循一些基本规则并负责特定功能的接口和其他代码的集合。 2. Model和ViewModel和View是APP架构中最常见也是最基础的两个分层。 Model：Model层是APP的内容，它不依赖于任何APP框架，程序员对Model层有完全的控制。它通常包括model对象和协调对象。 View：View层几乎是完全依赖于APP框架的部分，它使Model层可见，并允许用户进行交互，从而将Model层转变为一个APP。 在APP中，View对象通常会构成一个单一的view层级，view controller也通常会形成 view controller层级。model对象却不需要有明确的层级关系，在程序中它们可以是互不关联的独立 model。 model层的最重要的意义在于：它为我们的程序提供一个表述事实的单一来源，让程序的行为有清晰的规则可以依据，这会让编程逻辑清晰、行为正确。如果 model 层能做到和应用框架分离，我们就可以完全在 app 的范围之外使用它。 3. 反馈回路用户界面是一个同时负责展示和输入功能的反馈设备，APP的逻辑就是一个反馈回路。用户发起的事件会导致view的响应，我们把由此引起的代码路径称为view action，当一view action被送到model层时，它会被转变为model action，将view action转变为model action的操作,以及路径上的其他逻辑被叫做交互逻辑。一个或者多个model对象上状态的改变叫做model变更。Model的变更通常会触发一个model通知，当view依赖于model数据时，通知会触发一个view变更，将model通知和数据转变为view 更改的操作，以及路径上的其他逻辑被叫做表现逻辑。 4. 单向数据流有些状态可能是在文档model之外进行维护的，例如导航状态。在app中非文档model的状态被叫做view state。在Cocoa里，大部分view对象都管理着它们自己的view state，controller对象则管理剩余的view state。当所有的状态都在model层中被维护，而且所有的变更都通过完整的反馈回路路径进行传递时，我们就将它称为单向数据流。即：任意的view对象或者中间层对象只能够通过 model发出的通知来进行创建和更新(换句话说view或者中间层不能通过捷径来更新自身或者其他的view)时，这个模式通常就是单向的。在遵循单向数据流的模式中，就实现了model与应用框架的解耦。 5. APP的任务一个程序的正常工作方式为：view必须依赖于model数据来生成和存在，我们配置view，让它可以对model进行更改，并且能在model得到更新时也得到更新。所以我们需要决定APP中如何执行下列任务： 构建：谁构建model和view，以及将两者连接起来？ 变更view：如何将model数据的变化应用到view上去？ 更新model：如何处理view action？ 处理view state：如何处理导航及其他model state以外的状态？ 测试：为达到一定程度的测试覆盖，采取怎样的测试策略？ 我们研究APP设计模式，就是研究一个设计模式如何处理以上五个APP任务。]]></content>
      <categories>
        <category>APP架构</category>
      </categories>
      <tags>
        <tag>APP架构</tag>
        <tag>App Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发中好用的三方轮子]]></title>
    <url>%2F2018%2F09%2F06%2FiOS%E4%B8%89%E6%96%B9%E8%BD%AE%E5%AD%90%E5%88%86%E7%B1%BB-OC%2F</url>
    <content type="text"><![CDATA[收录的库以Objective C为主，含少量Swift库； 以⚠️标记表示作者已多年(3年及以上)未更新；* 以🚫标记表示作者已声明不再维护升级。 1.用户界面层(User Interface)视图控件对于更新不够频繁或自定义接口不够丰富的视图控件，最好直接使用其源码，而不是通过Cocoapods导入 MJRefresh：下拉刷新，上拉加载 MBProgressHUD：好用易扩展的活动指示器 SVProgressHUD：轻量级的活动指示器 TWMessageBarManager：轻量的通知和警告提示库⚠️ TSMessages：轻量的通知和警告提示库 JDStatusBarNotification：顶部状态栏提醒 UIActivityIndicator-for-SDWebImage：为网络图片加载添加活动指示 PYSearch：一种使用样式较广的搜索页面 YYText：富文本 DTCoreText：富文本，可解析Html和CSS TTTAttributedLabel：富文本label M80AttributedLabel：富文本label SDCycleScrollView：轮播图 FSCalendar：日历插件 PGDatePicker：时间/日期选择器 DZNEmptyDataSet：无数据时的展示视图 SGPagingView：标签指示器 iCarousel：卡片的旋转切换 ZJPickerView：各列会联动的选择器 LMReport：常见报表表格样式 PPBadgeView：为各种视图添加badge WZLBadge:为视图添加badge WMPageController：分页视图控制器 FlatUIKit：扁平化风格的UIKit⚠️ JSQMessagesViewController：聊天消息类框架🚫 JVFloatLabeledTextField：带浮动标签的文本输入框 SWTableViewCell：支持左滑和右滑的tableViewCell⚠️ MGSwipeTableCell：支持左滑和右滑的tableViewCell tapkulibrary：自定义控件库，包括HUD、进度条、日历、CoverFlow等 MWPhotoBrowser：简单的照片浏览控件⚠️ ZZCircleProgress：可定制的环形进度条 BFNavigationBarDrawer：NavigationBar下的tool菜单 SXFiveScoreShow：五项素质评分所组成的五角星 UUChatTableView：IM聊天界面的封装 HyPopMenuView：类似微博效果的弹出菜单 DXPopover：带小箭头的弹出视图 DOPDropDownMenu：下拉菜单 ActionSheetPicker-3.0：底部弹窗选择器 MultilevelMenu：多级选择器，Swift实现 层级管理 CWLateralSlide：侧边抽屉效果的视图容器 ViewDeck：侧边抽屉效果的视图容器 ECSlidingViewController：双层子视图容器实现侧滑效果 MMDrawerController：轻量的侧边抽屉效果的视图容器⚠️ RDVTabBarController：三方封装的tabBarController 页面布局 Masonry：Autolayout代码布局库 PureLayout：Autolayout代码布局库 UITableView+FDTemplateLayoutCell：tableVeiwCell高度的自动布局 动画特效 GPUImage：图片添加滤镜⚠️ Shimmer：为视图添加流光效果 FXBlurView：添加毛玻璃效果🚫 NYXImagesKit：常规的图片处理 AwesomeMenu：弹射动画展开的菜单 Canvas：无需编码就能添加动画效果的库⚠️ JazzHands：在scrollview中绘制关键帧动画⚠️ pop：pop动画引擎 popping：基于pop引擎的动画库 pop-handapp：基于pop引擎的动画实例 VCTransitionsLibrary：转场动画库⚠️ UI层优化 FDFullscreenPopGesture：简化返回手势的管理 KMNavigationBarTransition：优化转场时的导航栏样式 ZYCornerRadius：避免离屏渲染的圆角设置 FastImageCache：本地图片的快速加载与渲染 Texture：通过异步绘制来提升性能的UI框架 nui：用类CSS的语法来简化UI样式的设置⚠️ 2.业务逻辑层(Bussiness Logic)APP任务 IQKeyboardManager：键盘事务管理 AYCheckVersion：更新检查 iVersion：更新检查🚫 Appirater：去AppStore评分 CocoaLumberjack：App的日志管理库 NSLogger：带mac客户端的日志分析工具 功能组件 TZImagePickerController：图片选择器 ZFPlayer：视频播放器及控制器 PNChart：图表绘制库(OC) Charts：图标绘制库(Swift) WebViewJavascriptBridge：OC和JS的交互库 AGEmojiKeyboard：emoji表情输入面板 ZFSetting：快捷构建设置界面 TOCropViewController：图片裁剪 EZAudio：音频波形图绘制⚠️ 便捷工具 ReactiveObjC：函数响应式编程框架 KVOController：方便安全的KVO工具 PromiseKit：Promise设计模式处理异步任务的库 JKCategories：系统库的类扩展 Colours：颜色库扩展 FormatterKit：为很多数据类型提供了格式化的转换 nimbus：开源的iOS开发框架 BlocksKit：为一些常用的系统接口提供block版本 Bolts-ObjC：GCD、NSOperation之外的多任务管理库 RegexKitLite：通过正则表达式处理字符串⚠️ Objective-C-RegEx-Categories：提供便捷的正则表达式使用接口⚠️ 3.数据访问层(Data Access)网络传输 AFNetworking：网络请求库 XMNetworking：基于AF的封装，使用方便，适合中小型项目 YTKNetwork：基于AF的封装，功能完备，适合复杂网络请求项目 MKNetworkKit：轻量的网络请求库 Reachability：判断网络可达性 RestKit：专注于RESTful API的网络请求、JSON解析、CoreData存储的框架 SDWebImage：根据网络连接获取图片 SocketRocket：facebook家的轻量级socket连接库⚠️ CocoaAsyncSocket：异步socket通讯 SocketRocket：webSocket客户端 XMPPFramework：XMPP通信框架 转换处理 GZIP：数据压缩与解压 MJExtension：JSON字典和模型相互转换 Mantle：JSON字典和模型的转换 json framework：JSON数据解析 JSONModel：JSON字典和模型的转换 hpple：XML/HTML解析 本地持久化 YYCache：NSCoding归档缓存 Realm：移动端本地数据库 MagicalRecord：对CoreData的封装 FMDB：对SQLite数据库的封装 KeychainItemWrapper：keychain钥匙串管理⚠️ SAMKeychain：keychain钥匙串管理 GVUserDefaults：对NSUserDefaults的方便存取 4.测试调试(Test &amp; Debug)调试类三方库在Cocoapods导入时需设置其编译环境仅包含Debug，即需要在三方库的引入后面加上:configurations =&gt; [&#39;Debug&#39;]，测试类三方库要注意仅加到测试target下 FLEX：强大的调试工具 MLeaksFinder：内存泄漏调试工具 JxbDebugTool：网络请求调试工具⚠️ NetworkEye：Http网络请求调试工具 PonyDebugger：通过Chrome调试网络流量和数据存储 KIF：基于XCTest的UI测试框架 Kiwi：BDD行为驱动开发测试框架]]></content>
      <categories>
        <category>三方库源码</category>
      </categories>
      <tags>
        <tag>三方库合集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP工作机制(一) -- APP生命周期]]></title>
    <url>%2F2017%2F12%2F25%2FAPP%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E4%B8%80-APP%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Reference:app的生命周期ios background modes 想要知道APP是如何工作的，第一步是弄清楚APP从开始运行到终止有哪些主要的状态，这些状态和状态切换时有哪些需要特别注意的要点。 简述应用程序主要有 Not Running(未运行)，Inactive(未激活)，Active(激活), Background(后台)，Suspended(挂起)五个状态，当状态即将改变或已经改变时，在AppDelegate中会执行相应的回调，开发中需要视需求，在状态变换的对应回调方法中，添加相应的处理。 概览 要点 Not Running和Suspended两种状态没有相应的回调 APP在刚启动和返回前台时都会触发applicationDidBecomeActive: APP进入后台前会先进入未激活状态 普通APP进入后台有5s时间执行代码，之后会被挂起 进入后台后通过beginBackgroundTaskWithExpirationHandler:可申请180s的时间 申请后台任务需和结束后台任务endBackgroundTask:成对出现 挂起的APP依然在内存中，但可能被系统终止，系统优先清理内存大的挂起APP APP将要被终止时会调用applicationWillTerminate:，有5s的任务执行时间 内容Background ModesAPP进入后台后可以按声明的特殊后台运行模式运行，APP可以拥有多种后台运行模式，但审核时如果被认为APP无需所声明的后台运行模式，则审核会被拒。后台模式可以通过info.plist中的Required background modes进行配置，也可以通过Capabilities-&gt;Background Modes进行配置(推荐方式)，APP的后台模式如下： Audio, AirPlay and Picture in Picture info.plist key: App plays audio or streams audio/video using AirPlay 音频播放、录制、使用AirPlay投放，画中画(iPad)，此类APP可以后台常驻 Location updates info.plist key: App registers for location updates 后台获取定位更新，此类APP也可以后台常驻 Voice over IP info.plist key: App provides Voice over IP services IP电话，此类APP同样会被挂起，但系统会接管其通信socket，当socket中有数据传来时，会唤醒APP并交回socket Newsstand downloads info.plist key: App processes Newsstand Kit downloads 杂志类应用，此类APP会被挂起和终止，但可使用NKAssetDownload后台下载杂志，并在下载成功后重新唤醒或启动APP External Accessory communication info.plist key: App communicates with an accessory 与MFi外设通信类APP，在外设消息到达时APP会被唤醒，有10s的执行时间 Uses Bluetooth LE accessories info.plist key: App communicates using CoreBluetooth 与Bluetooth LE设备通信类APP，在设备的消息到达时会被唤醒，有10s的执行时间 Acts as a Bluetooth LE accessory info.plist key: App shares data using CoreBluetooth 自身作为蓝牙外设的应用，此类APP可以后台常驻，但需要用户授权 Background fetch info.plist key: App downloads content from the network 后台定时更新，设置时间间隔，在间隔时间内启动应用更新数据，有30s执行时间 Remote notifications info.plist key: App downloads content in response to push notifications 静默推送，在静默推送到底时，回调对应方法下载内容，有30s执行时间 Background processing info.plist key: App processes data in the background 基于NSURLSession的后台传输，任务成功或失败时，APP会被唤醒并执行application:handleEventsForBackgroundURLSession:completionHandler:回调]]></content>
      <categories>
        <category>iOS基础</category>
        <category>APP工作机制</category>
      </categories>
      <tags>
        <tag>APP生命周期</tag>
        <tag>Background Modes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法基础]]></title>
    <url>%2F2017%2F11%2F18%2FMarkdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Reference:Mardown语法说明 Markdown的宗旨：Markdown的目标是实现易读易写。可读性无论如何都是最重要的。 与HTML的兼容Markdown对HTML兼容，Markdown之外的标签可以使用HTML撰写。需要注意的是HTML区块标签需要在前后加上空行和其他内容隔开，且要求开始和结尾标签不能用制表符(tab)或空格来缩进。在HTML区块标签间的Markdown格式语法不会被处理，但Markdown语法在HTML区段标签间是有效的，同时HTML区段标签也可以在Markdown段落中直接使用，。 &amp;与&lt;在Markdown的HTML区段中的如果出现这两个特殊字符，Markdown在转换时会将其自动转换为HTML的实体。 区块元素链接Markdown的链接有行内式和参考式两种，行内式易写，参考式易读。 行内式链接语法为中括号+小括号，中括号中是链接文字，小括号内为链接和title（title在鼠标悬停在链接上显示的提示信息），链接可以为同一主机的相对地址，title用双引号包起来，title可有可无。 链接使用+地址定义： This is [an example](http://example.com/ &quot;Title&quot;) inline link. 参考式链接语法为中括号+中括号，第二个中括号中为链接的标识，然后在任何位置（一般为文末或者段后）用标记:链接地址+&quot;title&quot;的方式将链接内容定义出来即可，链接标识不区分大小写，可以为空，为空时为隐式标识，即标识为前面中括号中的内容。 链接使用： This is [an example][id] reference-style link. 地址定义： [id]: http://example.com/ &quot;Optional Title Here&quot; 强调Markdown可为段落中的文字加斜体、粗体和删除线三种方式来进行内容强调。方法是为要强调的文字前后分别加*、**和~~，其中斜体和粗体分别会为文字加上&lt;em&gt;和&lt;strong&gt;标签。 代码如果要标记一小段的行内代码，可以使用反引号`将其包起来，如果要在代码段中使用反引号，可以使用一个以上的反引号的开始和结束代码段:代码段中有`。行内代码中的&amp;和&lt;&gt;同样会被转换为对应的HTML实体。 图片插入图片和插入连接的语法基本相同，也分为行内式和参考式，区别是插入图片需要在前面加上!，第一个[]中是图片的替代文字，并不会显示。Markdown不支持指定图片宽高，如果有需求可以使用HTML的&lt;img&gt;标签。 区段元素段落和换行Markdown的段落由一个或多个连续的文本行组成，一个段落的前后要求各有至少一个的空白行。Markdown允许段落中换行（插入换行符），并不会把换行符都转换为&lt;br /&gt;,连按两个空格再换行，Markdown才会将此换行符转为&lt;br /&gt;。 标题Markdown的标题支持Setext（底线）和atx两种形式的标题，但一般使用atx形式，即在行首插入1~6个#，对应1~6阶标题。 区块引用Markdown使用&gt;标记区块引用，Markdown允许只在段落的首行添加&gt;标记，同时区块引用可以嵌套，添加不同数量&gt;即可，而且在区块内也可以使用Markdown语法。 ####区块（示例） 三级区块 列表 Markdown的列表可分为有序列表和无序列表。有序列表使用数字接一个英文句点作为标记，数字可以是乱序的（会自动排），但最好保持有序。无序列表使用*,+和-作为标记，他们的功能一样，建议在做列表嵌套时使用不同的标记来做区分。第一级的列表标记一般放在最左边，但也可以缩进（最多3个空格，4个空格=一个tab，会被视为嵌套）。 注意：如果列表项目间用空行分开，在输出HTML时项目内容将会用&lt;p&gt;标签包起来。 列表的项目下允许有多个段落，每个项目下的段落都必须缩进一个tab。 列表项目中可以嵌套区块引用，需要在区块前加空行，并对区块进行一个tab的缩进，如下： 嵌套的区块 列表项目中还可以嵌套代码块，代码块需要前面加空行，并进行两个tab的缩进，如下： // 这就是代码 printf(&quot;hello, world&quot;); 列表下也可以嵌套表格 |左对齐标题 |右对齐标题 |居中对齐标题 | |:– |–: |:–: | |短文本 |中等文本 |稍微长一点的文本 | |稍微长一点的文本|短文本 |中等文本 | 如果一定会在句首出现数字+句点+空白，那么可以在句点前加上反斜杠\。 表格和其他区块一样，表格前也需要有空白行，使用|来区分列，第一行为标题，第二行指明同一列的文字对齐方式:--表示左对齐，--:表示右对齐，:-:表示居中对齐，---表示默认对齐方式，即标题居中内容靠左。表示对齐的符号可以有多个-，但-和:加起来要不少于三个。示例： 左对齐标题 右对齐标题 居中对齐标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 代码区块Markdown中使用一个tab的缩进和一个段落（前后加空行）即可插入代码块，代码块会持续到没有没有缩进的那一行,也可以不使用缩进，而是在代码块的前后加上各加一行三个（或以上）反引号`。在转换的时候，Markdown会将代码用&lt;pre&gt;和&lt;code&gt;标签包起来，在代码块中，Markdown语法不会被转换，而缩进的制表符也会被移除，同时&amp;、&lt;和&gt;这种HTML特殊符号也会自动转为HTML实体，例如： &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 分隔线可以使用三个及以上的*、-和减号来建立一个分隔线，分隔线行内不能有其它东西（*和-之间可以插入空格），例如： 分隔线还有分隔出单独一段的效果，为了避免直接在文字后加-，而和Setext（底线）标题语法混淆，分隔线前应留一个空白行，或建议使用****。 其他自动链接Markdown支持用比较简短自动链接形式来处理网址和电子邮箱，只需要用尖括号包起来即可。如邮箱&#121;&#x6f;&#x75;&#x78;&#x69;&#x61;&#110;&#x67;&#64;&#113;&#113;&#x2e;&#x63;&#111;&#x6d;，网址http://www.baidu.com。值得一提的是邮箱地址的字符会被Markdown转换为对应的16进制码的HTML实体，以防御一些邮箱收集机器人。 反斜杠Markdown中的语法符号要直接显示而不表示语义的时候，可以在符号前面加\来转义。对应的符号有： \ 反斜杠 ` 反引号 * 星号 _ 底线 {} 大括号 [] 中括号 () 小括号 # 井号 + 加号 - 减号 . 英文句点 ! 惊叹号]]></content>
      <categories>
        <category>工具教程</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
